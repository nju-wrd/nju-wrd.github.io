<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>子春廿一</title>
    <link>https://nju-wrd.github.io/</link>
    <description>Recent content on 子春廿一</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Sat, 11 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://nju-wrd.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>图形学实验笔记丨A0</title>
      <link>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a0/</link>
      <pubDate>Sat, 11 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a0/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a style=&#34;color: #0000FF;&#34; href=&#34;http://games-cn.org/forums/forum/graphics-intro/&#34; target=&#34;_blank&#34;&gt;论坛链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;要实现之前立的flag了，因为换了电脑加上前面的都忘掉了，所以重新完成一下原来已经做过的内容。在这个过程中大概率还要重新补一下前面的学习内容。&lt;/p&gt;&#xA;&lt;p&gt;本次作业主要目的是熟悉虚拟机的使用、使用C++与Eigen库编写简单的程序和用cmake进行编译,由于涉及虚拟机的安装，所以内容很长，可以参考实验的&lt;a style=&#34;color: #0000FF;&#34; href=&#34;pa0.pdf&#34; target=&#34;_blank&#34;&gt;Pdf文档&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业内容&#34;&gt;作业内容&lt;/h2&gt;&#xA;&lt;p&gt;给定一个点 P=(2,1), 将该点绕原点先逆时针旋转 45*◦*，再平移 (1,2), 计算出变换后点的坐标（要求用齐次坐标进行计算）。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;cmath&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;eigen3/Eigen/Core&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;eigen3/Eigen/Dense&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;iostream&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sin(&lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; M_PI &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;180.0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=-&lt;/span&gt;a;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Vector3f v(&lt;span style=&#34;color:#ae81ff&#34;&gt;2.0f&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0f&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0f&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Matrix3f i,j;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; a, b, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, a, a, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以在此基础上熟悉一下Eigen库的使用，为后续实验打下基础。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨03 Transformation</title>
      <link>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A803-transformation/</link>
      <pubDate>Fri, 10 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A803-transformation/</guid>
      <description>&lt;h3 id=&#34;scale缩放&#34;&gt;Scale（缩放）&lt;/h3&gt;&#xA;&lt;image src = &#34;scale.png&#34; alt = &#34;缩放变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;缩放可以对x和y采取相同的缩放比例，也可以不同。&lt;/p&gt;&#xA;&lt;h3 id=&#34;reflection对称&#34;&gt;Reflection（对称）&lt;/h3&gt;&#xA;&lt;image src = &#34;reflection.png&#34; alt = &#34;对称变换&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;shear剪切&#34;&gt;Shear（剪切）&lt;/h3&gt;&#xA;&lt;image src = &#34;shear.png&#34; alt = &#34;剪切变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里是水平方向上的切变。&lt;/p&gt;&#xA;&lt;h3 id=&#34;rotation旋转&#34;&gt;Rotation（旋转）&lt;/h3&gt;&#xA;&lt;image src = &#34;rotation.png&#34; alt = &#34;旋转变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里是二维的旋转，并且我们默认它是绕着原点旋转，逆时针方向旋转。θ也就是默认为逆时针旋转的方向。&lt;/p&gt;&#xA;&lt;p&gt;推导过程：&lt;/p&gt;&#xA;&lt;image src = &#34;tuidao.png&#34; alt = &#34;推导过程&#34; /&gt;&#xD;&#xA;&lt;p&gt;并以此类推，计算出所有的参数。&lt;/p&gt;&#xA;&lt;h2 id=&#34;linear-transformations线性变换&#34;&gt;Linear Transformations（线性变换）&lt;/h2&gt;&#xA;&lt;image src = &#34;linear.png&#34; alt = &#34;线性变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;如果一个变换可以写成一个矩阵去乘输入的坐标，得到变换后的坐标，这个变换就是线性变换。上述介绍的几种变换都是线性变换。&lt;/p&gt;&#xA;&lt;h2 id=&#34;homogeneous-coordinates齐次坐标&#34;&gt;Homogeneous coordinates（齐次坐标）&lt;/h2&gt;&#xA;&lt;p&gt;为什么要引入齐次坐标？有一种变换非常特殊：平移变换。&lt;/p&gt;&#xA;&lt;image src = &#34;translation.png&#34; alt = &#34;平移变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;我们会发现，它的变换非常简单，但是我们不可以像刚刚一样写成一个和矩阵相乘的形式了。我们只能写成：&lt;/p&gt;&#xA;&lt;image src = &#34;translation2.png&#34; alt = &#34;平移变换的计算写法&#34; /&gt;&#xD;&#xA;&lt;p&gt;所以，平移变换不是一个线性变换。但我们并不像为平移变换引入一种特殊的表示方式，我们希望的是将它们用同一种计算方法来表示。因此引入了齐次坐标的形式。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lua学习笔记丨04字符串</title>
      <link>https://nju-wrd.github.io/posts/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A804%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 07 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A804%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>&lt;p&gt;Lua语言中的字符串既可以表示单个字符，也可以表示一个字符串。&lt;/p&gt;&#xA;&lt;p&gt;Lua语言中，字符使用8个比特位来存储（与之对比的时7-bit ASCII）。Lua语言中的字符串可以存储包括空字符在内的所有数值代码，这意味着我们可以在字符串中存储任意的二进制数据。Lua的字符串标准库默认处理8个比特位（1Byte）的字符，此外，从Lua5.3开始还提供了一个帮助使用UTF-8编码的函数库。&lt;/p&gt;&#xA;&lt;p&gt;Lua语言中的字符串是不可变的，但是我们可以通过创建一个新字符串的方式来达到修改的目的。例如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;one string&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; string.gsub(a, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;one&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;another&amp;#34;&lt;/span&gt;)&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 改变字符串中的某些部分&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(a)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(b)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;像Lua语言中的其他对象（表、函数等）一样，Lua语言中的字符串也是自动内存管理的对象之一。这意味着开发人员无需关注字符串的分配和释放。&lt;/p&gt;&#xA;&lt;p&gt;可以使用长队操作符（#）获取字符串的长度：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;a)&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;--&amp;gt; 5&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;good bye&amp;#34;&lt;/span&gt;)&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;--&amp;gt; 8&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以使用连接操作符..（两个点）来进行字符串连接。如果操作数中存在数值，那么Lua语言会先把数值转换成字符串：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;#34;Hello &amp;#34; .. &amp;#34;World&amp;#34;&#x9;&#x9;--&amp;gt; Hello World&#xD;&#xA;&amp;#34;result is &amp;#34; .. 3&#x9;&#x9;--&amp;gt; result is 3&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在Lua语言中，字符串是不可变量。字符串连接总是创建一个新字符串，而不会改变原来作为操作数的字符串。&lt;/p&gt;&#xA;&lt;h2 id=&#34;41-字符串常量&#34;&gt;4.1 字符串常量&lt;/h2&gt;&#xA;&lt;p&gt;我们可以使用一对双引号或单引号来声明字符串常量：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a line&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;another line&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用双引号和单引号声明的字符是等价的。它们两者唯一的区别在于，使用双引号声明的字符串中出现单引号时，单引号可以不用转义；使用单引号，出现双引号，不用转义。&lt;/p&gt;&#xA;&lt;p&gt;比如，与由于XML文本中一般会有双引号，所以操作XML的库可能就会使用单引号来声明XML片段。&lt;/p&gt;&#xA;&lt;p&gt;Lua语言中的字符串支持下列C语言风格的转义字符：&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;colgroup&gt;&#xD;&#xA;    &lt;col style=&#34;width: 30%;&#34;&gt;&#xD;&#xA;    &lt;col style=&#34;width: 70%;&#34;&gt;&#xD;&#xA;  &lt;/colgroup&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;\a&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;响铃（bell）&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;\b&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;退格（back space）&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;\f&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;换页（form feed）&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;\n&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;换行（newline）&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;\r&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;回车（carriage return）&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;\t&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;水平制表符（horizontal tab）&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;\v&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;垂直制表符（vertical tab）&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;\\&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;反斜杠（backslash）&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;\&#34;&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;双引号（double quote）&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;\&#39;&#39;&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;单引号（single quote）&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;p&gt;在字符串中，还可以通过转义序列\ddd和\xhh来声明字符。其中，ddd是最多三个十进制数字组成的序列，hh是两个且必须两个十六进制数字组成的序列。在一个使用ASCII编码的系统中，&amp;ldquo;AL0\n123\&amp;ldquo;&amp;ldquo;和&amp;rsquo;\x41L0\10\04923&amp;rdquo;&amp;lsquo;实际上是一样的：0x41对应A，10对应换行符，49对应数字1，由于转义序列49后面紧邻数字，所以必须写成\049。&lt;/p&gt;</description>
    </item>
    <item>
      <title>UE5C&#43;&#43;开发学习笔记丨03</title>
      <link>https://nju-wrd.github.io/posts/ue5c&#43;&#43;%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A803/</link>
      <pubDate>Tue, 07 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/ue5c&#43;&#43;%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A803/</guid>
      <description>&lt;details&gt;&lt;summary&gt;&lt;font size = 5&gt;&lt;b&gt;目录 - Table of contents&lt;/b&gt;&lt;/font&gt;&lt;/summary&gt;&#x9;&lt;p&gt;&#xD;&#xA;&lt;ul&gt;&#xD;&#xA;&#x9;&lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#00&#34;&gt;UEC++的基础变量类型&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;&#x9;&lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#01&#34;&gt;FString、FName、FText的区别&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;&#x9;&lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#02&#34;&gt;UEC++的容器TArray&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;    &lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#03&#34;&gt;UEC++的容器TMap&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;    &lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#04&#34;&gt;UEC++的容器TSet&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;    &lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#05&#34;&gt;UEC++基础数据类型输出打印&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;&lt;/ul&gt;&#xD;&#xA;    &lt;/p&gt; &lt;/details&gt;&#xD;&#xA;&lt;p&gt;&lt;a id=&#34;00&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;uec的基础变量类型&#34;&gt;UEC++的基础变量类型&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 布尔类型变量声明&#xD;&#xA;bool varBool;&#xD;&#xA;// 整型32位的变量声明&#xD;&#xA;int32 varInt32;&#xD;&#xA;// 整型64位的变量声明&#xD;&#xA;int64 varInt64;&#xD;&#xA;// 字节类型的变量声明&#xD;&#xA;BYTE varByte;&#xD;&#xA;// String类型的变量声明字符串的类型&#xD;&#xA;FString varString;&#xD;&#xA;// Name名称类型的变量声明&#xD;&#xA;FName varName;&#xD;&#xA;// FText文本类型的变量声明&#xD;&#xA;FText varText;&#xD;&#xA;// FVector;向量类型的变量声明&#xD;&#xA;FVector varVector;// 这个就是x轴，Y轴，Z轴的坐标&#xD;&#xA;// FRotator旋转类型的变量声明&#xD;&#xA;FRotator varRotator;// 这个就是x轴的旋转Ro1L,Y轴的旋转Pitch,Z轴的旋转Yam&#xD;&#xA;// FTransform类型的变量声明&#xD;&#xA;FTransform varTransform;// 这个就是既有FVector也有FRotator,还有缩放Scale三者的集合类型(一个齐次矩阵)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a id=&#34;01&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;fstringfnameftext的区别&#34;&gt;FString、FName、FText的区别&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;FString&lt;/strong&gt;用于表示动态字符串。FString是一个标准的可变字符串类型，用于在运行时处理文本。它可以包含任意字符，并且可以修改和动态改变内容。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内存动态分配，适合在程序中频繁修改或拼接字符串。&lt;/li&gt;&#xA;&lt;li&gt;支持Unicode字符，可以包含所有字符集。&lt;/li&gt;&#xA;&lt;li&gt;适用于一般的文本处理，比如文件路径、用户输入等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;FName&lt;/strong&gt;用于表示轻量级、不可变的字符串，通常用于标识符（如资源名称、对象标签、蓝图类名等）。FName是一种轻量的、高效的字符串表示方式，用于需要进行频繁比较的场景。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨02 Review of Linear Algebra</title>
      <link>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A802-review-of-linear-algebra/</link>
      <pubDate>Mon, 06 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A802-review-of-linear-algebra/</guid>
      <description>&lt;h2 id=&#34;graphics-dependencies&#34;&gt;Graphics’ Dependencies&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Basic mathematics&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Linear algebra, calculus, statistics（线性代数、微积分、统计）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Basic physics&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Optics, Mechanics（光学、力学）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Misc&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Signal processing（信号处理）&lt;/li&gt;&#xA;&lt;li&gt;Numerical analysis（数值分析）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;And a bit of aesthetics（美学）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;vectors&#34;&gt;Vectors&lt;/h2&gt;&#xA;&lt;p&gt;一个向量通常写做一个字母加一个在其上方从左指向右的箭头，或者是用加粗的字母表示&lt;strong&gt;a&lt;/strong&gt;。也可以用起点和终点加上箭头来表示，AB = B - A，即从点A指向点B，用B点坐标减去A点坐标。向量是由长度和方向组成的，它没有一个绝对的开始位置，如果对向量进行平移实际上他仍然是相等的向量。&lt;/p&gt;&#xA;&lt;image src = &#34;vector.png&#34; alt = &#34;向量&#34; /&gt;&#xD;&#xA;&lt;p&gt;一个向量的长度用||&lt;strong&gt;a&lt;/strong&gt;||表示，利用向量的长度我们可以获得单位向量：&lt;strong&gt;u&lt;/strong&gt; = &lt;strong&gt;a&lt;/strong&gt; / ||&lt;strong&gt;a&lt;/strong&gt;||，我们可以用单位向量来表示方向，不关心它的长度。&lt;/p&gt;&#xA;&lt;h3 id=&#34;vector-addition向量加法&#34;&gt;Vector Addition（向量加法）&lt;/h3&gt;&#xA;&lt;p&gt;分为平行四边形法则和三角形法则，不过殊途同归，计算的结果是一样的。平行四边形法则，对于向量a和向量b我们都可以任意的移动，然后将&lt;strong&gt;a&lt;/strong&gt;和&lt;strong&gt;b&lt;/strong&gt;都进行一定的平移，使得他们围成一个平行四边形，红线就是计算的结果。三角形法则，我们要将向量相加，就将他们首尾相连拼接起来，最后形成的最开始和最后就是计算的结果，这个也同样适用于多个向量相加。&lt;/p&gt;&#xA;&lt;p&gt;以上是在几何上理解向量相加，在数学上向量相加，就是将他们的坐标给加起来。&lt;/p&gt;&#xA;&lt;image src = &#34;addition.png&#34; alt = &#34;向量的加法&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;cartesian-coordinates笛卡尔坐标&#34;&gt;cartesian coordinates（笛卡尔坐标）&lt;/h3&gt;&#xA;&lt;image src = &#34;cartesian coordinates.png&#34; alt = &#34;笛卡尔坐标系下的向量&#34; /&gt;&#xD;&#xA;&lt;p&gt;在坐标系下描述一个向量，我们永远认为这个向量从(0, 0)开始，&lt;strong&gt;X&lt;/strong&gt;是向右的单位向量，&lt;strong&gt;Y&lt;/strong&gt;是向上的单位向量，一个向量是多少，就由几个&lt;strong&gt;X&lt;/strong&gt;加上几个&lt;strong&gt;Y&lt;/strong&gt;来表示，通常它们是互相垂直的单位向量。如上图所示，这样的话，我们就可以直接用A&lt;sup&gt;⊤&lt;/sup&gt; = (4, 3)来表示这个向量。这里有一点，在图形学，默认向量是一个列向量。在此基础上，计算向量的长度也会很简单，公式如图右下角所示。&lt;/p&gt;&#xA;&lt;h3 id=&#34;dotscalar-product点积&#34;&gt;Dot（scalar） Product（点积）&lt;/h3&gt;&#xA;&lt;image src = &#34;dot.png&#34; alt = &#34;点乘&#34; /&gt;&#xD;&#xA;&lt;p&gt;点乘的计算如图所示，这里的θ是两个向量之间的夹角。两个向量点乘的结果是一个数字（标量），其实向量的点乘可以方便计算这个θ角。&lt;/p&gt;</description>
    </item>
    <item>
      <title>UE5C&#43;&#43;开发学习笔记丨02</title>
      <link>https://nju-wrd.github.io/posts/ue5c&#43;&#43;%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A802/</link>
      <pubDate>Sat, 04 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/ue5c&#43;&#43;%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A802/</guid>
      <description>&lt;details&gt;&lt;summary&gt;&lt;font size = 5&gt;&lt;b&gt;目录 - Table of contents&lt;/b&gt;&lt;/font&gt;&lt;/summary&gt;&#x9;&lt;p&gt;&#xD;&#xA;&lt;ul&gt;&#xD;&#xA;&#x9;&lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#00&#34;&gt;UEC++游戏架构&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;&#x9;&lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#01&#34;&gt;创建C++类&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;&#x9;&lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#02&#34;&gt;重写BeginPlay、Tick、EndPlay函数&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;    &lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#03&#34;&gt;UE_LOG和AddOnScreenDebugMessage&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;&lt;/ul&gt;&#xD;&#xA;    &lt;/p&gt; &lt;/details&gt;&#xD;&#xA;&lt;p&gt;&lt;a id=&#34;00&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;uec游戏架构&#34;&gt;UEC++游戏架构&lt;/h2&gt;&#xA;&lt;image src = &#34;construct.png&#34; alt = &#34;UE内游戏结构&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;游戏模式gamemode&#34;&gt;游戏模式（GameMode）&lt;/h3&gt;&#xA;&lt;p&gt;游戏模式也就是游戏的基础规则，负责管理游戏规则和流程的核心类。它定义了玩家的行为、游戏的胜利或失败条件、关卡规则以及默认的玩家控制器、HUD 等关键组件。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;默认pawn类（Default Pawn Class）&lt;/strong&gt;，可以是有运动属性的character，也可以是不带有运动属性的pawn。这个可以理解成人体的躯干，它可以被controller控制，而controller可以是玩家，也可以是我们的AI controller。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;HUD类（用户界面类）&lt;/strong&gt;，绘制到屏幕上的UI，用来进行一些交互界面的展示。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;玩家控制器类（Player Controller Class）&lt;/strong&gt;，控制器是一个非物理的Actor，可以是一个pawn或者是一个pawn的派生类，可以控制角色的移动。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;游戏状态类（Game State Class）&lt;/strong&gt;，主要是追踪记录游戏层面的属性，比如说已经连接玩家的列表，团队的一些得分，开放世界中完成的任务等等。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;玩家状态类（Player State Class）&lt;/strong&gt;，追踪玩家的状态属性，比如当前玩家的姓名，得分，在线状态等等。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;旁观者类（Spectator Class）&lt;/strong&gt;，描述第三方的视角。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a id=&#34;01&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;创建c类&#34;&gt;创建C++类&lt;/h2&gt;&#xA;&lt;p&gt;这里用一个和之前创建C++类略有不同的方法，但殊途同归。&lt;/p&gt;&#xA;&lt;p&gt;首先使用ctrl + 空格召唤出内容菜单，在C++类文件夹中右击可以选择新建C++类，这里展示一个示例。&lt;/p&gt;&#xA;&lt;image src = &#34;menu.png&#34; alt = &#34;创建C++类&#34; /&gt;&#xD;&#xA;&lt;image src = &#34;choose.png&#34; alt = &#34;选择要创建的C++类&#34; /&gt;&#xD;&#xA;&lt;image src = &#34;generate.png&#34; alt = &#34;创建C++类&#34; /&gt;&#xD;&#xA;&lt;p&gt;创建成功会在living coding界面显示&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lua学习笔记丨03数值</title>
      <link>https://nju-wrd.github.io/posts/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A803%E6%95%B0%E5%80%BC/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A803%E6%95%B0%E5%80%BC/</guid>
      <description>&lt;h2 id=&#34;31-数值常量&#34;&gt;3.1 数值常量&lt;/h2&gt;&#xA;&lt;p&gt;我们可以使用科学技术法（一个可选的十进制部分外加一个可选的十进制指数部分）书写数值常量，例如：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;4.77e-3&#x9;&#x9;--&amp;gt; 0.00477&#xD;&#xA;0.3e12&#x9;&#x9;--&amp;gt; 300000000000.0&#xD;&#xA;4e+3&#x9;&#x9;--&amp;gt; 4000.0&#xD;&#xA;5E+20&#x9;&#x9;--&amp;gt; 5e+020&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具有十进制小数或者指数的数值会被当做浮点类型值，否则会被当作整型值。&lt;/p&gt;&#xA;&lt;p&gt;由于整型值和浮点型值的类型都是&amp;quot;number&amp;quot;，所以它们是可以相互转化的。同时，具有相同算术值的整型值和浮点类型值在Lua语言中是相等的：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1 == 1.0&#x9;&#x9;--&amp;gt; true&#xD;&#xA;-3 == -3.0&#x9;&#x9;--&amp;gt; true&#xD;&#xA;0.2e3 == 200&#x9;&#x9;--&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在少数情况下，需要区分整型值和浮点型值时，可以使用math.type：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;math.type(3)&#x9;&#x9;--&amp;gt; integer&#xD;&#xA;math.type(3.0)&#x9;&#x9;--&amp;gt; float&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Lua语言也支持以0x开头的十六进制常量。与其它语言不同的是，Lua还支持十六进制的浮点数，这种十六进制浮点数以p或P开头的指数部分组成。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;0xff&#x9;&#x9;--&amp;gt; 255&#xD;&#xA;0x1A3&#x9;&#x9;--&amp;gt; 419&#xD;&#xA;0x0.2&#x9;&#x9;--&amp;gt; 0.125&#xD;&#xA;0x1p-1&#x9;&#x9;--&amp;gt; 0.5(p后面的数字表示2的幂次)&#xD;&#xA;0xa.bp2&#x9;&#x9;--&amp;gt; 42.75&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以使用%a参数，通过函数string.format最这种格式进行格式化输出：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;string.format(&amp;#34;%a&amp;#34;,419)&#x9;&#x9;--&amp;gt; 0x1.a3p+8&#xD;&#xA;string.format(&amp;#34;%a&amp;#34;,0.1)&#x9;&#x9;--&amp;gt; 0x1.999999999999ap-4&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然难以阅读，但是可以保留所有浮点数的精度，并且比十进制的转换速度更快。&lt;/p&gt;&#xA;&lt;h2 id=&#34;32-算术运算&#34;&gt;3.2 算术运算&lt;/h2&gt;&#xA;&lt;p&gt;除了加、减、乘、除、取负数（单目减法）等，还支持取整除法（floor除法），取模和指数运算。&lt;/p&gt;&#xA;&lt;p&gt;当操作数一个是整型值一个是浮点型值时，Lua语言会在进行算术运算前先将整型值转换为浮点型值：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;13.0 + 25&#x9;&#x9;--&amp;gt; 38.0&#xD;&#xA;-(3 * 6.0)&#x9;&#x9;--&amp;gt; -18.0&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于两个整数相除的结果不一定时整除，因此触发不遵循整型值和整型值进行算术运算的结果依然是整型值，为了避免两个整型值相除和两个浮点型值相除导致不一样的结果，除法运算操作的永远是浮点数且产生浮点型值的结果：&lt;/p&gt;</description>
    </item>
    <item>
      <title>UE5C&#43;&#43;开发学习笔记丨01</title>
      <link>https://nju-wrd.github.io/posts/ue5c&#43;&#43;%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A801/</link>
      <pubDate>Thu, 02 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/ue5c&#43;&#43;%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A801/</guid>
      <description>&lt;details&gt;&lt;summary&gt;&lt;font size = 5&gt;&lt;b&gt;目录 - Table of contents&lt;/b&gt;&lt;/font&gt;&lt;/summary&gt;&#x9;&lt;p&gt;&#xD;&#xA;&lt;ul&gt;&#xD;&#xA;&#x9;&lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#00&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;&#x9;&lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#01&#34;&gt;创建项目&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;&#x9;&lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#02&#34;&gt;头文件的含义&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;    &lt;li&gt;&lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#03&#34;&gt;UEC++各个宏的作用&lt;/a&gt;&lt;/li&gt;&#xD;&#xA;&lt;/ul&gt;&#xD;&#xA;    &lt;/p&gt; &lt;/details&gt;&#xD;&#xA;&lt;p&gt;&lt;a id=&#34;00&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;由于腾讯客户端公开课的课程内容没有录播，并且内容量非常大，另外由于前段时间碰上期末周，所以一直没法快速跟上作业内容。于是我决定先从UE5的C++开发的基础学起，再去完成搁置的作业内容。&lt;/p&gt;&#xA;&lt;p&gt;学习内容来自于：&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://www.bilibili.com/video/BV1Dc411f7nx?spm_id_from=333.788.videopod.episodes&amp;vd_source=1837baf7c46a027b7e27b4ab7174fb85&#34; target=&#34;_blank&#34;&gt;【虚幻5】UE5C++零基础全网全流程开发从入门到进阶教程合集&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;开发工具:VS2022&lt;/p&gt;&#xA;&lt;p&gt;另外在开始学习之前，在评论区看到有推荐一个插件，设置教程链接如下：&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://dev.epicgames.com/documentation/en-us/unreal-engine/using-the-unrealvs-extension-for-unreal-engine-cplusplus-projects?application_version=5.4&#34; target=&#34;_blank&#34;&gt;将 UnrealVS 扩展用于 Unreal Engine C++ 项目&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a id=&#34;01&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;创建项目&#34;&gt;创建项目&lt;/h2&gt;&#xA;&lt;p&gt;下图会展示如何创建一个UE5游戏开发的C++项目&lt;/p&gt;&#xA;&lt;img src = &#34;generate.png&#34; alt = &#34;创建项目&#34; /&gt;&#xD;&#xA;&lt;p&gt;创建完成后会自动打开Visual Studio，按下图所示点击生成可以编译代码,若无问题可以生成成功。&lt;/p&gt;&#xA;&lt;img src = &#34;build.png&#34; alt = &#34;生成&#34; /&gt;&#xD;&#xA;&lt;img src = &#34;success.png&#34; alt = &#34;生成成功&#34; /&gt;&#xD;&#xA;&lt;p&gt;然后看一下侧边的解决方案，其中Engine/UE5是引擎自身的相关文件，Games/Project4Learning就是刚刚创建的项目的一些文件信息。Config是一些配置文件，Source是项目的一些源文件，现在能看到的文件是创建项目时会默认生成的。&lt;/p&gt;&#xA;&lt;img src = &#34;information.png&#34; alt = &#34;信息介绍&#34; /&gt;&#xD;&#xA;&lt;p&gt;其中Build.cs文件很重要，它是描述的每个模块的环境依赖信息，表示我这个项目用到了哪些模块，比如这里引擎默认带有的模块&amp;quot;Core&amp;quot;, &amp;ldquo;CoreUObject&amp;rdquo;, &amp;ldquo;Engine&amp;rdquo;, &amp;ldquo;InputCore&amp;rdquo;, &amp;ldquo;EnhancedInput&amp;rdquo;。第3行的using UnrealBuildTool；用到的UBT，会编译每一个模块并处理相关依赖信息。UHT（Unreal Header Tool）会收集我们虚幻的一些头文件，编译生成反射数据，这些反射数据会生成一个generator.h或.cpp当中。我们的头文件发生变化时，虚幻引擎底层也会调用并产生新的反射数据&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨07 Shading 1(illumination, Shading)</title>
      <link>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A807-shading-1illumination-shading/</link>
      <pubDate>Thu, 02 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A807-shading-1illumination-shading/</guid>
      <description>&lt;h2 id=&#34;painters-algorithm画家算法&#34;&gt;Painter&amp;rsquo;s Algorithm（画家算法）&lt;/h2&gt;&#xA;&lt;p&gt;上节课我们学习了如何光栅化一个三角形，但是当画面中有多个三角形的时候，该如何去光栅化所有的图像？一个办法就是像油画家一样，先画远处的内容，再画稍近一点的内容，也就是按照图像本身在画面中的深度由远及近的进行光栅化。&lt;/p&gt;&#xA;&lt;p&gt;很直观的方式就是可以对所有的物体进行深度的排序（O（nlogn）），但是这样存在不可解决的排序顺序，如下图所示：&lt;/p&gt;&#xA;&lt;img src = &#34;unresolvable.png&#34; alt = &#34;不可解决的顺序&#34; /&gt;&#xD;&#xA;&lt;p&gt;他们在深度上存在一个互相遮挡的关系，就无法对他们进行深度的排序，画家算法在这里也就失效了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;z-buffer深度缓存depth-buffer&#34;&gt;Z-Buffer（深度缓存depth buffer）&lt;/h2&gt;&#xA;&lt;p&gt;图形学实际上采用的是Z-Buffer的方法，也就是对于每一个像素去存储离我们最近的深度也就是最浅的深度z-value的信息。&lt;/p&gt;&#xA;&lt;p&gt;对于实际完成，会渲染最终的成品，也就是预期的效果；在生成这个结果的同时，也会生成另外一个图像，这个图像只存看到的几何物体最浅的深度的信息，这个图就叫做depth buffer（z-buffer）。存储最终结果的叫做frame buffer，利用深度缓存的想法来维护遮挡信息。&lt;/p&gt;&#xA;&lt;p&gt;这里重要的一点是，现在我们用z来表示一点到摄像机的距离，且这个z永远是正的，也就是说z的数值越大离我们越远，数值越小离我们越近。这里和前面学习的变换当中的概念不同（变换当中，摄像机在原点朝着-z方向，因此距离越近，数字越大，且z为负的）。&lt;/p&gt;&#xA;&lt;img src = &#34;buffer.png&#34; alt = &#34;生成的渲染图和深度信息图&#34; /&gt;&#xD;&#xA;&lt;p&gt;左侧是渲染的结果，右侧是维护遮挡信息的深度图。可以看到，离我们越远，颜色也就越浅，离我们越近，颜色也就越深。&lt;/p&gt;&#xA;&lt;img src = &#34;algorithm.png&#34; alt = &#34;算法伪代码&#34; /&gt;&#xD;&#xA;&lt;p&gt;上图就是要实现的算法了，首先将深度缓存的所有像素一开始记录的深度初始化为无限大，即表示无限远。然后在每一个三角形进行光栅化的过程中，对于任意一个三角形的任意一个像素，如果现在要画的深度小于深度缓存记录好的深度，就更新深度缓存的值为更小的，并且把这个结果存到要渲染的frame-buffer里面去，否则什么都不做。&lt;/p&gt;&#xA;&lt;p&gt;时间复杂度为O（n），并且不会因为画三角形的顺序不同而产生不同结果（假设在同一像素上不同三角形不会有相同深度的值，因为用浮点型记录深度很难有相同值的存在）。&lt;/p&gt;&#xA;&lt;p&gt;在之前提到的反走样技术MSAA中，考虑到会在一个像素内设置多个采样点，因此在结合这样的技术的时候，对于不同的采样点，也要做相应的深度缓存。&lt;/p&gt;&#xA;&lt;h2 id=&#34;shading着色&#34;&gt;Shading（着色）&lt;/h2&gt;&#xA;&lt;p&gt;对不同物体应用不同的材质。&lt;/p&gt;&#xA;&lt;h3 id=&#34;a-simple-shading-modelblinn-phong-reflectance-model&#34;&gt;A Simple Shading Model（Blinn-Phong Reflectance Model）&lt;/h3&gt;&#xA;&lt;p&gt;在了解这个模型之前，我们可以先了解一下着色要考虑到的三个内容：高光、漫反射和环境光。高光指的是光源照射到一个相对来说较为光滑的平面，光线被反射到镜面反射附近位置产生的高亮，漫反射是指光线找到类似于墙壁这种比较粗糙的面上产生的各个方向的反射；而环境光是指由于各个面上都会发生反射，最终使得即使在光源无法照到的位置也能被看到，此处就是环境光。&lt;/p&gt;&#xA;&lt;p&gt;接下来看一些定义：&lt;/p&gt;&#xA;&lt;img src = &#34;definition.png&#34; alt = &#34;光的反射的数值定义&#34; /&gt;&#xD;&#xA;&lt;p&gt;我们考虑光照首先是在任何一个点上去考虑，也就是在一个shading point上去考虑它的着色结果是什么。那么对于这个point所属的一个物体表面上，我们认为在一个局部的一个非常小的范围内，这个表面永远是一个平面。那么在这个平面上，我们可以定义平面的法线向量n，观测方向为shading point 到观测点的方向，也就是向量v，从point看向光源的方向叫做光源方向，记作向量l。且这三个向量都被记为单位向量，长度为1。其次，对于shading point本身的一些属性，要定义一下和物体表面相关的信息。例如它是什么颜色，它有多么亮等等（color，shininess&amp;hellip;）。&lt;/p&gt;&#xA;&lt;p&gt;补充一点是，我们考虑的shading point是在局部的，也就是不考虑是否在阴影内等和其他物体产生联系的情况。&lt;/p&gt;&#xA;&lt;h4 id=&#34;diffusion&#34;&gt;diffusion&lt;/h4&gt;&#xA;&lt;p&gt;首先考虑漫反射的情况，当光照到物体表面的某一个点时，会被均匀的反射到各个不同的方向上去。&lt;/p&gt;&#xA;&lt;img src = &#34;diffusion.png&#34; alt = &#34;漫反射&#34; /&gt;&#xD;&#xA;&lt;p&gt;并且对于光线的不同入射角度，光的强度也会发生变化。总的来说，一个漫反射的部分单位面积会接收到多少光和光照方向与法线方向形成夹角的余弦值成正比。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lua学习笔记丨02小插曲：八皇后问题</title>
      <link>https://nju-wrd.github.io/posts/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A802%E5%B0%8F%E6%8F%92%E6%9B%B2%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A802%E5%B0%8F%E6%8F%92%E6%9B%B2%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;本章作为小插曲讲解如何用Lua语言编写的简单但完整的程序来解决八皇后问题（eight-quene puzzle，其目标是把8个皇后合理地摆放在棋盘上，让每个皇后之间都不能相互攻击）。&lt;/p&gt;&#xA;&lt;p&gt;可以用一个8个数字组成的简单数组来表示可能的解决方案。例如{3, 7, 2, 1, 8, 6, 5, 4}中3即(1, 3)表示其位置，7即(2, 7)，换言之，数字在数组中的位置同样表示其部分位置信息。&lt;/p&gt;&#xA;&lt;p&gt;示例：求解八皇后问题的程序&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 棋盘大小&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 检查(n, c)是否不会被攻击&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isplaceok&lt;/span&gt;(a, n, c)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 对于每一个已经被放置的皇后&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(a[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; c) &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 同一列？&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            (a[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; n) &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 同一对角线？&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            (a[i] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; n) &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 同一对角线？&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 位置会被攻击&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 不会被攻击；位置有效&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--  打印棋盘&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;printsolution&lt;/span&gt; (a)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, N &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 对于每一行&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, N &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 和每一列&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           &#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 输出&amp;#34;X&amp;#34;或&amp;#34;-&amp;#34;，外加一个空格&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#x9;io.write(a[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;X&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        io.write(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    io.write(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 把从&amp;#39;n&amp;#39;到&amp;#39;N&amp;#39;的所有皇后放在棋盘&amp;#39;a&amp;#39;上&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addqueen&lt;/span&gt;(a, n)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; N &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 是否所有的皇后都被放置好了？&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printsolution(a)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 尝试放置第n个皇后&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, N &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; isplaceok(a, n, c) &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                a[n] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;-- 把第n个皇后放在列&amp;#39;c&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                addqueen(a, n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 运行程序&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;addqueen({}, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Lua学习笔记丨01Lua语言入门</title>
      <link>https://nju-wrd.github.io/posts/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A801lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</link>
      <pubDate>Tue, 31 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A801lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;开发环境： &lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://sourceforge.net/projects/luabinaries/files/5.4.2/Tools Executables/lua-5.4.2_Win64_bin.zip/download&#34; target=&#34;_blank&#34;&gt;Lua 5.4.2&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;IDE 选择：&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://www.sublimetext.com/3&#34; target=&#34;_blank&#34;&gt;Sublime Text 3&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;为了在游戏开发的路上走得更远，开始学习Lua，据我了解Lua主要便于游戏热更，并且非常简单轻便。学习过程基于《Lua程序设计》第4版由梅隆魁译，出版于电子工业出版社。旨在记录一些和我所熟悉的内容的不同之处，可能并没有特别详细。在上述环境中完成书上的小练习。&lt;/p&gt;&#xA;&lt;h2 id=&#34;11-程序段&#34;&gt;1.1 程序段&lt;/h2&gt;&#xA;&lt;p&gt;Lua语言执行的每一段代码（一个文件或交互模式下的一行）称为一个&lt;em&gt;程序段&lt;/em&gt;（Chunk），即一组命令或表达式组成的序列。&lt;/p&gt;&#xA;&lt;p&gt;程序段既可以只有一句表达式构成，也可以由多句表达式和函数定义（实际是赋值表达式）组成。&lt;/p&gt;&#xA;&lt;p&gt;当不带参数地调用lua时，输入的每一条指令都会在按下回车键后立即执行，在Windows下可以用ctrl-C或调用exit函数退出交互模式。&lt;/p&gt;&#xA;&lt;p&gt;从Lua5.3版本开始，可以直接在交互模式下输入表达式，Lua语言会输出表达式的值，在5.3之前的老版本中，实现相同的效果需要在表达式之前加入一个等号。如果不想输出结果，可以在行末加入一个分号;。为了向下兼容，5.3也支持这种语法。要以代码段的方式运行代码（不在交互模式下），必须把表达式包含在函数print的调用中。&lt;/p&gt;&#xA;&lt;p&gt;在交互模式下，Lua语言解释器会把我们输入的每一行当作完整的程序块或表达式来解释执行。但是，如果遇到不完整的一行，会等待直到输入完整后再解释执行。&lt;/p&gt;&#xA;&lt;p&gt;我们可以使用-i参数让Lua语言解释器在执行完指定的程序段后进入交互模式：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;% lua -i prog&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中prog为文件名，这对于调试和手工测试很有用。&lt;/p&gt;&#xA;&lt;p&gt;另一种运行程序段的方式是调用函数dofile，该函数会立即执行一个文件。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;% dofile(&amp;#34;test.lua&amp;#34;)        --加载文件&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;12-一些词法规范&#34;&gt;1.2 一些词法规范&lt;/h2&gt;&#xA;&lt;p&gt;Lua语言中的标识符（名称）是由任意字母（A-Z和a-z）、数字和下划线组成的字符串，且不能以数字开头。&lt;/p&gt;&#xA;&lt;p&gt;“下划线 + 大写字母”（例如_VERSION）组成的标识符通常被Lua语言用作特殊用途，应避免将其用作其他用途。通常会将“下划线 + 小写字母”用作哑变量（Dummy variable）。&lt;/p&gt;&#xA;&lt;p&gt;以下是Lua语言的保留字（reserve word），不能被用作标识符。&lt;/p&gt;&#xA;&lt;p&gt;and       break      do      else      elseif      end      false&lt;/p&gt;&#xA;&lt;p&gt;goto      for      function      if      in      local      nil      not&lt;/p&gt;&#xA;&lt;p&gt;or      repeat      return      then      true      until      while&lt;/p&gt;&#xA;&lt;p&gt;Lua语言是对大小写敏感的，因此虽然and是保留字，但是AND和And就是两个不同的标识符。&lt;/p&gt;&#xA;&lt;p&gt;Lua语言中使用两个连续的连字符（&amp;ndash;）表示单行注释的开始（从&amp;ndash;之后直到此行结束都是注释），使用两个连续的连字符加两对连续的左方括号表示长注释或多行注释的开始（直到两个连续的右括号为止，中间都是注释。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--[[多行&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;    长注释&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;]]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在注视一段代码的时候，一个常见的技巧是将这些代码放在&amp;ndash;[[和&amp;ndash;]]之间，当我们需要重新启用这段代码的时候，只需要在第一行行首添加一个连字符即可：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;---[[&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)         &lt;span style=&#34;color:#75715e&#34;&gt;--&amp;gt;10&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--]]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因此最后一行实际上也是一条独立的单行注释。&lt;/p&gt;</description>
    </item>
    <item>
      <title>网易雷火凉经&#43;反思</title>
      <link>https://nju-wrd.github.io/posts/%E7%BD%91%E6%98%93%E9%9B%B7%E7%81%AB%E5%87%89%E7%BB%8F&#43;%E5%8F%8D%E6%80%9D/</link>
      <pubDate>Tue, 31 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E7%BD%91%E6%98%93%E9%9B%B7%E7%81%AB%E5%87%89%E7%BB%8F&#43;%E5%8F%8D%E6%80%9D/</guid>
      <description>&lt;h2 id=&#34;止步一面&#34;&gt;止步一面&lt;/h2&gt;&#xA;&lt;p&gt;12.25 16:30 一面&lt;/p&gt;&#xA;&lt;p&gt;12.31 通知流程结束（感觉是在我的询问之下才会通知&lt;/p&gt;&#xA;&lt;p&gt;一开始本来提前准备好了进面试房间，开始了才发现最后一次进来没有开摄像头，开始前调了两分钟设备。其实一开始有发现这一遍进来没显示摄像头拍摄的画面的窗口，但是侥幸心理想着应该没事，只是有bug，还是应该处理一下重新进的。&lt;/p&gt;&#xA;&lt;p&gt;开始之后问了一些 C++ 的基础问题，然后在简历基础上问了一些问题。&lt;/p&gt;&#xA;&lt;p&gt;还是准备的不够充分，虽然面试官问到有关引擎包括物理系统或者问到 Lua 相关的问题，没答上来是可以接受的，毕竟在这条路上还没开始多久，准备的还不够充分，但是在 C++ 的基础上其实可以准备的更充分一点。&lt;/p&gt;&#xA;&lt;p&gt;反思了一下反问的流程，应该多问一些岗位相关的问题，不能过于随意。&lt;/p&gt;&#xA;&lt;p&gt;从昨天考完到今天已经针对目标岗位制定了学习的计划，期待下次再相遇能走得更远些。&lt;/p&gt;</description>
    </item>
    <item>
      <title>网络安全与检测技术复习要点（详细）</title>
      <link>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E8%AF%A6%E7%BB%86/</link>
      <pubDate>Fri, 20 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E8%AF%A6%E7%BB%86/</guid>
      <description>&lt;h2 id=&#34;复习知识要点&#34;&gt;复习知识要点&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1-概论&#34;&gt;1. 概论&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本安全属性的理解&#34;&gt;基本安全属性的理解&lt;/h3&gt;&#xA;&lt;h4 id=&#34;confidentiality保密性&#34;&gt;Confidentiality（保密性）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Confidentiality 是信息的隐瞒&lt;/li&gt;&#xA;&lt;li&gt;Data Confidentiality：确保私人或机密信息不会提供给或披露给未经授权的个人&lt;/li&gt;&#xA;&lt;li&gt;&lt;font color=gray&gt;Privacy：确保个人控制或影响哪些和他们有关的信息被收集，以及这些信息会被谁以及向谁披露&lt;/font&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;integrity完整性&#34;&gt;Integrity（完整性）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Integrity 是防止未经授权的更改&lt;/li&gt;&#xA;&lt;li&gt;Data Integrity：确保数据和信息仅以指定和授权的方式进行更改&lt;/li&gt;&#xA;&lt;li&gt;System Integrity：确保系统以不受损害的方式执行预期功能，不受故意或无意的未经授权的操作对系统执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;availability可用性&#34;&gt;Availability（可用性）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Availability 是使用信息或资源的能力&lt;/li&gt;&#xA;&lt;li&gt;确保系统迅速工作，并且不会拒绝向授权用户提供服务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;threats-and-attacks能够初步完成威胁模型threat-model的分析&#34;&gt;Threats and Attacks：能够初步完成威胁模型（Threat model）的分析&lt;/h3&gt;&#xA;&lt;p&gt;Assets：我们要保护什么？这个资产有多少价值？&lt;/p&gt;&#xA;&lt;p&gt;Adversaries：(对手)谁可能会尝试攻击，为什么？&lt;/p&gt;&#xA;&lt;p&gt;Vulnerabilities：系统可能多么薄弱？&lt;/p&gt;&#xA;&lt;p&gt;Threats：攻击者可能会采取哪些措施来利用漏洞&lt;/p&gt;&#xA;&lt;p&gt;Risk：资产有多重要？漏洞利用的可能性有多大？&lt;/p&gt;&#xA;&lt;p&gt;Possible Defenses：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不是“传统的”威胁建模，但很重要（无论是整个过程，还是为了在帮助威胁建模之前更好的了解系统）&lt;/li&gt;&#xA;&lt;li&gt;好处：系统可能会使谁受益，以及如何受益&lt;/li&gt;&#xA;&lt;li&gt;危害：系统可能会伤害谁，如何伤害&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;没有完美的安全，但是攻击者的资源有限。**让他们付出不可接受的代价/承担不可接受的风险来取得成功！**根据上下文来定义安全。&lt;/p&gt;&#xA;&lt;h3 id=&#34;security-principles安全原则&#34;&gt;Security Principles安全原则&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;h3 id=&#34;能够理解各安全原则的基本含义识别出遵从违背安全原则的设计&#34;&gt;能够理解各安全原则的基本含义，识别出遵从/违背安全原则的设计&lt;/h3&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;details&gt;&lt;summary&gt;&lt;font size = 4&gt;&lt;b&gt;安全原则&lt;/b&gt;&lt;/font&gt;&lt;/summary&gt;&#x9;&lt;p&gt;&#xD;&#xA;    &lt;a style=&#34;color: #1e90ff;&#34; href=&#34;#00&#34;&gt;Know Your Threat Model&lt;/a&gt;&lt;br&gt;&#xD;&#xA;    &lt;a style=&#34;color: #1e90ff;&#34;href=&#34;#01&#34;&gt;Security is Economics&lt;/a&gt;&lt;br&gt;&#xD;&#xA;    &lt;a style=&#34;color: #1e90ff;&#34;href=&#34;#02&#34;&gt;Secure the Weakest&lt;/a&gt;&lt;br&gt;&#xD;&#xA;    &lt;a style=&#34;color: #1e90ff;&#34;href=&#34;#03&#34;&gt;Defense in Depth&lt;/a&gt;&lt;br&gt;&#xD;&#xA;    &lt;a style=&#34;color: #1e90ff;&#34;href=&#34;#04&#34;&gt;Use Fail-Secure Defaults&lt;/a&gt;&lt;br&gt;&#xD;&#xA;    &lt;a style=&#34;color: #1e90ff;&#34;href=&#34;#05&#34;&gt;Least Privilege&lt;/a&gt;&lt;br&gt;&#xD;&#xA;    &lt;a style=&#34;color: #1e90ff;&#34;href=&#34;#06&#34;&gt;Compartmentalization&lt;/a&gt;&lt;br&gt;&#xD;&#xA;    &lt;a style=&#34;color: #1e90ff;&#34;href=&#34;#07&#34;&gt;Hard to Hide Secrets&lt;/a&gt;&lt;br&gt;&#xD;&#xA;    &lt;a style=&#34;color: #1e90ff;&#34;href=&#34;#08&#34;&gt;Separation of Responsibility&lt;/a&gt;&lt;br&gt;&#xD;&#xA;    &lt;a style=&#34;color: #1e90ff;&#34;href=&#34;#09&#34;&gt;Minimize Attack Surface&lt;/a&gt;&lt;br&gt;&#xD;&#xA;    &lt;a style=&#34;color: #1e90ff;&#34;href=&#34;#10&#34;&gt;Have Good Usability&lt;/a&gt;&lt;br&gt;&#xD;&#xA;    &lt;a style=&#34;color: #1e90ff;&#34;href=&#34;#11&#34;&gt;Detect if You Can’t Prevent&lt;/a&gt;&lt;br&gt;&#xD;&#xA;    &lt;a style=&#34;color: #1e90ff;&#34;href=&#34;#12&#34;&gt;Design in Security from the Start&lt;/a&gt;&lt;br&gt;&#xD;&#xA;    &lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A8</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a8/</link>
      <pubDate>Fri, 20 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a8/</guid>
      <description>&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa8.html&#34; target=&#34;_blank&#34;&gt;作业 8：污点分析&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业目标&#34;&gt;作业目标&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为 Java 实现污点分析。&lt;/li&gt;&#xA;&lt;li&gt;最后一次作业！ヾ(≧▽≦*)o&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在这次作业中，我们需要基于第 6 次作业实现的上下文敏感的指针分析来为 Java 实现污点分析（taint analysis）。为了让此次的污点分析不仅仅是个玩具，我们会在这次作业中学习一个叫做&lt;strong&gt;污点传播&lt;/strong&gt;（taint transfer）的技术，这样实现的污点分析就能够应用到生产实践中检测安全漏洞了。此外，taie 也提供了可配置的污点分析框架，帮助方便地设置污点分析中所需要的诸如 sources、sinks 等数据。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实现污点分析&#34;&gt;实现污点分析&lt;/h2&gt;&#xA;&lt;h3 id=&#34;分析范围&#34;&gt;分析范围&lt;/h3&gt;&#xA;&lt;p&gt;在这一小节中，我们来定义一下在这次作业中所需要实现的污点分析。和第 13 讲介绍的污点分析一样，我们会把一些特定的方法（通常是产生数据的 API）视作 taint sources，调用这些方法的语句会返回污点数据；为了和指针分析中的对象对应，这些污点数据也被叫做&lt;strong&gt;污点对象&lt;/strong&gt;（taint objects）。我们也把一些特定方法的某些参数视作 taint sinks。此外，为了达到更高的精度，需要实现一个&lt;strong&gt;上下文敏感的&lt;/strong&gt;污点分析。作为参考，已经写好了处理 sources 和 sinks 的规则：&lt;/p&gt;&#xA;&lt;image src = &#34;rule.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里，Sources 是二元组 ⟨m,u⟩ 的集合，其中 m 表示一个被视作 source 的方法的签名，而 u 是该方法返回的污点对象的类型。我们用 t&lt;sub&gt;l&lt;/sub&gt;&lt;sup&gt;u&lt;/sup&gt; 来表示一个污点对象，其中 u 是这个对象的类型，l 表示创建这个对象的调用点（call site）。简单起见，只需要使用&lt;strong&gt;空上下文&lt;/strong&gt;作为污点对象的堆上下文（heap context）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;污点传播&lt;/strong&gt;&lt;/em&gt;. 污点分析和指针分析看起来很相似，因为他们本质上都在跟踪程序中数据的流动——指针分析跟踪的是抽象的对象，污点分析跟踪的是污点对象。但是他们又有些微妙的不同：污点分析中的污点是一个更加抽象的概念——它与数据的&lt;strong&gt;内容&lt;/strong&gt;相关联，因此它可以在不同的对象之间&lt;strong&gt;传播&lt;/strong&gt;。我们把这样的现象叫做污点传播（taint transfer）。下面我们通过一个例子来学习这个概念：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;style=&#34;position:relative;&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34; id = &#34;code1&#34;&gt;String taint = getSecret(); // source&#xD;&#xA;StringBuilder sb = new StringBuilder();&#xD;&#xA;sb.append(&#34;abc&#34;);&#xD;&#xA;sb.append(taint); // taint is transferred to sb&#xD;&#xA;sb.append(&#34;xyz&#34;);&#xD;&#xA;String s = sb.toString(); // taint is transferred to s&#xD;&#xA;leak(s); // sink&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;  &lt;button class=&#34;copy-button&#34; data-clipboard-target=&#34;#code1&#34;&gt;Copy&lt;/button&gt;&#xD;&#xA;  &lt;/div&gt;&#xD;&#xA;&lt;p&gt;假设我们把 getSecret() 和 leak() 分别视作 source 和 sink，那么在这个例子中，第 1 行的代码首先通过方法调用获得了一份字符串类型的秘密数据（即污点对象）并把它保存在了变量 taint 中。然后，这份秘密数据会经过两次污点传播流入到第 7 行的 sink 中：&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨14以Datalog为基础的程序分析</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A814%E4%BB%A5datalog%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 18 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A814%E4%BB%A5datalog%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;对于同样的目标：从一组人当中选择出成人&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Imperative（命令式语言）：如何做&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;style=&#34;position:relative;&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34; id = &#34;code1&#34;&gt;Set&lt;Person&gt; selectAdults(Set&lt;Person&gt; persons) {&#xD;&#xA;&#x9;Set&lt;Person&gt; result = new HashSet&lt;&gt;();&#xD;&#xA;&#x9;for (Person person : persons)&#xD;&#xA;&#x9;&#x9;if (person.getAge() &gt;= 18)&#xD;&#xA;&#x9;&#x9;&#x9;result.add(person);&#xD;&#xA;&#x9;return result;&#xD;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;  &lt;button class=&#34;copy-button&#34; data-clipboard-target=&#34;#code1&#34;&gt;Copy&lt;/button&gt;&#xD;&#xA;  &lt;/div&gt;&#xD;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Declarative（声明式语言）：做什么&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;style=&#34;position:relative;&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34; id = &#34;code2&#34;&gt;SELECT * FROM Persons WHERE Age &gt;= 18;&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;  &lt;button class=&#34;copy-button&#34; data-clipboard-target=&#34;#code2&#34;&gt;Copy&lt;/button&gt;&#xD;&#xA;  &lt;/div&gt;&#xD;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;可以看出来声明式语言要比命令式语言简单很多。&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction-to-datalog&#34;&gt;Introduction to Datalog&lt;/h2&gt;&#xA;&lt;h3 id=&#34;datalog&#34;&gt;Datalog&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Datalog 是一种声明性逻辑编程语言，是 Prolog 的子集。&lt;/li&gt;&#xA;&lt;li&gt;它作为一种数据库语言出现（1980 年代中期）&lt;/li&gt;&#xA;&lt;li&gt;现在它有多种应用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序分析&lt;/li&gt;&#xA;&lt;li&gt;声明式网络&lt;/li&gt;&#xA;&lt;li&gt;大数据&lt;/li&gt;&#xA;&lt;li&gt;云计算&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Datalog = &lt;span style=&#34;color: #FF0000;&#34;&gt;Data&lt;/span&gt; + &lt;span style=&#34;color: #FF0000;&#34;&gt;Log&lt;/span&gt;ic（and, or, not）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无副作用&lt;/li&gt;&#xA;&lt;li&gt;无控制流&lt;/li&gt;&#xA;&lt;li&gt;无函数&lt;/li&gt;&#xA;&lt;li&gt;非图灵完备&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;predicates谓词&#34;&gt;Predicates（谓词）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在 Datalog 中，谓词 （relation） 是一组语句&lt;/p&gt;</description>
    </item>
    <item>
      <title>网络安全与检测技术复习要点</title>
      <link>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9/</link>
      <pubDate>Tue, 17 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9/</guid>
      <description>&lt;h2 id=&#34;复习知识要点&#34;&gt;复习知识要点&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1-概论&#34;&gt;1. 概论&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本安全属性的理解&lt;/li&gt;&#xA;&lt;li&gt;Threats and Attacks：能够初步完成威胁模型（Threat model）的分析&lt;/li&gt;&#xA;&lt;li&gt;安全原则Security Principles&#xA;&lt;ul&gt;&#xA;&lt;li&gt;能够理解各安全原则的基本含义，识别出遵从/违背安全原则的设计&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-对称加密&#34;&gt;2. 对称加密&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本概念&#34;&gt;基本概念&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;了解基本的密码学术语及对应关系&lt;/li&gt;&#xA;&lt;li&gt;针对加密消息的攻击类型&lt;/li&gt;&#xA;&lt;li&gt;对称加密的基本构成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;性质：正确性、高效性、安全性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;one-time-pad与流密码&#34;&gt;one-Time Pad与流密码&lt;/h3&gt;&#xA;&lt;h3 id=&#34;des&#34;&gt;DES&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;掌握 Feistel Cipher 结构&lt;/li&gt;&#xA;&lt;li&gt;DES的发展以及其基本结构&lt;/li&gt;&#xA;&lt;li&gt;理解 Avalanche Effect&lt;/li&gt;&#xA;&lt;li&gt;多重加密的安全性，以 2DES 的安全性为主&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aes&#34;&gt;AES&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AES 的发展历史以及其一般结构&lt;/li&gt;&#xA;&lt;li&gt;了解 AES 中的四种变换及其设计原理（不需要记忆Boxes）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Substitute Bytes&lt;/li&gt;&#xA;&lt;li&gt;Shift Rows&lt;/li&gt;&#xA;&lt;li&gt;Mix Columns&lt;/li&gt;&#xA;&lt;li&gt;Add Round Key&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;AES 密钥扩展算法以及其设计原理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;分组加密工作模式-modes-of-operation&#34;&gt;分组加密工作模式 Modes of Operation&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;消息填充&lt;/li&gt;&#xA;&lt;li&gt;理解几种工作模式，比较这几种工作模式的异同/优劣&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECB 、CBC 、OFB 、CFB 、CTR&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;理解几种工作模式的安全性与鲁棒性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CBC 修改密文块攻击&lt;/li&gt;&#xA;&lt;li&gt;分组加密模式的错误传播&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;对不同工作模式的应用场景有一定的了解&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;3-完整性-integrity&#34;&gt;3. 完整性 (Integrity)&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;完整性基本概念&#xA;&lt;ul&gt;&#xA;&lt;li&gt;与机密性的区别&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;hashes&#34;&gt;Hashes&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;（密码学）Hash 函数的基本思想&lt;/li&gt;&#xA;&lt;li&gt;理解 One-wayness、（Weak/Strong）Collision resistance的含义以及其之间关系&lt;/li&gt;&#xA;&lt;li&gt;了解常用的 Hash 函数以及其一般结构&lt;/li&gt;&#xA;&lt;li&gt;应用：Password Hashing&lt;/li&gt;&#xA;&lt;li&gt;理解Hash函数在何种情况无法提供完整性保护？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;macs&#34;&gt;MACs&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;消息认证码的使用方式和定义&lt;/li&gt;&#xA;&lt;li&gt;区别伪造攻击的几种方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;存在形伪造 Existential forgery&lt;/li&gt;&#xA;&lt;li&gt;选择性伪造 Selective forgery&lt;/li&gt;&#xA;&lt;li&gt;通用伪造 Universal forgery&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;消息认证码的几种构造方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;NMAC 、HMAC 、Constructing MAC using Block Cipher&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;理解 MACs 的完整性保证和机密性保证&lt;/li&gt;&#xA;&lt;li&gt;Authenticated Encryption&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;4-非对称加密公认密钥学&#34;&gt;4. 非对称加密/公认密钥学&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于公钥密码学的加密基本流程&lt;/li&gt;&#xA;&lt;li&gt;基于公钥密码学的认证基本流程&lt;/li&gt;&#xA;&lt;li&gt;公钥加密的要求&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Key Generation 、加密、解密&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;基本的模运算&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;diffie-hellman&#34;&gt;Diffie-Hellman&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;能够应用 Diffie-Hellman 密钥交换&lt;/li&gt;&#xA;&lt;li&gt;了解 Diffie-Hellman 的安全性&lt;/li&gt;&#xA;&lt;li&gt;Diffie-Hellman 的中间人攻击（MITM Attack）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;rsa&#34;&gt;RSA&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RSA 的加密解密流程&lt;/li&gt;&#xA;&lt;li&gt;理解并应用 Square-and-multiply 算法&lt;/li&gt;&#xA;&lt;li&gt;了解 RSA 密钥生成过程&lt;/li&gt;&#xA;&lt;li&gt;理解 RSA 的安全性保证&lt;/li&gt;&#xA;&lt;li&gt;了解针对 RSA 的一些攻击&lt;/li&gt;&#xA;&lt;li&gt;数字签名&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如何用 RSA 实现数字签名：RSA Signature&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;pki&#34;&gt;PKI&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;理解密钥分发问题与 Certificates 的基本概念&lt;/li&gt;&#xA;&lt;li&gt;了解几种PKI信任模型&lt;/li&gt;&#xA;&lt;li&gt;X.509&#xA;&lt;ul&gt;&#xA;&lt;li&gt;理解Certificate Revocation的含义&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;5-认证&#34;&gt;5. 认证&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;认证的目标：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Mutual Authentication&lt;/li&gt;&#xA;&lt;li&gt;Key Establishment&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;理解并应用基于对称密钥的认证&lt;/li&gt;&#xA;&lt;li&gt;理解并应用基于非对称密钥的认证&lt;/li&gt;&#xA;&lt;li&gt;了解 Kerberos 并理解其设计原理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Kerberos Realm&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;6-数据隐私&#34;&gt;6. 数据隐私&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本定义与性质&lt;/li&gt;&#xA;&lt;li&gt;ɛ 的含义&lt;/li&gt;&#xA;&lt;li&gt;Laplace机制&lt;/li&gt;&#xA;&lt;li&gt;敏感度分析Sensitivity&lt;/li&gt;&#xA;&lt;li&gt;后处理（Post-processing）的特性&lt;/li&gt;&#xA;&lt;li&gt;组合定理 Basic Composition Theorem&lt;/li&gt;&#xA;&lt;li&gt;Privacy for Non-Numeric Queries&#xA;&lt;ul&gt;&#xA;&lt;li&gt;隐私选择&lt;/li&gt;&#xA;&lt;li&gt;Private Median 的设计方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;本地化差分隐私（Local Differential Privacy）基本定义及方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Randomized Response&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Tradeoff between Utility and Privacy&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;7-实用安全-usable-security&#34;&gt;7. 实用安全 Usable Security&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实用的实人认证&#xA;&lt;ul&gt;&#xA;&lt;li&gt;常见实人认证机制及其优缺点&lt;/li&gt;&#xA;&lt;li&gt;Two-Factor Authentication&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;给定认证机制，分析其安全性与可能攻击面&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;8-网络安全协议&#34;&gt;8. 网络安全协议&lt;/h2&gt;&#xA;&lt;h3 id=&#34;arp-攻击与-dhcp-攻击&#34;&gt;ARP 攻击与 DHCP 攻击&lt;/h3&gt;&#xA;&lt;h3 id=&#34;传输层安全-ssltls&#34;&gt;传输层安全 SSL/TLS&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;SYN Flooding Attack 以及造成 TCP DoS 攻击的原因&lt;/p&gt;</description>
    </item>
    <item>
      <title>分布式系统作业丨02</title>
      <link>https://nju-wrd.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%A802/</link>
      <pubDate>Mon, 16 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%A802/</guid>
      <description>&lt;p&gt;&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https:github.com/Zhang-Xiaoda/NJU-DisSys-2017/&#34; target=&#34;_blank&#34;&gt; 作业地址&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;环境搭建&#34;&gt;环境搭建&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;虚拟机 Ubuntu-22.04.1&lt;/li&gt;&#xA;&lt;li&gt;Go 1.23.4&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://go.dev/dl/&#34; target=&#34;_blank&#34;&gt; GO 下载地址&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;第一次接触 Go 语言还是踩了一些坑的，因为看到老师给出的 ppt 要求在1.5以上，就下载了最新版本，因为墙的原因，我的 Ubuntu 不能直接下载，所以用WinSCP 传到我的 Ubuntu 里面去，接着在b站搜索了一个部署环境的&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://www.bilibili.com/video/BV1PR4y1C7Bw/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1837baf7c46a027b7e27b4ab7174fb85&#34; target=&#34;_blank&#34;&gt;教程&lt;/a&gt;。&lt;del&gt;（虽然一开始错安装成32位的了，导致后续安装其他 package 的时候会和 gcc 的版本不一致）&lt;/del&gt;然后我发现我照着 PPT 上的指令去做，始终不行。我看着报错的内容突然想起了之前看到同学在群里闲聊到这个作业的时候的内容，和 GO 的不同版本的环境配置有关，当时觉得可能有用就顺手收藏了，于是我翻出收藏的内容，输入指令 &lt;code&gt;export GO111MODULE=off&lt;/code&gt; 果然好使。&lt;/p&gt;&#xA;&lt;h2 id=&#34;assignment-part-i&#34;&gt;Assignment Part I&lt;/h2&gt;&#xA;&lt;h4 id=&#34;任务要求&#34;&gt;任务要求&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Implement Raft by adding code to raft/raft.go (only)&lt;/p&gt;&#xA;&lt;p&gt;– find some example code of how to send and receive RPC&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Your task: Leader election:&lt;/p&gt;&#xA;&lt;p&gt;– First task is to fill the RequestVoteArgs and RequestVoteReply structs&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨13针对安全方面的静态分析</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A813%E9%92%88%E5%AF%B9%E5%AE%89%E5%85%A8%E6%96%B9%E9%9D%A2%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 16 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A813%E9%92%88%E5%AF%B9%E5%AE%89%E5%85%A8%E6%96%B9%E9%9D%A2%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;computer-security&#34;&gt;Computer Security&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Goals&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dependability&lt;/li&gt;&#xA;&lt;li&gt;Data safety&lt;/li&gt;&#xA;&lt;li&gt;…&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Adversaries&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Crackers&lt;/li&gt;&#xA;&lt;li&gt;Cyber attackers&lt;/li&gt;&#xA;&lt;li&gt;…&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;causes-of-exploited-vulnerabilities造成已被利用的漏洞的原因&#34;&gt;Causes of exploited vulnerabilities（造成已被利用的漏洞的原因）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Injection errors&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Information leaks&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这两点其实就是本节课要解决的问题&lt;/p&gt;&#xA;&lt;h2 id=&#34;information-flow-security&#34;&gt;Information Flow Security&lt;/h2&gt;&#xA;&lt;p&gt;我们要防止不必要的信息流动 保护信息安全&lt;/p&gt;&#xA;&lt;h3 id=&#34;access-control-vs-information-flow-security&#34;&gt;Access Control vs. Information Flow Security&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;访问控制（保护敏感数据的标准方法）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检查程序是否具有访问某些信息的权限&lt;/li&gt;&#xA;&lt;li&gt;关注信息的访问方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;信息流安全（端到端）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;跟踪信息如何流经程序，以确保程序安全地处理信息&lt;/li&gt;&#xA;&lt;li&gt;关注信息的传播方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;information-flow&#34;&gt;Information Flow&lt;/h3&gt;&#xA;&lt;p&gt;信息流：如果变量 x 中的信息被转移到变量 y，那么存在信息流 y → x&lt;/p&gt;&#xA;&lt;img src = &#34;example.png&#34; alt = &#34;示例&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;information-flow-security-1&#34;&gt;Information Flow Security&lt;/h3&gt;&#xA;&lt;p&gt;将信息流与安全联系起来&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将程序变量分类为不同的安全级别&lt;/li&gt;&#xA;&lt;li&gt;指定这些级别之间允许的流，即信息流策略&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;security-levels-classes&#34;&gt;Security Levels (Classes)&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;最基本的模型是两级策略，即一个变量被分为两个安全级别之一：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;H，意为高安全性、秘密信息&lt;/li&gt;&#xA;&lt;li&gt;L，表示低安全性，公共可观察信息&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;h = getPassword(); // h is high security&lt;/li&gt;&#xA;&lt;li&gt;broadcast(l);           // l is low security&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;安全级别可以建模为 lattice*&lt;/p&gt;</description>
    </item>
    <item>
      <title>分布式系统作业丨01</title>
      <link>https://nju-wrd.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%A801/</link>
      <pubDate>Sun, 15 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%A801/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;远程过程调用 (RPC) 是一种允许程序在不同计算机之间进行通信的协议。它使得客户端可以像调用本地函数一样调用远程服务器上的函数，而无需了解底层的网络细节。这一次的作业是实现RPC机制下的“黑杰克”游戏&lt;/p&gt;&#xA;&lt;h2 id=&#34;分析与设计&#34;&gt;分析与设计&lt;/h2&gt;&#xA;&lt;p&gt;首先在 ubuntu 下下载并使用 rpcgen 编写 .x 文件，使用 rpcgen blackjack.x 生成文件并完善逻辑。&lt;/p&gt;&#xA;&lt;p&gt;基本规则如下：&lt;/p&gt;&#xA;&lt;h3 id=&#34;卡片值&#34;&gt;卡片值&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数字牌(2-10)：牌的价值等于其面值。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;人头牌(J、Q、K):每张价值10分。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;A:可以值1分或11分，具体取决于哪个对玩家的手牌更有利。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;所以我用两个数组分别记录四个花色和13种牌面，外循环来选择牌面，内循环选择花色，来给 52 张牌初始化，并且外循环的牌面从 2 开始，也就是 2 - 10，J ，Q ，K ，A ，这样 2  - 10 的部分用外循环的值加2即可，然后针对 i + 2 等于 11，12，13 的赋值为 10，等于  14 则赋值为 11 。并且根据有多少副牌就重复多少次这个过程。在计分时，每遇到一个手牌分值为11的就用一个变量记录一次，这样当手牌分值超过 21 且记录值大于 0 的时候，总分减去 10，这样就达成了 A 值 1 分或 11 分取决于哪个对玩家更有利的规则。&lt;/p&gt;&#xA;&lt;h3 id=&#34;游戏流程&#34;&gt;游戏流程&lt;/h3&gt;&#xA;&lt;p&gt;游戏用一个结构体game state来表示这场游戏的状态：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;style=&#34;position:relative;&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34; id = &#34;code1&#34;&gt;struct game_state {&#xD;&#xA;    int num_decks;&#xD;&#xA;    int action;  /* 玩家操作：0: 拿牌, 1: 停牌 */&#xD;&#xA;    struct hand player_hand; /* 玩家手牌 */&#xD;&#xA;    struct hand dealer_hand; /* 庄家手牌 */&#xD;&#xA;    int player_busted; /* 玩家是否爆牌 (0: 未爆牌, 1: 已爆牌) */&#xD;&#xA;    int dealer_busted; /* 庄家是否爆牌 (0: 未爆牌, 1: 已爆牌) */&#xD;&#xA;    int result; /* 游戏结果 (0: 游戏进行中, 1: 玩家赢, 2: 庄家赢, 3: 平局) */&#xD;&#xA;};&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;&lt;button class=&#34;copy-button&#34; data-clipboard-target=&#34;#code1&#34;&gt;Copy&lt;/button&gt;&#xD;&#xA;&lt;/div&gt;&#xD;&#xA;&lt;p&gt;这个结构体用来表示一张牌，主要有三个部分&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A7</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a7/</link>
      <pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a7/</guid>
      <description>&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa7.html&#34; target=&#34;_blank&#34;&gt;作业 7：Alias-Aware 的过程间常量传播&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业目标&#34;&gt;作业目标&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为 Java 实现一个 alias-aware 的过程间常量传播分析&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在本次作业中，我们需要在作业4的基础上，进一步提高常量传播的精度。具体而言，我们需要借助之前作业中实现的指针分析，根据指针分析结果来得到程序中的别名（alias）信息，并用这一信息来在过程间常量传播中更精确地处理对象字段（field）和数组（array）。&lt;/p&gt;&#xA;&lt;p&gt;和作业4一样，常量传播中只需要考虑 int 类型的值，但在本次作业中，需要额外考虑程序中的别名，用别名信息来更精确地处理对字段和数组的存取。不过，可以忽略一些将在后续描述的情况。&lt;/p&gt;&#xA;&lt;h2 id=&#34;alias-aware的常量传播&#34;&gt;Alias-Aware的常量传播&lt;/h2&gt;&#xA;&lt;h3 id=&#34;别名&#34;&gt;别名&lt;/h3&gt;&#xA;&lt;p&gt;别名用于描述以下情况：一个内存中的数据位置可以通过不同的符号名来访问，这些指向内存中的同一位置的不同符号互为别名 。在 Java 中，对实例字段和数组的访问可以形成别名，举例来说，如果变量 x 和 y 指向相同的对象，那么 x.f 和 y.f 这两个字段访问构成了别名，因为它们实际上指向同一个字段；如果变量 a 和 b 指向同一个数组，并且 i 和 j 有相同的值，那么 a[i] 和 b[j] 这两个数组访问构成了别名，因为它们实际上指向同一个数组中的同一个位置。&lt;/p&gt;&#xA;&lt;p&gt;在别名存在的情况下，通过对一个字段/数组的访问来修改一个实例字段/数组将会同时修改与这一访问相关的所有别名值。举例来说，如果 x.f，y.f 和 z.f 互为别名，那么 store 语句 x.f = 5; 不仅将 x.f 的值修改为 5，而且同时将 y.f 和 z.f 的值设为 5。因此，为了在常量传播中精确地分析字段和数组的值，我们需要取得被分析程序的别名信息。&lt;/p&gt;&#xA;&lt;p&gt;值得注意的是，Java 中的静态字段不能拥有别名：对一个静态字段 T.f，它有唯一的符号名（即 T.f），且只能通过 T.f 被访问。由于不需要考虑别名的存在，对静态字段的处理要比对实例字段和数组的处理简单。&lt;/p&gt;</description>
    </item>
    <item>
      <title>网络安全与检测技术学习笔记丨02</title>
      <link>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A802/</link>
      <pubDate>Tue, 10 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A802/</guid>
      <description>&lt;h2 id=&#34;lec04-symmetric-key-cryptography&#34;&gt;Lec04 Symmetric Key Cryptography&lt;/h2&gt;&#xA;&lt;h3 id=&#34;how-to-use-a-block-cipher&#34;&gt;How to use a block cipher?&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分组密码加密固定大小的块&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例如，DES 加密 64 位块，AES 加密 128 位块&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;用某种方法来加密任意长度的消息&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;我们如何使用 AES 加密 256 位消息？&lt;/p&gt;&#xA;&lt;p&gt;我们可以使用 AES 两次！避免像 one-time pads 这样的情况，需要很长的键。&lt;/p&gt;&#xA;&lt;h3 id=&#34;modes-of-operation&#34;&gt;Modes of Operation&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;电子密码簿模式 （ECB）Electronic Codebook Mode&lt;/li&gt;&#xA;&lt;li&gt;密码块链接模式 （CBC）Cipher Block Chaining Mode&lt;/li&gt;&#xA;&lt;li&gt;输出反馈模式 （OFB）Output Feedback Mode&lt;/li&gt;&#xA;&lt;li&gt;密码反馈模式 （CFB）Cipher Feedback Mode&lt;/li&gt;&#xA;&lt;li&gt;计数器模式 （CTR）Counter Mode&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;electronic-code-book-ecb&#34;&gt;Electronic Code Book (ECB)&lt;/h4&gt;&#xA;&lt;p&gt;我们刚刚就设计了一个 ECB 模式。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最简单模式&lt;/li&gt;&#xA;&lt;li&gt;明文一次处理 b 位&lt;/li&gt;&#xA;&lt;li&gt;每个块都使用相同的密钥进行加密&lt;/li&gt;&#xA;&lt;li&gt;对于给定的密钥，每个 b 位纯文本块都有一个唯一的密文&lt;/li&gt;&#xA;&lt;li&gt;每个 b 明文位块都使用相同的密钥独立编码&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;AES-ECB 不是 IND-CPA 安全的。为什么？&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨11上下文敏感指针分析I</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A811%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90i/</link>
      <pubDate>Sat, 07 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A811%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90i/</guid>
      <description>&lt;h2 id=&#34;problem-of-context-insensitive--pointer-analysis&#34;&gt;Problem of Context-Insensitive  Pointer Analysis&lt;/h2&gt;&#xA;&lt;image src = &#34;problem.png&#34; alt = &#34;存在的问题&#34;/&gt;&#xD;&#xA;&lt;p&gt;在 CI（Content Insensitive）中，处理 x.get() 时，因为 x 是Number类型，所以这里会 Dispatch 到两个方法，并且将两条边都加入 CG 中。但是，其实可以看到有一条边是明显冗余的，在实际执行中并不是 x 的指向目标，这在常量传播分析当中会直接导致 i 成为一个 NAC 。&lt;/p&gt;&#xA;&lt;image src = &#34;via.png&#34; alt = &#34;改变后&#34;/&gt;&#xD;&#xA;&lt;p&gt;采用 CS（Content Sensitive）后，由于对上下文敏感了，所以现在对于 id(n) 的调用，分为两次去分析。&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;再简单总结一下 CI 带来的imprecision 的原因。&lt;/p&gt;&#xA;&lt;p&gt;在动态执行中，一个方法可能在不同的调用上下文中被多次调用，而在不同调用上下文中，该方法中的变量可能指向不同的对象，在 CI 指针分析中，不同上下文的对象被混合并传播到程序的其它部分（通过返回值或副作用），导致虚假的数据流。&lt;/p&gt;&#xA;&lt;p&gt;上下文敏感性模型通过区分不同上下文的不同数据流来调用上下文，以提高精度。最古老且最著名的上下文敏感性策略是调用点敏感性（ call-string ）：每个方法上下文都表示为调用点的链，即方法的一个调用点、；调用者的一个调用点；调用者的调用者的一个调用点等。&lt;/p&gt;&#xA;&lt;image src = &#34;example.png&#34; alt = &#34;例子&#34;/&gt;&#xD;&#xA;&lt;p&gt;在 CS 中，这里的方法 id(Number)有两个上下文：[1] 和 [2]。&lt;/p&gt;&#xA;&lt;h3 id=&#34;cloning-based-context-sensitivity&#34;&gt;Cloning-Based Context Sensitivity&lt;/h3&gt;&#xA;&lt;p&gt;基于克隆的上下文敏感分析是最直接的方法来实现上下文敏感性。在基于克隆的上下文相关指针分析中，每种方法都由一个或多个上下文来限定，变量也由上下文（从它们声明的函数继承而来）进行限定，本质上，每种方法和其变量都被克隆，每个上下文一个克隆。&lt;/p&gt;&#xA;&lt;h3 id=&#34;context-sensitive-heap&#34;&gt;Context-Sensitive Heap&lt;/h3&gt;&#xA;&lt;p&gt;OO 程序（例如 Java ）通常是堆密集型，在实践中，为了提高精度，对堆抽象也应用上下文敏感性，抽象对象也由上下文（称为堆上下文）限定，最常见的做法是从分配对象的方法中继承上下文。上下文敏感的堆抽象在分配站点抽象之上提供了一个更细粒度的堆模型。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨12上下文敏感指针分析II</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A812%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90ii/</link>
      <pubDate>Sat, 07 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A812%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90ii/</guid>
      <description>&lt;h2 id=&#34;context-sensitive-pointer-analysis-algorithms&#34;&gt;Context Sensitive Pointer Analysis: Algorithms&lt;/h2&gt;&#xA;&lt;h3 id=&#34;how-to-implement-context-sensitive-pointer-analysis&#34;&gt;How to Implement Context-Sensitive Pointer Analysis&lt;/h3&gt;&#xA;&lt;img src = &#34;dependent.png&#34; alt = &#34;相互依赖的过程&#34; /&gt;&#xD;&#xA;&lt;p&gt;类似于上下文无关指针分析，依旧是在构建 PFG 的同时利用 PFG 传播指针信息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;cs-pointer-analysis-algorithm&#34;&gt;C.S. Pointer Analysis: Algorithm&lt;/h3&gt;&#xA;&lt;p&gt;算法如下所示：&lt;/p&gt;&#xA;&lt;img src = &#34;algorithm.png&#34; alt = &#34;算法&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里和前面类似，主要是加上了限定的上下文，就不再赘述，对于上下文的信息，在调用规则里也有体现。&lt;/p&gt;&#xA;&lt;h2 id=&#34;context-sensitivity-variants&#34;&gt;Context Sensitivity Variants&lt;/h2&gt;&#xA;&lt;h3 id=&#34;call-site-sensitivity&#34;&gt;Call-Site Sensitivity&lt;/h3&gt;&#xA;&lt;img src = &#34;variant.png&#34; alt = &#34;select&#34; /&gt;&#xD;&#xA;&lt;p&gt;Select 算法会根据三个参数来确定，分别是调用者上下文，调用点，有堆上下文的接收对象。&lt;/p&gt;&#xA;&lt;p&gt;上下文无关可以被视为 C.S.分析框架中上下文敏感性的一个特例：Select(,,) = []&lt;/p&gt;&#xA;&lt;p&gt;每个上下文都由一系列调用点（调用链）组成，在方法调用时，将调用位置追加到调用者上下文中作为被调用者上下文，本质上是对调用栈的抽象。&lt;/p&gt;&#xA;&lt;img src = &#34;call-string.png&#34; alt = &#34;call-string&#34; /&gt;&#xD;&#xA;&lt;p&gt;这个方法存在一定的问题，看下图例子：&lt;/p&gt;&#xA;&lt;img src = &#34;example.png&#34; alt = &#34;call-string&#34; /&gt;&#xD;&#xA;&lt;p&gt;可以看到在函数之间循环的调用时，会导致调用链无限变长。所以这里的 k 其实就是用于对上下文抽象的限制。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A6</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a6/</link>
      <pubDate>Sat, 07 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a6/</guid>
      <description>&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa6.html&#34; target=&#34;_blank&#34;&gt;作业 6：上下文敏感的指针分析&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业目标&#34;&gt;作业目标&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为 Java 实现一个上下文敏感的指针分析框架。&lt;/li&gt;&#xA;&lt;li&gt;作为指针分析的一部分，随着指针分析一起实现调用图（call graph）构建。&lt;/li&gt;&#xA;&lt;li&gt;实现几种常见的上下文敏感策略（context sensitivity variants）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;新的分析规则&#34;&gt;新的分析规则&lt;/h2&gt;&#xA;&lt;p&gt;在这一节中，我们引入与上次实验类似的新的指针分析规则来处理静态字段、数组索引和静态方法调用，主要区别在于上下文的部分&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;静态字段&lt;/strong&gt;的处理很简单：我们只需要在静态字段和变量之间传值。我们用 T.f 表示静态字段 T.f 的指针，然后定义如下规则来处理静态字段的 store 和 load：&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;thead&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;th&gt;类型&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;语句&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;规则（在上下文c下）&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;PFG 边&lt;/th&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/thead&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Static Store&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;T.f = y&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;1.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;T.f ← c:y&lt;/sub&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Static Load&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;y = T.f&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;2.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;c:y ← T.f&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;p&gt;常规指针分析不区分对不同&lt;strong&gt;数组索引&lt;/strong&gt;（位置）的 load 和 store。假设 c&amp;rsquo;:o&lt;sub&gt;i&lt;/sub&gt; 代表一个具有上下文c&amp;rsquo;的数组对象，那么我们用 c&amp;rsquo;:o&lt;sub&gt;i&lt;/sub&gt;[∗] 表示一个指向数组中所有对象的指针（无论保存在数组的什么位置）。基于这样的处理，我们定义了数组 store 和 load 的规则：&lt;/p&gt;</description>
    </item>
    <item>
      <title>网易雷火游戏大赛总结</title>
      <link>https://nju-wrd.github.io/posts/%E7%BD%91%E6%98%93%E9%9B%B7%E7%81%AB%E6%B8%B8%E6%88%8F%E5%A4%A7%E8%B5%9B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 03 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E7%BD%91%E6%98%93%E9%9B%B7%E7%81%AB%E6%B8%B8%E6%88%8F%E5%A4%A7%E8%B5%9B%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h2 id=&#34;滴滴&#34;&gt;滴滴&lt;/h2&gt;&#xA;&lt;p&gt;起初是在年级群内看到了有关南大计科和网易雷火共同举办 makes 游戏大赛的推送。我当时看了就挺想参加的，不单单是因为喜欢游戏，也是为了恰好在我喜欢的领域内丰富一下自己的履历。其实本科阶段一直没有完整的参加过一场比赛，这一次或许可以弥补这样的遗憾，我这样思考过，甚至还用参加了可以抽奖拿礼品的接口“哄骗”自己参加。以前从来没想过在游戏领域做程序开发的工作，虽然我一直很爱游戏，并且在这方面可以说是一个杂食性动物。但我竟然从未意识到我作为一个程序员，事实上可以通过自己的努力进入到游戏开发制作的流程当中，或许是未经思考就放弃了开始的过程吧。我先是发了朋友圈分享活动，并截图填写问卷，因为它说了这样可以参与抽奖，但是最后不知道参与到哪里去了，除了群内本来就有的参与组队抽奖，简直杳无音讯啊。人们常说事以密成，我也一直把这句话当作一个格言来践行，发了这个朋友圈之后我就在想我这么早就发了，会不会又完不成。不过我确实是安慰自己的高手，我告诉自己，就算完不成，我可以就当作来抽奖的，也没有关系的。&lt;/p&gt;&#xA;&lt;p&gt;这时候我还对游戏制作毫无头绪呢，我也有模有样的照着群公告，先给自己改一个“程序”的群昵称，这应该不会错。但随后我就有点焦虑了，我这啥也不会啊，于是打开了 GPT 和 B 站大学，从游戏开发有哪些工具，用那些语言到它的使用广泛程度再到对应的各种攻略是否完善我都进行了反复的搜索以及简单的查看，最终我锁定了两个引擎，分别是 Unity 和 UE ，并先行开始学习起 Unity 了，因为我注意到它貌似更 popular 一些（注意力惊人。由此看来，我还是想认真组队完成比赛的，我可不想在组队的时候别人问我会什么，然后我是啥也不会因此最终组不到队伍，况且多学点到时候底气也足些。我也按照教程学习安装，安装完成后止步于此哈哈哈哈哈哈。这会也想不起来当时去做什么了，当时群里正是组队的小高峰，有个同学找到我说要组队，我便同意了，于是我们便口头组成了两人小队，我也将组队一事先放下了，再后来他忙我也忙，早把这件事抛诸脑后了。终于在组队截止临近的时候（也许也没有临近），又有一个人找到我，那时候群内的组队消息已经很少了，当时的我也没想到还会有人来组队了。那一刻，突兀的滴滴声在耳边响起时，我是承认我心动了，就像是一个溺水者，眼前出现了一个藤曼，但是我还留有一丝愧疚，因为是的，我曾经有一个队友。于是我在想要不要和他说一下我找其他队伍了，毕竟我们从那次之后真的很久不联系，也因此，我也没开口，终究会有一天，当他回来的时候发现这个家已经散了，那个时候告诉他也不迟，并且我甚至不知道他还要不要参赛。于是我果断“弃暗投明”，当时的我生怕来找我的同学找到了新的队友，急得我在床上翻来覆去，可以说是穷尽我的网络沟通功底，让她感受到我是一个温和可亲，好沟通且成长空间很大的队友，不过好像他们缺一个南大的同学（赛制要求），对这些并不是很在意~&lt;/p&gt;&#xA;&lt;p&gt;进群就发现这个队伍确实要靠谱一些，她把以前的聊天记录发在群里包括初期的策划案等内容，已经有一些小成果了，让我还有点诚惶诚恐。我点开文档了解到我们的游戏是用 UE 引擎开发，真是让我喜出望外，还好没学 Unity ，不过是可以这么说的吗哈哈。不过我收藏已久（2周左右）的 UE 教程刚好可以拿出来派上用场。不得不吐槽当时我的电脑下载的是真慢啊，令人折磨。&lt;/p&gt;&#xA;&lt;h2 id=&#34;在黑夜里&#34;&gt;在黑夜里&lt;/h2&gt;&#xA;&lt;p&gt;经历了前期很多很多次的腾讯会议的讨论和游戏制作过程中的交流，我们也渐渐熟络一些，不过大家好像都比较内向，说话比较少比较谨慎的感觉。&lt;/p&gt;&#xA;&lt;p&gt;当时临近学期的期中时间，大家都比较忙，远在埃及的美术老师刚从外地回到她在埃及的学校，并且肝完了美术部分的内容。然后程序还积压了很多优化和改动的部分要完成。不巧的是，一次 ddl 就快到了，所以策划也是和我们开会讨论要完成的内容，他最终也会做些打包提交的工作。那几天真是不眠不休的几天啊，起初的第一天我以为我弄清楚了一个内容的问题就好了，就是说我做好了一个小地图的 UI 模板，后面做一些重复的体力劳动即可，没想到这一弄就是一整夜，通宵到了第二天早上。而比睡觉来的更早的竟然是妈妈的早饭，当时心里并没有感到很疲惫，倒是有一种兴奋感，虽然我吃完早饭便沉沉睡去，毕竟再不睡可不行了。第二天，策划索性建议我们一起打电话修改了，前一天另一个程序就是边打电话边改，有问题随时沟通，结果比第一天要好一些，四点多便睡了。最后一天是三点。最终也是成功交了一版上去。&lt;/p&gt;&#xA;&lt;p&gt;经过了中期之后，大家仿佛更忙了，都有些顾不上比赛了，最后也是在中期之后只做了一些小修改就最终完赛了。其实当时的我在中期刚结束的时候还好，但是其他队友很忙，到了快截止的时候，我又比较忙，有一点错开的感觉，毕竟要同时平衡学习，科研，上课和比赛还是有点困难。后来据策划所说，当时那个晚上只有他自己一个人内心有点小崩，我只能表示心疼3秒❤️‍🩹。&lt;/p&gt;&#xA;&lt;h2 id=&#34;正午的阳光&#34;&gt;正午的阳光&lt;/h2&gt;&#xA;&lt;p&gt;就这样略带稀里糊涂的完赛了，本以为就这样结束了，让人意想不到的是我们最后还进入了决赛，不过这也意味着我可以和我的队友们线下面基了。最终我见到了两位队友，一位程序因为忙着秋招之类的事来不来，还有一位美术人在埃及太远了。&lt;/p&gt;&#xA;&lt;p&gt;我的队友 Q.C 从没来之前就开始问我一些有关南京的问题，我们在那几天也是交流颇多，在另外一个队友桃子到了之后，Q.C 提议问我要不要一起出来，顺便带他们逛逛，我也是欣然应邀前往。当时他们上午正逛了寻玄武湖，于是我便建议去先锋书店看看吧，他们先去吃中饭，我也吃完中饭再出发。&lt;/p&gt;&#xA;&lt;p&gt;那两天的南京格外的热，阳光也十分强烈但也说不上刺眼或是灼热，就是冬日里的暖阳，不过要是还像前几天一样的穿衣，就有些热了，不巧的是我就穿的有点多。花了一个小时，我到了老门东的先锋书店，这里我也没有来过，刚好一起看看。我到了之后没看到回复，便进去先观望一下，顺便参观参观。这里不算大，和广州路的总店比起来，风格差异很大，和老门东的整体风格很像，也算是一种“本土化”吧。过了一会收到消息才知道他们在外面，我就出去找他们，其实在我设想的里面，他们俩应该是一起在某一个地方等我，但是没想到只见到了一个人在那个位置张望，导致我有点不敢认。初见面，就看的出来每个人的社交属性了。由于我在三人之中显得最外向，加上又是本地佬，于是我便提议去喝一杯南京的拾叁茶，加上今天太阳确实很大，一路过来都有点口渴了。找店的过程也是经历一番磨难，不过感觉在这个过程中，大家也会更熟悉一些，虽然还是都很拘谨。我们在奶茶店促膝长谈，现在想来还确实蛮有意思的，对我来说，也是第一次线下和网友见面。&lt;/p&gt;&#xA;&lt;p&gt;短暂休息之后我们回归主线任务，为明天的游戏展准备一些小物料布置展台什么的，我们准备去打印一些类似明信片的东西。这一路上也是蛮有意思，我在前面带路，我们边聊边走，然后在去到的打印店交流沟通。这过程不知道为什么给我颇有一种真人秀的感觉，每个人都为了完成任务一起在路上奔波，并且大家彼此之间还不是非常熟。我们一共去了两家，最终花了30元打印了24张卡片。&lt;/p&gt;&#xA;&lt;p&gt;这个时候又回归无头苍蝇状态，本来计划推荐去的地方又想不起来，我一拍脑袋想到之前随口说的去德基看厕所，他们也不知道什么情况，不过我自己也没去过，就一起被我忽悠去了。看着小红书上说的“迪拜土豪风”、“赛博朋克风”等等，我们共同感叹道有点像 KTV，在某些方面达成共识。&lt;/p&gt;&#xA;&lt;p&gt;因为南京的地铁人真的很多，加上德基里面弥漫着一股香水味，他们俩也逛了快一天了很累。当时已经五点半左右了，所以就先走了，不过我其实还想看一下“中式禅意风”会不会有什么不一样，哈哈哈，毕竟只有一层之隔了，我也没见过。不过没去好像也没什么好可惜的，走出德基，呼吸到新鲜空气我突然想到一个好去处，水游城。水游城是一个适合年轻人的好去处，如果你不知道为什么，我也不好说，懂得都懂。在这方面我们也算是打开了话匣子，从番剧到游戏，聊得越来越随意些了。&lt;/p&gt;&#xA;&lt;p&gt;来到了水游城，我也是再一次带他们去了我熟悉的辛香汇，三个人吃了180左右，愣是没吃完，可能来旅游确实是会导致最后吃不下东西吧。我有些意犹未尽，提议再一起去里面逛逛就回去。事实证明在这里玩果然比德基更吸引人一些，更符合大家的爱好。&lt;/p&gt;&#xA;&lt;p&gt;到了第二天来决赛现场进行游戏展和答辩的时候，我们也是比第一天更熟悉了，感觉已经可以说是朋友了。我们一起布置自己的展台，引导别人玩自己的游戏，也去体验别人的游戏。答辩完后，我们还在校内小逛了一下。&lt;/p&gt;&#xA;&lt;p&gt;为了等结果多等了半小时还没有获奖真是令人悲伤啊。不过虽然最终没有得奖，不过不影响我的第一次 GameJam 经历给我带来了很多体验和快乐。本来说我们要一起留影一张来留下纪念的，但是最后确实等久了，要去赶高铁回去了，也是留下一些小遗憾。不过就像 Q.C 在答辩上说的遗憾也是一种人生常态一样，我相信有遗憾一定会有下一次更好的结果。&lt;/p&gt;</description>
    </item>
    <item>
      <title>24腾讯游戏客户端公开课作业丨01</title>
      <link>https://nju-wrd.github.io/posts/24%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E4%BD%9C%E4%B8%9A%E4%B8%A801/</link>
      <pubDate>Sun, 24 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/24%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E4%BD%9C%E4%B8%9A%E4%B8%A801/</guid>
      <description>&lt;h2 id=&#34;作业内容&#34;&gt;作业内容&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;编译UE5源码&lt;/li&gt;&#xA;&lt;li&gt;Androiod打包&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;过程&#34;&gt;过程&lt;/h2&gt;&#xA;&lt;p&gt;首先，需要安装 git ，安装的链接参考是 &lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://blog.csdn.net/weixin_42242910/article/details/136297201&#34; target=&#34;_blank&#34;&gt;windows安装git&lt;/a&gt; 。然后需要在你想存储的地方打开 git bash ，进行 git clone 。克隆 Unreal Engine 的官方源码需要一个 GitHub 账号，并且要和 Epic 账号绑定，才能加入 group 有权限下载源码，这一点可以参考官方的 &lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://www.epicgames.com/help/zh-CN/c-Category_EpicAccount/c-ConnectedAccounts/unreal-enginegithub-a000084938&#34; target=&#34;_blank&#34;&gt;help 文档页面&lt;/a&gt;。完成这一步之后需要在你的 git bash 界面设置你的账户，一种是通过修改配置文件，利用以下两条语句配置你的 Git 账号信息：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git config --global user.name &amp;#34;your-github-username&amp;#34;&#xD;&#xA;git config --global user.email &amp;#34;your-email@example.com&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后利用 &lt;code&gt;git clone https://github.com/EpicGames/UnrealEngine.git&lt;/code&gt;在 git bash 中进行下载。&lt;/p&gt;&#xA;&lt;p&gt;其次可以通过生成 ssh 密钥，首先在 Git Bash 中生成 SSH 密钥：&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;ssh-keygen -t rsa -b 4096 -C &amp;quot;your-email@example.com&amp;quot;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;通常在你的当前用户的 C:\Users\admin\.ssh下的id_rsa.pub 文件中，复制公钥内容并将其添加到 GitHub 的 SSH Keys 设置中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A5</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a5/</link>
      <pubDate>Sun, 24 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a5/</guid>
      <description>&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa5.html&#34; target=&#34;_blank&#34;&gt;作业 5：非上下文敏感指针分析&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业目标&#34;&gt;作业目标&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为 Java 实现非上下文敏感的指针分析。&lt;/li&gt;&#xA;&lt;li&gt;为指针分析实现一个调用图的实时构建算法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在本次作业中，我们将在 Tai-e 上为 Java 实现一个非上下文敏感的指针分析，并在指针分析的过程中实时构建调用图。如果实现正确，该调用图会比用类层次结构分析（CHA）建立的更加精确。&lt;/p&gt;&#xA;&lt;p&gt;在本次作业中，我们将学习如何处理课上没有涉及的一些 Java 特性，即静态字段、数组和静态方法，这样我们的指针分析就可以处理 Java 中所有类型的指针了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;新的分析规则&#34;&gt;新的分析规则&lt;/h2&gt;&#xA;&lt;p&gt;在这一节中，我们引入新的指针分析规则来处理静态字段、数组索引和静态方法调用。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;静态字段&lt;/strong&gt;的处理很简单：我们只需要在静态字段和变量之间传值。我们用 T.f 表示静态字段 &lt;code&gt;T.f&lt;/code&gt; 的指针，然后定义如下规则来处理静态字段的 store 和 load：&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;thead&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;th&gt;类型&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;语句&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;规则&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;PFG 边&lt;/th&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/thead&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Static Store&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;T.f = y&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;1.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;        &lt;td&gt;T.f ← y&lt;/sub&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Static Load&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;y = T.f&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;2.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;y ← T.f&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;p&gt;常规指针分析不区分对不同&lt;strong&gt;数组索引&lt;/strong&gt;（位置）的 load 和 store。假设 o&lt;sub&gt;i&lt;/sub&gt; 代表一个数组对象，那么我们用 o&lt;sub&gt;i&lt;/sub&gt;[∗] 表示一个指向数组中所有对象的指针（无论保存在数组的什么位置）。基于这样的处理，我们定义了数组 store 和 load 的规则：&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨10指针分析基础II</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A810%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80ii/</link>
      <pubDate>Thu, 21 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A810%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80ii/</guid>
      <description>&lt;h2 id=&#34;pointer-analysis-with-method-calls&#34;&gt;Pointer Analysis with Method Calls&lt;/h2&gt;&#xA;&lt;p&gt;过程间指针分析需要调用图，在 &lt;a style=&#34;color: #0000FF;&#34; href = &#34;https://nju-wrd.github.io//posts/软件分析学习笔记丨07过程间分析/#01&#34; target=&#34;_blank&#34; &gt;07 过程间分析中&lt;/a&gt;，我们采用了 CHA 方法来构造调用图。但是它本身是不精确的，因为它在一些情况下引入虚假的调用边和指向关系。&lt;/p&gt;&#xA;&lt;p&gt;而利用指针分析的方法，会比CHA更加精确。并且这种好处对调用图和指向关系的构建都会带来更精确的好处。规则如下：&lt;/p&gt;&#xA;&lt;img src = &#34;rule.png&#34; alt = &#34;规则&#34;/&gt;&#xD;&#xA;&lt;p&gt;我们来一点一点解析这里面的符号所代表的含义。这里的 Dispatch(o&lt;sub&gt;i&lt;/sub&gt;,k) 和前面 CHA 中的本质上是一样的，它利用 receive object o&lt;sub&gt;i&lt;/sub&gt; 的类型和调用点方法的签名 k 来找到实际的调用方法 m 。m&lt;sub&gt;this&lt;/sub&gt; 代表当前找到的目标方法的 this 变量。a&lt;sub&gt;j&lt;/sub&gt; 表示调用的第 j 个参数。m&lt;sub&gt;pj&lt;/sub&gt; 表示 m 的第 j 个参数。所以为了将调用的参数对应传递给 m 的参数，会在他们之间加上 PFG 边进行指向信息的传递。&lt;/p&gt;&#xA;&lt;img src = &#34;edge.png&#34; alt = &#34;加边&#34;/&gt;&#xD;&#xA;&lt;p&gt;m&lt;sub&gt;ret&lt;/sub&gt; 代表 m 的返回值，将返回值赋给调用点的左值。&lt;/p&gt;&#xA;&lt;p&gt;这里可以思考一个问题也就是为什么我们在处理 m&lt;sub&gt;this&lt;/sub&gt; 的时候，不和参数一样直接添加 PFG Edge ？&lt;/p&gt;&#xA;&lt;img src = &#34;example.png&#34; alt = &#34;例子&#34;/&gt;&#xD;&#xA;&lt;p&gt;首先我们知道在 Java 中，this 是一个很重要的变量，方法中可能会频繁地使用 this 变量，所以 this 变量的指向信息的正确性十分重要。我们再来看上图的例子，如果我们直接引入新 PFG Edge ，会导致给方法的 this 引入虚假的指向关系。具体来说在下面的三个方法中，其实每个方法的 this 的指向的类都是声明方法的类本身。而在 x 调用foo方法的时候，如果直接引入 PFG Edge，会将 x 原来所有的指向信息都流入找到的方法的 this ，但其实最终 this 只会是其中一个，而这由具体调用到哪个方法所决定。所以为了避免给 this 引入虚假的指向信息，我们不能和参数一样直接添加 PFG Edge。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨06 Rasterization 2（Antialiasing）</title>
      <link>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A806-rasterization-2antialiasing/</link>
      <pubDate>Thu, 14 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A806-rasterization-2antialiasing/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&lt;s&gt;在我开始写博客之前我已经学完了前面的五次课，并且完成了作业0和作业1。在我简单回顾之后，我本来是想把这一块补上的，因为前几节课还是有很多需要记住的点的。但是犹豫再三，我还是放弃了，因为还是那句话，这意味着我要补上前面的很多内容，会带来很多重复的工作量让我心生退却。不过我也给自己立了一个 Flag ，如果我下一次用到相关知识，或者说复习的时候忘记了，我就把它加上，这样它对我来说就是一个更加有意义的工作量了，我会更容易接受。&lt;/s&gt;&lt;/p&gt;&#xA;&lt;p&gt;课程内容来源：&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://www.bilibili.com/video/BV1X7411F744?spm_id_from=333.788.videopod.episodes&amp;vd_source=1837baf7c46a027b7e27b4ab7174fb85&#34; target=&#34;_blank&#34;&gt;GAMES101-现代计算机图形学入门-闫令琪&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;antialiasing&#34;&gt;Antialiasing&lt;/h2&gt;&#xA;&lt;img src = &#34;jaggie.png&#34; alt = &#34;锯齿&#34; /&gt;&#xD;&#xA;&lt;p&gt;锯齿是一种图片走样的结果，比如图中本来是一个三角形，但经过测试像素中心点在三角形内部还是外部并且将在内部的像素填上颜色的方式呈现在屏幕上时，就发生了锯齿的现象。所以我们要采用反走样技术来解决这种现象。&lt;/p&gt;&#xA;&lt;p&gt;在这之前我们先看看在计算机图形学中的采样。&lt;/p&gt;&#xA;&lt;p&gt;Rasterization = Sample 2D Positions，栅格化也就是采样2D平面内的位置&lt;/p&gt;&#xA;&lt;img src = &#34;rasterization.png&#34; alt = &#34;栅格化&#34; /&gt;&#xD;&#xA;&lt;p&gt;Photograph = Sample Image Sensor Plane，照片也就是采样图像传感器平面&lt;/p&gt;&#xA;&lt;img src = &#34;photograph.png&#34; alt = &#34;照片采样&#34; /&gt;&#xD;&#xA;&lt;p&gt;Video = Sample Time，视频也就是对时间采样，每隔一定时间采样一次&lt;/p&gt;&#xA;&lt;img src = &#34;video.png&#34; alt = &#34;视频采样&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;sampling-artifactserrors--mistakes--inaccuraciesin-computer-graphics&#34;&gt;Sampling Artifacts（Errors / Mistakes / Inaccuracies）in Computer Graphics&lt;/h3&gt;&#xA;&lt;p&gt;计算机图形学中由采样带来的“瑕疵”有很多，包括锯齿、摩尔纹、车轮效应。&lt;/p&gt;&#xA;&lt;p&gt;Jaggies（Staircase Pattern）：锯齿，也被称作楼梯模式&lt;/p&gt;&#xA;&lt;img src = &#34;jaggies.png&#34; alt = &#34;锯齿&#34; /&gt;&#xD;&#xA;&lt;p&gt;Moiré Patterns in Imaging：摩尔纹&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A4</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a4/</link>
      <pubDate>Wed, 13 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a4/</guid>
      <description>&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa4.html&#34; target=&#34;_blank&#34;&gt;作业 4：类层次结构分析与过程间常量传播&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业目标&#34;&gt;作业目标&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为 Java 实现一个类层次结构分析（Class Hierarchy Analysis，CHA）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;实现过程间常量传播。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;实现过程间数据流传播的 worklist 求解器。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;&#xA;&lt;h3 id=&#34;完成-chabuilder-类&#34;&gt;完成 CHABuilder 类&lt;/h3&gt;&#xA;&lt;h4 id=&#34;jmethod-dispatchjclasssubsignature&#34;&gt;JMethod dispatch(JClass,Subsignature)&lt;/h4&gt;&#xA;&lt;p&gt;该方法实现了如下图所示的 Dispatch 方法。特别地，如果找不到满足要求的方法，返回 null。&lt;/p&gt;&#xA;&lt;img src = &#34;dispatch.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里要了解三个类， JMethod 、 JClass 、 Subsignature 。其中， &lt;strong&gt;JMethod&lt;/strong&gt; 表示 Tai-e 中的 Java 方法，每个 JMethod 的实例关联着一个方法并包含该方法的各种信息。&lt;strong&gt;boolean isAbstract()&lt;/strong&gt;: 如果该 JMethod 是一个没有方法体的抽象方法，则返回 true ，否则返回 false； &lt;strong&gt;JClass&lt;/strong&gt; 表示 Tai-e 中的 Java 类，每个 JClass 的实例关联着一个类并包含该类的各种信息。&lt;strong&gt;JClass getSuperClass()&lt;/strong&gt;: 返回该类的父类。如果这个类在类层次结构的顶端（没有父类），比如 java.lang.Object，则返回 null。&lt;strong&gt;JMethod getDeclaredMethod(Subsignature)&lt;/strong&gt;: 根据子签名返回该类中声明的对应方法。如果该类中没有该子签名对应的方法，则返回 null。&lt;strong&gt;boolean isInterface()&lt;/strong&gt;: 返回该类是否是一个接口； &lt;strong&gt;Subsignature&lt;/strong&gt; 表示 Tai-e 中的子签名，一个方法的子签名只包含它的方法名和方法签名的描述符，举个例子，下面方法 foo 的子签名是：“T foo(P,Q,R)” ，而它的完整签名是：“&amp;lt;C: T foo(P,Q,R)&amp;gt;”。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨09指针分析基础I</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A809%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80i/</link>
      <pubDate>Tue, 12 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A809%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80i/</guid>
      <description>&lt;h2 id=&#34;pointer-analysis-rules&#34;&gt;Pointer Analysis: Rules&lt;/h2&gt;&#xA;&lt;h3 id=&#34;domains-and-notations域和符号&#34;&gt;Domains and Notations（域和符号）&lt;/h3&gt;&#xA;&lt;table border=&#34;0&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Variables:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;x, y ∈ V&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Fields:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;f, g ∈ F&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Objects:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;o&lt;sub&gt;i&lt;/sub&gt;, o&lt;sub&gt;j&lt;/sub&gt; ∈ O&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Instance fields:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;o&lt;sub&gt;i&lt;/sub&gt;.f, o&lt;sub&gt;j&lt;/sub&gt;.g ∈ O × F&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Pointers:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Pointer = V ⋃ (O × F)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Points-to relations:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;pt : Pointer → 𝒫𝒫(O)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;P(O) denotes the powerset of O（P(O)表示 O 的幂集）&lt;/li&gt;&#xA;&lt;li&gt;pt(p) denotes the points-to set of （pt(p) 表示 p 的指向的集合）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;how-to-implement-pointer-analysis&#34;&gt;How to Implement Pointer Analysis&lt;/h2&gt;&#xA;&lt;table border=&#34;0&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;thead&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;th&gt;Kind&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Statement&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Rule&lt;/th&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/thead&gt;&#xD;&#xA;  &lt;tbody align=&#34;center&#34;&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;New&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;i: x = new T()&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;1.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Assign&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;x = y&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;2.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Store&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;x.f = y&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;3.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Load&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;y = x.f&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;4.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;规则中上面为条件，下面为结论。&#xD;&#xA;&lt;p&gt;本质上，指针分析是在指针（变量和字段）之间传播指向信息。我们使用一个 graph 来连接相关指针，当 pt(x) 发生变化时，传播更改的部分到 x 的后继。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨08指针分析</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A808%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 11 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A808%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;CHA存在一些问题,会导致不精确的常量分析，如下图所示：&lt;/p&gt;&#xA;&lt;img src = &#34;problem.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;由于CHA只考虑类名，不考虑上下文，所以会追踪到三个目标方法，导致&lt;code&gt;x = NAC&lt;/code&gt;，但实际上调用的只是其中一个，这是不精确的，结果应该是&lt;code&gt;x = 1&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction-to-pointer-analysis&#34;&gt;Introduction to Pointer Analysis&lt;/h2&gt;&#xA;&lt;p&gt;指针分析是一个基础性的静态分析，计算指针可以指向的内存位置。对于面向对象（侧重于Java）的程序。计算指针（变量或字段）可以指向的对象。指针分析被看作may-analysis，会过度计算指针可以指向的对象集合，即“指针可能指向哪些对象？”。&lt;/p&gt;&#xA;&lt;img src = &#34;example.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;如上图例子所示，指针分析就是将一个输入的程序，输出为指针和对象之间的指向关系。&lt;/p&gt;&#xA;&lt;p&gt;Pointer Analysis and Alias Analysis是两个密切但不相关的概念&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;指针分析：指针可以指向哪些对象？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;别名分析：两个指针可以指向同一个对象吗？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果两个指针（比如 p 和 q）引用同一个对象，那么 p 和 q 之间就是别名的关系。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p = new C();&#xD;&#xA;q = p;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;别名的信息是可以根据指针分析推导出来的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;applications-of-pointer-analysis&#34;&gt;Applications of Pointer Analysis&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Fundamental information&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Call graph, aliases, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Compiler optimization&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Virtual call inlining, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Bug detection&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Null pointer detection, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Security analysis&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Information flow analysis, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;key-factors-of-pointer-analysis&#34;&gt;Key Factors of Pointer Analysis&lt;/h2&gt;&#xA;&lt;p&gt;指针分析是一个复杂的系统，影响系统精度和效率的因素很多&lt;/p&gt;</description>
    </item>
    <item>
      <title>2024腾讯游戏客户端公开课笔试</title>
      <link>https://nju-wrd.github.io/posts/2024%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AF%95/</link>
      <pubDate>Sun, 10 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/2024%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AF%95/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;因为周六要打工没空，所以选择参加了11.10号的场次，在参加之前我除了知道这两场题目会不同之外，我还发现11.9对于编程语言限制的描述是&lt;div style=&#34;border-left:4px solid green;padding-left:10px;&#34;&gt;&lt;font color=#686868&gt;1道题目可使用：[C, C#, C++, Java, Python, Python 3] 1道题目可使用：[C++] 1道题目可使用：[C, C#, C++, Go, Groovy, Java, Javascript, Kotlin, Matlab, Object C, Pascal, Php, Pypy2, Pypy3, Python, Python 3, R, Ruby, Rust, Scala, Swift, Typescript]&lt;/font&gt;&lt;/div&gt;而11.10的表述是&lt;div style=&#34;border-left:4px solid green;padding-left:10px;&#34;&gt;&lt;font color=#686868&gt;2道题目可使用：[C, C++] 1道题目可使用：[C#, C++] 在线作答编程&lt;/font&gt;&lt;/div&gt;不知道会不会差别很大，大致回忆一下题目的内容，记不清的内容我会用自己理解的东西代替描述。&lt;/p&gt;&#xA;&lt;h2 id=&#34;q1&#34;&gt;Q1&lt;/h2&gt;&#xA;&lt;p&gt;第一道题是定义了一个完美平方数组，他会给你字符串的长度，以及相对应的由01组成的字符串，如果他能形成一个m * n的矩阵，满足外部都是1，中间都是0，就是完美数组，且当m == n的时候，是完美平方数组。输入的格式先是字符串的个数，然后接受每个字符串的长度和内容，满足完美平方数组的打印Yes，否则打印No。&lt;/p&gt;&#xA;&lt;h2 id=&#34;q2&#34;&gt;Q2&lt;/h2&gt;&#xA;&lt;p&gt;第二道题是会给出一个表达式，然后你要做的是解析表达式，解析成功的打印表达式的最终值，解析失败则打印XXX。要求解析的只有+-*/，且输入可能会有空格。&lt;/p&gt;&#xA;&lt;h2 id=&#34;q3&#34;&gt;Q3&lt;/h2&gt;&#xA;&lt;p&gt;第三道题是给定一个包含非负整数的 &lt;code&gt;m x n&lt;/code&gt; 矩阵 ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。且元素为0时，表示不可以通过。说明：每次只能向下或者向右移动一步。&lt;/p&gt;&#xA;&lt;h2 id=&#34;我的思路&#34;&gt;我的思路&lt;/h2&gt;&#xA;&lt;p&gt;第一题的话我是先判断是否满足平方，然后再简单的遍历每一个字符串的元素是否满足0，1的条件。&lt;/p&gt;&#xA;&lt;p&gt;第二题用了两个栈来解析，第一个栈对于数字操作，第二个对于op符操作，当遇到数字进数字栈，遇到符号且符号栈为空时进栈，栈不为空时，根据符号的优先级进行出栈以及计算的判断。不过中间会有一些细节的处理。&lt;/p&gt;&#xA;&lt;p&gt;第三题是很常见的dp题，因为某一点的最短路径只会来自于他的左边和上边，选择短的加上自己则是最短，所以可以划分为子问题。不过这里要对于0做特殊处理，我的处理是将此处的dp值设为int的最大值。随后循环生成打印即可。&lt;/p&gt;&#xA;&lt;p&gt;代码如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;style=&#34;position:relative;&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34; id = &#34;code1&#34;&gt;#include &amp;ltalgorithm&amp;gt&#xD;&#xA;#include &amp;ltiostream&amp;gt&#xD;&#xA;using namespace std;&#xD;&#xA;int main() {&#xD;&#xA;&#x9;int n,m;&#xD;&#xA;&#x9;cin &gt;&gt; m &gt;&gt; n;&#xD;&#xA;&#x9;int arr[100][100];&#xD;&#xA;&#x9;for(int i = 0 ;i &lt; m; i++){&#xD;&#xA;&#x9;for(int j = 0; j &lt; n; j++){&#xD;&#xA;&#x9;&#x9;cin &gt;&gt; arr[i][j];&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    int dp[100][100] = {0};&#xD;&#xA;    dp[0][0] = arr[0][0];&#xD;&#xA;    for(int i = 1 ;i &lt; m; i++){&#xD;&#xA;        if(arr[i][0] == 0){&#xD;&#xA;            while(i &lt; m){&#xD;&#xA;                dp[i][0] = INT32_MAX;&#xD;&#xA;                i++;&#xD;&#xA;            }&#xD;&#xA;        }else{&#xD;&#xA;            dp[i][0] = dp[i - 1][0] + arr[i][0];&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    for(int i = 1 ;i &lt; n; i++){&#xD;&#xA;        if(arr[0][i] == 0){&#xD;&#xA;            while(i &lt; n){&#xD;&#xA;                dp[0][i] = INT32_MAX;&#xD;&#xA;                i++;&#xD;&#xA;            }&#xD;&#xA;        }else {&#xD;&#xA;            dp[0][i] = dp[0][i - 1] + arr[0][i];&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    for(int i = 1 ;i &lt; m; i++){&#xD;&#xA;        for(int j = 1; j &lt; n; j++){&#xD;&#xA;            if(arr[i][j] == 0){&#xD;&#xA;                dp[i][j] = INT32_MAX;&#xD;&#xA;            }else {&#xD;&#xA;                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + arr[i][j];&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    printf(&#34;%d&#34;,dp[m - 1][n - 1]);&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;&lt;button class=&#34;copy-button&#34; data-clipboard-target=&#34;#code1&#34;&gt;Copy&lt;/button&gt;&#xD;&#xA;&lt;/div&gt;&#xD;&#xA;&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;&#xA;&lt;p&gt;只有第三题的代码的原因是，我没有在本地idea存储每一题的答案，所以只剩下最后的，就顺便贴上了。对于这次笔试，我得了60分，最后一题没有AC，可能还是因为我平常不会经常去有目的性的去刷题，所以做题目的速度比较慢，导致最后只差一点点但是来不及写完了。我做题的过程首先就是思路的产生，再到将思路转化为实践，最后是实践中的边界情况讨论。第一题我就写了半个小时，要花费很多时间去找到出错的边界。第二题也是一样的情况，写完第二题只剩半个小时了。而第三题一开始我甚至没看到障碍的情况，导致虽然找到了问题的核心，但距离写出题目浪费了很多时间，最后找到原因之后也已经来不及了，虽然最后还是花了几分钟把它写完了，不过算是有点可惜。&lt;/p&gt;</description>
    </item>
    <item>
      <title>我的博客网站搭建进展丨01</title>
      <link>https://nju-wrd.github.io/posts/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%B1%95%E4%B8%A801/</link>
      <pubDate>Sun, 10 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%B1%95%E4%B8%A801/</guid>
      <description>&lt;h2 id=&#34;2024-11-07&#34;&gt;2024-11-07&lt;/h2&gt;&#xA;&lt;p&gt;在我写了几篇博客之后，通过实际的编写过程和这期间看到的别的内容，我发现用单纯的Markdown语法来写并不能达到我想要的效果。并且我通过对比发现我在Typora里编辑的 html 语法是可以被识别到并正确运行的，不过可能由于我本身博客的框架基础，在web页面并没有被正确加载，所以我决定研究一下我的 post 具体是怎样被加载的。&lt;/p&gt;&#xA;&lt;p&gt;经过研究发现，我的书写内容没有问题，post 的加载也没有问题，在&lt;a href=&#34;https://juejin.cn/post/7119681369831112741&#34;&gt;修复Hugo静态生成器中忽略原始HTML的方法&lt;/a&gt;中我找到了问题的答案，原来是因为渲染的markdown不能理解我在短代码中的HTML。从Hugo V.0.60开始，默认的markdown渲染器是Gold mark。Goldmark渲染引擎默认忽略了原始HTML。所以我必须使用配置参数来告诉它。这个解决方案可以让Markdown渲染器使用Goldmark渲染器，通过配置考虑原始HTML。&lt;/p&gt;&#xA;&lt;p&gt;修复方法是在配置文件中加入&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;style=&#34;position:relative;&#34;&gt;&lt;pre&gt;&lt;code id = &#34;code1&#34;&gt;[markup]&#xD;&#xA;  [markup.goldmark]&#xD;&#xA;    [markup.goldmark.renderer]&#xD;&#xA;      unsafe = true&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;&lt;button class=&#34;copy-button&#34; data-clipboard-target=&#34;#code1&#34;&gt;Copy&lt;/button&gt;&#xD;&#xA;&lt;/div&gt;&#xD;&#xA;&lt;p&gt;这里我正在使用 config.toml 文件，若是 yaml 文件参考文章给出的格式。这时候我之前的 html 语句就被正确加载了。&lt;/p&gt;&#xA;&lt;p&gt;第二个问题是我之前插入了很多图片都没有被正确加载，我觉得可能是因为文件路径的问题。因为上一个问题我是先问的 gpt ，其实 gpt 给出的方案和正确方案是比较类似的，但他没有意识到她提到的 blackfriday 渲染器已经不再使用了，导致我花费很多时间找到真正的原因，所以这一次我也觉得先在搜索引擎中找答案。根据 &lt;a href=&#34;https://blog.csdn.net/qq_38340601/article/details/108900666&#34;&gt;hugo 导入图片的两种方式&lt;/a&gt;我也完成了我的图片导入。但是后续我想到了一些问题，就是我的 content\cn\posts 内文件本身是没有额外文件夹的，但是在 hugo 启动之后生成的 public 文件夹中是针对每个 md 文件有一个文件夹的，其中放了 html 文件，所以我的做法就是将图片放在这个文件夹之下。我想到的是什么呢，就是说这个文件是一个缓存文件，如果我执行了清除缓存的命令，我里面的图片就没了，我测试了一下，果然没了。但是 edge 里面还能看到，我猜测是因为 edge 本身缓存了这个图片，于是我打开 chrome 试了一下果然，这张图片已经看不到了，所以我现在要理解这个过程，将图片放在一个一劳永逸的地方。为什么我不直接放在 content 目录先呢，因为这里面原来都是单独的 md 文件，我担心将 md 文件放入文件夹中会影响 hugo 构建的过程。这次我直接询问 gpt 得到了答案，我可以在 post 文件夹下额外新建一个对应 md 文件的文件夹，然后将相应的图片放入即可，这样 hugo 自然会将图片放入 public 对应的文件夹和 html 文件在一起。在这之前，~~我找到了回收站中被清除的图片。~~我重新上传了需要的图片。&lt;/p&gt;</description>
    </item>
    <item>
      <title>网络安全与检测技术作业丨01</title>
      <link>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E4%BD%9C%E4%B8%9A%E4%B8%A801/</link>
      <pubDate>Sat, 09 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E4%BD%9C%E4%B8%9A%E4%B8%A801/</guid>
      <description>&lt;h2 id=&#34;题目&#34;&gt;题目&lt;/h2&gt;&#xA;&lt;p&gt;作业的内容是&lt;a style=&#34;color: #0000FF;&#34; href=&#34;网络安全与检测技术作业 1.pdf&#34; target=&#34;_blank&#34;&gt;网络安全与检测技术 作业 1&lt;/a&gt;，其中第八题的内容是：&lt;/p&gt;&#xA;&lt;img src=&#34;8.png&#34; /&gt;&#xD;&#xA;&lt;h2 id=&#34;我的答案&#34;&gt;我的答案&lt;/h2&gt;&#xA;&lt;p&gt;1.(1)Mi=Dk(Ci⊕Ci−1)⊕Ci-1&lt;/p&gt;&#xA;&lt;p&gt;(2)在AES-CBS-STAR模式中，每个密文分组Ci依赖于前一个密文分组Ci−1，即加密过程是串行的，无法进行并行化。&lt;/p&gt;&#xA;&lt;p&gt;解密过程中Mi的计算也依赖于前一个密文分组Ci−1，因此，解密过程也是串行的。&lt;/p&gt;&#xA;&lt;p&gt;所以AES-CBS-STAR模式既不能并行加密，也不能并行解密。&lt;/p&gt;&#xA;&lt;p&gt;(3)由于C0=IV0是已知的，对手能够根据选择的明文和已知的IV，推测出初始密文分组C1或其他分组。然后攻击者可以分析密文序列中的变化趋势，利用IV的已知值推断出明文。&lt;/p&gt;&#xA;&lt;p&gt;2.(1)在ECB模式中，每个分组的加密是独立的，只会影响第8个明文分组的第17比特。&lt;/p&gt;&#xA;&lt;p&gt;(2)CTR模式的密文模块之间是独立的，因此一个密文模块的污染只会影响相应的明文模块。第2和第3个明文分组都将被污染。&lt;/p&gt;&#xA;&lt;p&gt;(3)OFB模式中,密文生成是通过明文与一个伪随机序列进行异或来完成的,密文模块之间是独立的，只会影响第7个明文分组。&lt;/p&gt;&#xA;&lt;p&gt;(4)CBC模式中，每个明文分组与前一个密文分组进行异或操作,会影响当前分组的解密结果和下一个分组的解密结果。会影响第9个明文分组的第16和第17比特，以及第10个明文分组的第16和第17比特。&lt;/p&gt;&#xA;&lt;p&gt;(5)CFB模式中，密文是通过明文与来自加密器输出的前几个比特进行异或来生成的。会影响第12个明文分组的第3到第6比特，以及以后所有明文分组的所有比特。&lt;/p&gt;&#xA;&lt;p&gt;3.这种方法与RSA不等价在RSA中，e（相当于这里的E）的选择是有一定条件的，通常要求e与(P-1)(Q-1)互质，这样才能保证解密的唯一性和正确性。而这里不满足RSA中的选择条件，解密指数D未必存在，或者可能存在多个解，无法保证解密过程的正确性。所以该方法不是RSA算法。&lt;/p&gt;&#xA;&lt;p&gt;4.假设我们希望找到一对新的分组C1和C2，使得：&lt;/p&gt;&#xA;&lt;p&gt;RSAH(C1,C2)=RSAH(B1,B2)即&lt;/p&gt;&#xA;&lt;p&gt;RSA(E(C1)⊕C2)=RSA(E(B1)⊕B2)&lt;/p&gt;&#xA;&lt;p&gt;由于RSA是一个可逆操作，给定密文，我们可以通过逆向操作（即RSA解密）得到对应的明文。因此，如果我们有密文E(B1)⊕B2，我们可以通过适当选择C1和C2来调整这个结果，使其匹配。&lt;/p&gt;&#xA;&lt;p&gt;我们可以选择：&lt;/p&gt;&#xA;&lt;p&gt;C2=B2⊕(E(C1)⊕E(B1))这样，RSA(C1,C2)就会与RSA(B1,B2)相同。因此，该Hash函数是不安全的，它不满足抗弱碰撞性。&lt;/p&gt;&#xA;&lt;p&gt;5.攻击者可以利用逐字节比较的特性，通过逐字节猜测sig_bytes的正确值。在每次对比时，比较操作会在不匹配的字节处提前结束。可以通过监控每次比较的时间差来判断哪些字节匹配。通常，匹配的字节会导致较长的比较时间（因为继续进行字节比较），而不匹配的字节会导致较短的比较时间。利用这个反馈信息，攻击者就可以逐步恢复正确的签名。&lt;/p&gt;&#xA;&lt;p&gt;我们可以使用常数时间比较：&lt;/p&gt;&#xA;&lt;p&gt;importhmac&lt;/p&gt;&#xA;&lt;p&gt;defverify(key,msg,sig_bytes):&lt;/p&gt;&#xA;&lt;p&gt;returnhmac.compare_digest(HMAC(key,msg),sig_bytes)&lt;/p&gt;&#xA;&lt;p&gt;6.(1)Bob能解密密文c并获得明文m的条件是密文c中包含了可以通过对称加密解密或通过私钥解签名获得的明文。&lt;/p&gt;&#xA;&lt;p&gt;(a)这种方式使用了哈希函数对密文Enc(K,m)进行哈希计算。哈希函数是单向的，Bob无法获得明文m，&lt;/p&gt;&#xA;&lt;p&gt;(b)中，c1是通过对称加密得到的密文，Bob使用对称密钥K可以解密c1得到m。c2只是Enc(K,m)的哈希，Bob不需要它来获取明文m。(c)中c1是加密后的密文，Bob可以使用K解密得到m，c2是对m的MAC（消息认证码），它主要用于验证消息的完整性。&lt;/p&gt;&#xA;&lt;p&gt;(d)中c1是加密的密文，Bob可以解密它得到m。c2是对加密后密文的MAC，用于完整性验证。&lt;/p&gt;&#xA;&lt;p&gt;(e)这里，c是Alice使用私钥SKA对加密消息Enc(K,m)的签名。Bob可以使用Alice的公钥PKA来验证签名，然后Bob可以根据对称密钥K解密Enc(K,m)。&lt;/p&gt;&#xA;&lt;p&gt;(f)中c1是加密后的明文m，Bob使用K解密得到m。c2是对明文m的签名（加密过），Bob可以解密c2并验证签名，但这不会影响c1中的解密过程。&lt;/p&gt;&#xA;&lt;p&gt;Bob能解密c获得明文m的方式是(b)、(c)、(d)、(e)、(f)。&lt;/p&gt;&#xA;&lt;p&gt;(2) (a)是通过哈希函数对密文进行处理，而哈希函数本身是单向的，不涉及加密，所以不能提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(b)是对称加密的密文，提供了机密性保护，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(c)是对称加密的密文，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(d)是对称加密的密文，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(e)是加密的密文，提供了机密性保护，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(f)是对称加密的密文，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;可以提供机密性保护的方式是(b)、(c)、(d)、(e)、(f)。&lt;/p&gt;&#xA;&lt;p&gt;(3) (a)只能提供单向验证，但不能验证消息是否在传输中被篡改，不能提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(b)中c2是Enc(K,m)的哈希值，可以用于验证密文是否被篡改，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(c)中c2是对消息m的MAC，可以验证消息的完整性，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(d)中c2是对密文Enc(K,m)的MAC，可以验证密文是否被篡改，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(e)Sign(SKA,Enc(K,m))是对密文的签名，可以验证密文是否被篡改，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(f)中c2是对明文m的签名的加密，可以用于验证消息的完整性，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;可以提供完整性保护的方式是(b)、(c)、(d)、(e)、(f)。&lt;/p&gt;&#xA;&lt;p&gt;(4)选择方式(c)：c=c1,c2:c1=Enc(K,m),c2=MAC(K,m)，它同时提供了机密性和完整性保护。为了防止重放攻击，我们可以在消息中添加时间戳或唯一的随机数nonce。&lt;/p&gt;&#xA;&lt;p&gt;7.(1)一种可能的攻击角度是伪造人脸图像进行攻击，即通过技术手段制造或操控一个与目标人物极为相似的面部图像或视频，从而欺骗门禁系统，绕过人脸识别机制进入系统。具体攻击方法可能包括以下几种：&lt;/p&gt;&#xA;&lt;p&gt;照片攻击：使用目标用户的照片，将其展示给门禁系统的摄像头来欺骗系统。&lt;/p&gt;&#xA;&lt;p&gt;视频攻击：通过录制目标用户的正常活动（例如走路、说话等），再通过播放视频来进行攻击，模拟目标的面部动态。&lt;/p&gt;&#xA;&lt;p&gt;3D模型攻击：通过3D打印技术制造出目标人物的面部模型，并将其放置在摄像头前，试图欺骗识别系统。&lt;/p&gt;&#xA;&lt;p&gt;深度学习攻击：利用深度学习技术生成目标人物的虚假面部图像或视频，进行欺骗。&lt;/p&gt;&#xA;&lt;p&gt;威胁模型：&lt;/p&gt;&#xA;&lt;p&gt;资产：门禁后的区域安全、生物识别数据、门禁系统完整性。&lt;/p&gt;&#xA;&lt;p&gt;对手：外部无通行权限的攻击者，获取门禁后的被保护的东西&lt;/p&gt;&#xA;&lt;p&gt;漏洞：识别技术不精确、缺乏活体检测、数据传输不加密。&lt;/p&gt;&#xA;&lt;p&gt;威胁：伪造身份、深度伪造、数据截获。&lt;/p&gt;&#xA;&lt;p&gt;风险：高价值区域和用户数据泄露，漏洞可能性较大。&lt;/p&gt;&#xA;&lt;p&gt;防御：活体检测、多因素认证、加密传输。&lt;/p&gt;&#xA;&lt;p&gt;(2)安全性质：&lt;/p&gt;&#xA;&lt;p&gt;KnowYourThreatModel：&#xA;确定潜在威胁和攻击者，包括外部黑客、内部员工、以及中间人。了解攻击者的动机、能力和目标。&lt;/p&gt;&#xA;&lt;p&gt;SecurityisEconomics：&#xA;评估安全防护的成本和攻击的潜在损失，确保在合理的成本范围内实现最佳安全效果。&lt;/p&gt;</description>
    </item>
    <item>
      <title>网络安全与检测技术学习笔记丨01</title>
      <link>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A801/</link>
      <pubDate>Sat, 09 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A801/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;这次学习是因为该课程布置了第一次作业，所以需要补充学习一下遗漏的内容。由于这门课是本研共修课程，在开学第一周本科生们就已经选好课并且开始上课了，但是我们新入学的研究生从第三周才能选好课并开始上课。这导致我最终其实第四周左右才选上这门课，所以遗漏了前面的很多内容，上课时感到很不连贯也就没有细听了，最终决定采用根据PPT自学的形式来完成这次布置的第一次作业。&lt;/p&gt;&#xA;&lt;h2 id=&#34;lec01-intro&#34;&gt;Lec01 Intro&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Ethics&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通常可以闯入自己的系统&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这是评估自己系统的好办法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;在获得他人明确许可的情况下，通常可以闯入他人的系统&lt;/li&gt;&#xA;&lt;li&gt;未经许可闯入他人的系统是不道德且犯罪的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;系统失效的原因：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Reliability：意外故障&lt;/li&gt;&#xA;&lt;li&gt;Usability：因用户操作错误而引起的问题&lt;/li&gt;&#xA;&lt;li&gt;Design and goal oversights：设计过程中的疏忽、错误和遗漏&lt;/li&gt;&#xA;&lt;li&gt;Security：他人故意造成的故障&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Security VS. Correctness：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;System correctness：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;系统满足规范&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于合理输入，获得合理输出&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;System security：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在面对攻击时保留系统属性&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于不合理的的输入，输出不完全错误&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;主要区别：主动干扰&lt;/p&gt;&#xA;&lt;p&gt;Course Overview&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如何考虑安全和隐私&#xA;&lt;ul&gt;&#xA;&lt;li&gt;“Security Mind” ——一种思考系统的全新方式&lt;/li&gt;&#xA;&lt;li&gt;Security Principles&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;安全和隐私的&lt;strong&gt;技术&lt;/strong&gt;方面&#xA;&lt;ul&gt;&#xA;&lt;li&gt;漏洞和攻击技术&lt;/li&gt;&#xA;&lt;li&gt;防御技术&lt;/li&gt;&#xA;&lt;li&gt;如何构建具有强大安全属性的计算机系统&lt;/li&gt;&#xA;&lt;li&gt;如何衡量当今技术提供的保护和限制&lt;/li&gt;&#xA;&lt;li&gt;攻击在实践中的工作原理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;主题包括&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本密码学&lt;/li&gt;&#xA;&lt;li&gt;认证&lt;/li&gt;&#xA;&lt;li&gt;密钥管理&lt;/li&gt;&#xA;&lt;li&gt;可用安全性（人工身份验证）&lt;/li&gt;&#xA;&lt;li&gt;网络安全&lt;/li&gt;&#xA;&lt;li&gt;数据安全和隐私&#xA;&lt;ul&gt;&#xA;&lt;li&gt;匿名和差分隐私&lt;/li&gt;&#xA;&lt;li&gt;联邦学习&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Emerging Technologies 的安全&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ML的安全性&lt;/li&gt;&#xA;&lt;li&gt;自动驾驶汽车的安全性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;lec02-secbasics&#34;&gt;Lec02 SecBasics&lt;/h2&gt;&#xA;&lt;h3 id=&#34;objects&#34;&gt;Objects&lt;/h3&gt;&#xA;&lt;h4 id=&#34;confidentiality保密性&#34;&gt;Confidentiality（保密性）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Confidentiality 是信息的隐瞒&lt;/li&gt;&#xA;&lt;li&gt;Data Confidentiality：确保私人或机密信息不会提供给或披露给未经授权的个人&lt;/li&gt;&#xA;&lt;li&gt;&lt;font color=gray&gt;Privacy：确保个人控制或影响哪些和他们有关的信息被收集，以及这些信息会被谁以及向谁披露&lt;/font&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;integrity完整性&#34;&gt;Integrity（完整性）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Integrity 是防止未经授权的更改&lt;/li&gt;&#xA;&lt;li&gt;Data Integrity：确保数据和信息仅以指定和授权的方式进行更改&lt;/li&gt;&#xA;&lt;li&gt;System Integrity：确保系统以不受损害的方式执行预期功能，不受故意或无意的未经授权的操作对系统执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;availability可用性&#34;&gt;Availability（可用性）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Availability 是使用信息或资源的能力&lt;/li&gt;&#xA;&lt;li&gt;确保系统迅速工作，并且不会拒绝向授权用户提供服务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;thread-modeling&#34;&gt;Thread Modeling&lt;/h3&gt;&#xA;&lt;p&gt;Assets：我们要保护什么？这个资产有多少价值？&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨07过程间分析</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A807%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A807%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;因为上周三忙着做团支书的工作以及各种其他事情，课上没有仔细的听，所以之后再花时间重新看b站的视频课程。顺便就此机会准备后面的课都通过视频的形式来学习了。这门课还是在观看视频的时候反复理解和思考才是更高效的，即使我之前会线下去上课，回来之后还是有一些地方要自己好好研究的。所以后续以这种形式既不会错过知识内容，也可以增加我的效率。&lt;/p&gt;&#xA;&lt;p&gt;从这节课开始就是从谭添老师开始上了，前面听说从这一部分开始会有一些动态的分析，而且难度也会开始变得更高。针对过程间分析我们要了解的主要有 Call Graph Construction（ CHA ）、Interprocedural Control-Flow Graph 和 Interprocedural Data-Flow Analysis。&lt;/p&gt;&#xA;&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;过程内分析过于保守，假设调用后都不是常量，丢失了精度。所以我们需要过程间分析，首先就需要调用图，来得到调用边（Call edges）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;call-graph-construction-cha-&#34;&gt;Call Graph Construction（ CHA ）&lt;/h2&gt;&#xA;&lt;p&gt;一个调用图是一个从 call-sites 到目标方法的调用边的集合。&lt;/p&gt;&#xA;&lt;img src=&#34;call-graph.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;本课程主要对 OOPLs 构建调用图(focus on Java)，这节课会学习Class hierarchy analysis（ CHA ），下节课会学习Pointer analysis（k-CFA）。&lt;/p&gt;&#xA;&lt;img src=&#34;1.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;越往上速度越快，越往下精度越高。&lt;/p&gt;&#xA;&lt;p&gt;了解JAVA中的call：&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;thead&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;th&gt;&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Static call&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Special call&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Virtual call&lt;/th&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/thead&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Instruction&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokestatic&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokespecial&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokeinterface&lt;br&gt;invokevirtual&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Receiver objects&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;×无实例&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;√有实例&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;√有实例&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Target methods&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Static methods (静态方法)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Constructors (构造函数)&lt;br&gt;&lt;strong&gt;·&lt;/strong&gt;Private instance methods (类自己的私有方法)&lt;br&gt;&lt;strong&gt;·&lt;/strong&gt;Superclass instance methods (父类的实例方法)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Other instance methods (其他实例方法)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;# Target methods 个数&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;1&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;1&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;≥1 (polymorphism) 多态&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Determinacy 确定时机&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Compile-time (编译时)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Compile-time (编译时)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Run-time (运行时)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;p&gt;构造调用图的关键在于处理virtual call，其中关键的一个步骤叫做Method Dispatch，基于：&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A3</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a3/</link>
      <pubDate>Wed, 06 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a3/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;因为开始写博客的时间已经完成了前两次的实验，所以也不打算重新补写前两次的实验笔记了。如果增加这个工作量我肯定会对写博客产生抵触心理，因为我补充了这个那我后续在其他方面不能不补充厚此薄彼吧，这样一下子积压了大量需要补充的内容压力过大会导致我直接化身怯战蜥蜴——放弃。&lt;/p&gt;&#xA;&lt;p&gt;作业3：死代码检测，并不是我们上课学习的内容，但是通过组合我前两次作业中实现的分析方法：&lt;strong&gt;活跃变量分析&lt;/strong&gt;和&lt;strong&gt;常量传播&lt;/strong&gt;，可以实现一个Java的死代码检测算法。&lt;/p&gt;&#xA;&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa3.html&#34; target=&#34;_blank&#34;&gt;作业 3：死代码检测 | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;死代码检测介绍&#34;&gt;死代码检测介绍&lt;/h2&gt;&#xA;&lt;p&gt;死代码指的是程序中不可达的（unreachable）代码（即不会被执行的代码），或者是执行结果永远不会被其他计算过程用到的代码。去除死代码可以在不影响程序输出的前提下简化程序、提高效率。我们在这次实验中考虑两种死代码：&lt;strong&gt;不可达代码&lt;/strong&gt;（unreachable code）和&lt;strong&gt;无用赋值&lt;/strong&gt;（unreachable code）。这好像正好分别对应了常量传播和活跃变量分析。&lt;/p&gt;&#xA;&lt;h3 id=&#34;不可达代码&#34;&gt;不可达代码&lt;/h3&gt;&#xA;&lt;p&gt;一个程序中永远不可能被执行的代码被称为不可达代码。我们考虑两种不可达代码：&lt;strong&gt;控制流不可达代码&lt;/strong&gt;（control-flow unreachable code）和&lt;strong&gt;分支不可达代码&lt;/strong&gt;（unreachable branch）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;控制流不可达代码&lt;/strong&gt;：在一个方法中，如果不存在从程序入口到达某一段代码的控制流路径，那么这一段代码就是控制流不可达的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：利用所在方法的控制流图（CFG，即 control-flow graph）检测出来。我们只需要从方法入口开始，遍历 CFG 并标记可达语句。当遍历结束时，那些没有被标记的语句就是&lt;strong&gt;控制流不可达&lt;/strong&gt;的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;分支不可达代码&lt;/strong&gt;：在 Java 中有两种分支语句：if 语句和 switch 语句。它们可能会导致分支不可达代码的出现。&lt;/p&gt;&#xA;&lt;p&gt;对于一个 if 语句，如果它的条件值（通过常量传播得知）是一个常数，那么无论程序怎么执行，它两个分支中的其中一个分支都不会被走到。这样的分支被称为&lt;strong&gt;不可达分支&lt;/strong&gt;。该分支下的代码也因此是不可达的，被称为分支不可达代码。&lt;/p&gt;&#xA;&lt;p&gt;对于一个 switch 语句，如果它的条件值是一个常数，那么不符合条件值的 case 分支就&lt;strong&gt;可能&lt;/strong&gt;是不可达的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：为了检测分支不可达代码，我们需要预先对被检测代码应用常量传播分析，通过它来告诉我们条件值是否为常量，然后在遍历 CFG 时，我们不进入相应的不可达分支。&lt;/p&gt;&#xA;&lt;h3 id=&#34;无用赋值&#34;&gt;无用赋值&lt;/h3&gt;&#xA;&lt;p&gt;一个局部变量在一条语句中被赋值，但再也没有被该语句后面的语句读取，这样的变量和语句分别被称为无用变量（dead variable，与活跃变量 live variable 相对）和无用赋值。无用赋值不会影响程序的输出，因而可以被去除。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：为了检测无用赋值，我们需要预先对被检测代码施用活跃变量分析。对于一个赋值语句，如果它等号左侧的变量（LHS 变量）是一个无用变量（换句话说，not live），那么我们可以把它标记为一个无用赋值。&lt;/p&gt;&#xA;&lt;p&gt;但需要注意的是，以上讨论有一种例外情况：有时即使等号左边的变量 &lt;code&gt;x&lt;/code&gt; 是无用变量，它所属的赋值语句 &lt;code&gt;x = expr&lt;/code&gt; 也不能被去除，因为右边的表达式 &lt;code&gt;expr&lt;/code&gt; 可能带有某些副作用。例如，当 &lt;code&gt;expr&lt;/code&gt; 是一个方法调用（&lt;code&gt;x = m()&lt;/code&gt;）时，它就有可能带有副作用，可能在m()中改变了某些值。对于这种情况，作业提供了一个 API 供检查等号右边的表达式是否可能带有副作用。如果带有副作用，那么为了保证 safety，即使 &lt;code&gt;x&lt;/code&gt; 不是一个活跃变量，也不应该把这个赋值语句标记为死代码。&lt;/p&gt;</description>
    </item>
    <item>
      <title>去除冗余的Java依赖</title>
      <link>https://nju-wrd.github.io/posts/%E5%8E%BB%E9%99%A4%E5%86%97%E4%BD%99%E7%9A%84java%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Mon, 04 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%8E%BB%E9%99%A4%E5%86%97%E4%BD%99%E7%9A%84java%E4%BE%9D%E8%B5%96/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;这是本周三我要分享的论文，在这里浅谈一下我对于&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://ieeexplore.ieee.org/abstract/document/10549332&#34; target=&#34;_blank&#34;&gt;Efficiently Trimming the Fat: Streamlining Software Dependencies with Java Reflection and Dependency Analysis&lt;/a&gt;的理解。&lt;/p&gt;&#xA;&lt;h2 id=&#34;contributions&#34;&gt;Contributions&lt;/h2&gt;&#xA;&lt;div style=&#34;border-left:4px solid green;padding-left:10px;&#34;&gt;&lt;font color=#686868&gt;&#xD;&#xA;An effective debloating tool called Slimming &lt;br&gt;&lt;br&gt;&#xD;&#xA;Comprehensive datasets. (1) a high-quality benchmark including 3,520 reflective calls captured by dynamic techniques from a collection of framework-based Java projects for evaluating the effectiveness of reflection analysis techniques; (2) a dataset of 40 projects with 100% test coverage for Java byte code instructions for evaluating the reliability of debloating solutions.”&lt;/font&gt;&lt;/div&gt;&#xD;&#xA;这篇文章的贡献包括提供了有效的去臃肿工具，以及一个全面的数据集，分别提供用于评估反射分析有效性和可靠性。包含3520个从框架型JAVA项目中通过动态技术捕获的反射调用，还包含40个字节码指令测试覆盖率达100%的JAVA项目。&#xD;&#xA;&lt;div style=&#34;border-left:4px solid green;padding-left:10px;&#34;&gt;&lt;font color=#686868&gt;Data Availability. We provided a reproduction package, including the above datasets, an available tool, and experiment raw data, on the [website](https://slimming-fat.github.io/) for facilitating future research.&lt;/font&gt;&lt;/div&gt;&#xD;&#xA;&lt;p&gt;另外还提供了&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://slimming-fat.github.io/&#34; target=&#34;_blank&#34;&gt;在线网站&lt;/a&gt;方便你来复现文章的内容。&lt;/p&gt;</description>
    </item>
    <item>
      <title>我的第一篇博客</title>
      <link>https://nju-wrd.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sat, 02 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</guid>
      <description>&lt;h2 id=&#34;契机与想法&#34;&gt;契机与想法&lt;/h2&gt;&#xA;&lt;p&gt;这是我的第一篇博客，同时也是我参加王道助教工作的第一天，在这个工作的时间搭建了一个简单的博客网站。首先，想要写博客这个想法的契机来源于我在写南京大学软件分析课程作业时，遇到了未通过的样例且思索无果，可以说我是百思不得其解，但是又十分想要AC。这时我在搜索引擎上搜索而看到的一个计算机领域前辈大佬的笔记&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://blog.wohin.me/posts/nju-program-analysis-a2/&#34; target=&#34;_blank&#34;&gt;南大软分实验笔记｜A2&lt;/a&gt;，我为这样形式的内容而感到惊喜，不仅让我解决了当时遇到的困难，还给我一种启发。说实话，这是我第一次在计算机领域接触到这种记录自己的心路历程以及解决问题过程的形式，单纯的记录与分享却让我受益良多，无论是从问题解决还是解决问题的能力上。&lt;/p&gt;&#xA;&lt;p&gt;其实，这种感叹和惊喜从我开始在南大读研之后就常常发生。像是打开了新世纪的大门。在原来，程序员的世界在我看来是一个黑白，理性，充满逻辑的世界。给我的抽象感觉是一个摆放在黑白棋盘格上的天平，纯粹的同时不会给我的生活带来太多的色彩。现在我认识到了许多优秀的老师~~（单方面）~~以及见到了许多优秀的课程让我觉得原来学计算机也这么有意思。&lt;/p&gt;&#xA;&lt;p&gt;在这之后，我想到我还有那么多优秀的课想要去学，有很多感兴趣的事情想要去做，加上平时的作业与科研也可以以这样一种形式来呈现，还想到自己曾经想过的写日记的想法等等。在昨天凌晨一点我再也克制不住这样的想法，于是起来开始准备搭建这样的一个属于我自己的博客网站，一个我在计算机，在程序员世界的小家，同时会存下现实中的美好。&lt;/p&gt;&#xA;&lt;h2 id=&#34;博客搭建进度&#34;&gt;博客搭建进度&lt;/h2&gt;&#xA;&lt;p&gt;因为我对于前端不太熟悉，对于这样一件事情也是很茫然的。所以这个博客的搭建也完全来自于对Bonan前辈（上文的佬）在自己博客上的分享&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://blog.wohin.me/about/&#34; target=&#34;_blank&#34;&gt;About Me&lt;/a&gt;的拙劣模仿，以及结合在b站上的教程&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://www.bilibili.com/video/BV1bovfeaEtQ?spm_id_from=333.788.videopod.episodes&amp;vd_source=1837baf7c46a027b7e27b4ab7174fb85&#34; target=&#34;_blank&#34;&gt;Hugo + Github免费搭建博客&lt;/a&gt;的方式下，完成了一个小demo。由于非常喜欢这种简约的风格，所以没有换其他主题。我目前的想法除了完成这个主题的使用，同时将字体换成&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://github.com/lxgw/LxgwWenKai&#34; target=&#34;_blank&#34;&gt;“霞鹜文楷”&lt;/a&gt;，然后调整一下我的博客的结构，丰富其中的结构设计，以及加入深色模式功能和GitHub自动部署。目前完成了更换字体以及调整结构只留下了一条博客的目录，后续需要设计丰富一下。但是我现在可以先开始着手写一些内容了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;王道助教&#34;&gt;王道助教&lt;/h2&gt;&#xA;&lt;p&gt;因为之前参加过王道的线上培训课程，主要是做一个项目，现在看来是很简单了，但是当时帮助我掌握了很多知识和技巧。提到这个是因为王道当时上课的云龙老师在当时的课程群内发布了一条招聘助教的信息。我一想只需要在线上给同学们答疑就可以拿工资，多是一件美事，于是立马加了云龙老师的微信然后表达了我的意愿。虽然我没参加过这个叫做C语言督学营的课，但是我满足考研上岸211或985学校的同学，也算是拥有了一个面试的资格。想着都是一些简单的数据结构，我也就没有多做准备等待面试即可。就在昨天上午，十点半的时间，刚起床不久，我正吃着我母亲特地从菜市场给我带回来的咸豆腐脑和包子，刚刚把豆腐脑上撒的辣油和花生碎给拌开。也许是因为最近跟我母亲表达了我蛮喜欢吃花生米的意愿，所以上面的花生碎非常多。尝了没几口，收到了云龙老师的信息。就挺突然的，“现在是否方便面试，微信语音电话，预计10到15分钟的时间”，那我自然是积极回复，可以说是秒回了一句“龙哥你好方便的”。然后我便和母亲交代我有点事一会来吃，并叮嘱她一会不要来喊我，然后回房间等待面试。面试很快，9&#39;28，虽然说有些回答的磕磕绊绊，因为我对于一些专业术语反应的有点慢，归根到底我想还是记得不够牢固啊。总之，11:22分我收到了通过面试的消息，或许这是我第一份通过且接受的职位，也是我即将利用本专业知识赚取的第一碗金。是的，这时我就已经开始幻想轻松的答疑工作+拿钱了。我还挺上心的，我去看了基本上一大半的课件，完成了一大半的OJ题目，还挺费时间的，后来觉得不是太大问题，看了一下大纲就没在细细品读了。结果，今天的现实给了我沉重的打击，一是今天是周六，学习的同学比之前多特别多，虽然对于这个一共大约620人7个群的数量来说还算能接受，但也比较多了，二是遇到的问题基本上都是一长串的代码，因为是新手，他们不会根据报错和提示找到问题根源，所以我只能让他们发所有的源代码给我自己测试，还好都是比较基础的数据结构不算难理解，也很少遇到代码写的很奇怪的同学。不过我觉得这也在某种程度上加深我对数据结构的理解，真是教学相长啊。还有一个比较难受的特殊原因是，今天本来是要和我母亲一起去参加她同事儿子的婚礼，在这样的情况下，就让人比较纠结，最终我还是去了，在五点多解决了最后一个存在的问题之后。不过后续是我又早早回来了，因为在外面确实不方便，还好婚礼地点离我家不算远，加上我又有小电驴。这篇博客就是我回来之后开始写的，马上今天的答疑也快结束了。哦！我还写了一份不同时间点的提醒的文案，我要贴在下面留着，最下面是我找到的另外两个劝学的名言但没用上的。&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xA;&lt;colgroup&gt;&#xA;    &lt;col style=&#34;width: 26%&#34;&gt;&#xA;    &lt;col style=&#34;width: 74%&#34;&gt;&#xA;  &lt;/colgroup&gt;&#xA;  &lt;thead&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;th&gt;时间点&lt;/th&gt;&#xA;      &lt;th&gt;提醒文案&lt;/th&gt;&#xA;    &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;早上9点开始&lt;/td&gt;&#xA;      &lt;td&gt;同学们早上好！为学患无疑，以则进也。遇到问题是进步的开始，大家可以在群里@我，我会努力帮助大家解答，如果问题较多可能会回复不及时还请大家多多包涵。如果漏了某些同学的问题还得麻烦再次提醒我一下，期待今天大家的提问。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;中午十二点休息&lt;/td&gt;&#xA;      &lt;td&gt;午休时间到，大家注意休息，保持充沛的精神体力，两点后答疑继续哦。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;下午两点开始&lt;/td&gt;&#xA;      &lt;td&gt;下午的答疑开始了，大家可以继续向我提问啦。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;晚上六点休息&lt;/td&gt;&#xA;      &lt;td&gt;晚饭时间到，休息一会，七点继续哦。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;晚上七点开始&lt;/td&gt;&#xA;      &lt;td&gt;晚上的答疑开始啦，欢迎提问。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;晚上十点结束&lt;/td&gt;&#xA;      &lt;td&gt;今天的答疑时间就结束了哦，如果有遗漏和不清晰的地方可以再次@我！今天的学习也辛苦了，大家注意休息，可以早睡早起明天继续努力。同学们下次见！&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;人生在勤，勤则不匮。&lt;/td&gt;&#xA;      &lt;td&gt;人学始知道，不学非自然。——孟郊《劝学》&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;一会我就要发十点的文案了，幻想今天的答疑工作能收到好评。&lt;/p&gt;&#xA;&lt;h2 id=&#34;第一篇的总结&#34;&gt;第一篇的总结&lt;/h2&gt;&#xA;&lt;p&gt;万事开头难，虽然翻过了一座山，后面还有各种各样的山坡和丘陵，希望我能坚持记录。接下来可能会先写下周要分享的论文和下周二要交的论文报告。之后还可能会有软件分析的A3,A4作业，顺带一提我本来想补一下以前的内容，让这个成一套体系，但我仔细想了想先设立这个工作可能会让我有放弃的想法，所以我放弃了这个想法。之后应该还会有网安的作业，网易雷火比赛作品的开发日志，games101的学习记录等等，给自己画个小饼，希望自己多多加油努力呀！&lt;/p&gt;&#xA;&lt;p&gt;附一张我觉得有趣的图片：&lt;/p&gt;&#xA;&lt;img src=&#34;screen-shoot.jpg&#34; /&gt;&#xA;&lt;p&gt;是我在某时间点之前，将我的文案草稿全部复制粘贴好，到点就发，看着很好笑。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
