<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GAMES101 on 子春廿一</title>
    <link>http://localhost:1313/categories/games101/</link>
    <description>Recent content in GAMES101 on 子春廿一</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Thu, 02 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/games101/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>图形学笔记丨07 Shading 1(illumination, Shading)</title>
      <link>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A807-shading-1illumination-shading/</link>
      <pubDate>Thu, 02 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A807-shading-1illumination-shading/</guid>
      <description>&lt;h2 id=&#34;painters-algorithm画家算法&#34;&gt;Painter&amp;rsquo;s Algorithm（画家算法）&lt;/h2&gt;&#xA;&lt;p&gt;上节课我们学习了如何光栅化一个三角形，但是当画面中有多个三角形的时候，该如何去光栅化所有的图像？一个办法就是像油画家一样，先画远处的内容，再画稍近一点的内容，也就是按照图像本身在画面中的深度由远及近的进行光栅化。&lt;/p&gt;&#xA;&lt;p&gt;很直观的方式就是可以对所有的物体进行深度的排序（O（nlogn）），但是这样存在不可解决的排序顺序，如下图所示：&lt;/p&gt;&#xA;&lt;img src = &#34;unresolvable.png&#34; alt = &#34;不可解决的顺序&#34; /&gt;&#xD;&#xA;&lt;p&gt;他们在深度上存在一个互相遮挡的关系，就无法对他们进行深度的排序，画家算法在这里也就失效了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;z-buffer深度缓存depth-buffer&#34;&gt;Z-Buffer（深度缓存depth buffer）&lt;/h2&gt;&#xA;&lt;p&gt;图形学实际上采用的是Z-Buffer的方法，也就是对于每一个像素去存储离我们最近的深度也就是最浅的深度z-value的信息。&lt;/p&gt;&#xA;&lt;p&gt;对于实际完成，会渲染最终的成品，也就是预期的效果；在生成这个结果的同时，也会生成另外一个图像，这个图像只存看到的几何物体最浅的深度的信息，这个图就叫做depth buffer（z-buffer）。存储最终结果的叫做frame buffer，利用深度缓存的想法来维护遮挡信息。&lt;/p&gt;&#xA;&lt;p&gt;这里重要的一点是，现在我们用z来表示一点到摄像机的距离，且这个z永远是正的，也就是说z的数值越大离我们越远，数值越小离我们越近。这里和前面学习的变换当中的概念不同（变换当中，摄像机在原点朝着-z方向，因此距离越近，数字越大，且z为负的）。&lt;/p&gt;&#xA;&lt;img src = &#34;buffer.png&#34; alt = &#34;生成的渲染图和深度信息图&#34; /&gt;&#xD;&#xA;&lt;p&gt;左侧是渲染的结果，右侧是维护遮挡信息的深度图。可以看到，离我们越远，颜色也就越浅，离我们越近，颜色也就越深。&lt;/p&gt;&#xA;&lt;img src = &#34;algorithm.png&#34; alt = &#34;算法伪代码&#34; /&gt;&#xD;&#xA;&lt;p&gt;上图就是要实现的算法了，首先将深度缓存的所有像素一开始记录的深度初始化为无限大，即表示无限远。然后在每一个三角形进行光栅化的过程中，对于任意一个三角形的任意一个像素，如果现在要画的深度小于深度缓存记录好的深度，就更新深度缓存的值为更小的，并且把这个结果存到要渲染的frame-buffer里面去，否则什么都不做。&lt;/p&gt;&#xA;&lt;p&gt;时间复杂度为O（n），并且不会因为画三角形的顺序不同而产生不同结果（假设在同一像素上不同三角形不会有相同深度的值，因为用浮点型记录深度很难有相同值的存在）。&lt;/p&gt;&#xA;&lt;p&gt;在之前提到的反走样技术MSAA中，考虑到会在一个像素内设置多个采样点，因此在结合这样的技术的时候，对于不同的采样点，也要做相应的深度缓存。&lt;/p&gt;&#xA;&lt;h2 id=&#34;shading着色&#34;&gt;Shading（着色）&lt;/h2&gt;&#xA;&lt;p&gt;对不同物体应用不同的材质。&lt;/p&gt;&#xA;&lt;h3 id=&#34;a-simple-shading-modelblinn-phong-reflectance-model&#34;&gt;A Simple Shading Model（Blinn-Phong Reflectance Model）&lt;/h3&gt;&#xA;&lt;p&gt;在了解这个模型之前，我们可以先了解一下着色要考虑到的三个内容：高光、漫反射和环境光。高光指的是光源照射到一个相对来说较为光滑的平面，光线被反射到镜面反射附近位置产生的高亮，漫反射是指光线找到类似于墙壁这种比较粗糙的面上产生的各个方向的反射；而环境光是指由于各个面上都会发生反射，最终使得即使在光源无法照到的位置也能被看到，此处就是环境光。&lt;/p&gt;&#xA;&lt;p&gt;接下来看一些定义：&lt;/p&gt;&#xA;&lt;img src = &#34;definition.png&#34; alt = &#34;光的反射的数值定义&#34; /&gt;&#xD;&#xA;&lt;p&gt;我们考虑光照首先是在任何一个点上去考虑，也就是在一个shading point上去考虑它的着色结果是什么。那么对于这个point所属的一个物体表面上，我们认为在一个局部的一个非常小的范围内，这个表面永远是一个平面。那么在这个平面上，我们可以定义平面的法线向量n，观测方向为shading point 到观测点的方向，也就是向量v，从point看向光源的方向叫做光源方向，记作向量l。且这三个向量都被记为单位向量，长度为1。其次，对于shading point本身的一些属性，要定义一下和物体表面相关的信息。例如它是什么颜色，它有多么亮等等（color，shininess&amp;hellip;）。&lt;/p&gt;&#xA;&lt;p&gt;补充一点是，我们考虑的shading point是在局部的，也就是不考虑是否在阴影内等和其他物体产生联系的情况。&lt;/p&gt;&#xA;&lt;h4 id=&#34;diffusion&#34;&gt;diffusion&lt;/h4&gt;&#xA;&lt;p&gt;首先考虑漫反射的情况，当光照到物体表面的某一个点时，会被均匀的反射到各个不同的方向上去。&lt;/p&gt;&#xA;&lt;img src = &#34;diffusion.png&#34; alt = &#34;漫反射&#34; /&gt;&#xD;&#xA;&lt;p&gt;并且对于光线的不同入射角度，光的强度也会发生变化。总的来说，一个漫反射的部分单位面积会接收到多少光和光照方向与法线方向形成夹角的余弦值成正比。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨06 Rasterization 2（Antialiasing）</title>
      <link>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A806-rasterization-2antialiasing/</link>
      <pubDate>Thu, 14 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A806-rasterization-2antialiasing/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;在我开始写博客之前我已经学完了前面的五次课，并且完成了作业0和作业1。在我简单回顾之后，我本来是想把这一块补上的，因为前几节课还是有很多需要记住的点的。但是犹豫再三，我还是放弃了，因为还是那句话，这意味着我要补上前面的很多内容，会带来很多重复的工作量让我心生退却。不过我也给自己立了一个 Flag ，如果我下一次用到相关知识，或者说复习的时候忘记了，我就把它加上，这样它对我来说就是一个更加有意义的工作量了，我会更容易接受。&lt;/p&gt;&#xA;&lt;h2 id=&#34;antialiasing&#34;&gt;Antialiasing&lt;/h2&gt;&#xA;&lt;img src = &#34;jaggie.png&#34; alt = &#34;锯齿&#34; /&gt;&#xD;&#xA;&lt;p&gt;锯齿是一种图片走样的结果，比如图中本来是一个三角形，但经过测试像素中心点在三角形内部还是外部并且将在内部的像素填上颜色的方式呈现在屏幕上时，就发生了锯齿的现象。所以我们要采用反走样技术来解决这种现象。&lt;/p&gt;&#xA;&lt;p&gt;在这之前我们先看看在计算机图形学中的采样。&lt;/p&gt;&#xA;&lt;p&gt;Rasterization = Sample 2D Positions，栅格化也就是采样2D平面内的位置&lt;/p&gt;&#xA;&lt;img src = &#34;rasterization.png&#34; alt = &#34;栅格化&#34; /&gt;&#xD;&#xA;&lt;p&gt;Photograph = Sample Image Sensor Plane，照片也就是采样图像传感器平面&lt;/p&gt;&#xA;&lt;img src = &#34;photograph.png&#34; alt = &#34;照片采样&#34; /&gt;&#xD;&#xA;&lt;p&gt;Video = Sample Time，视频也就是对时间采样，每隔一定时间采样一次&lt;/p&gt;&#xA;&lt;img src = &#34;video.png&#34; alt = &#34;视频采样&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;sampling-artifactserrors--mistakes--inaccuraciesin-computer-graphics&#34;&gt;Sampling Artifacts（Errors / Mistakes / Inaccuracies）in Computer Graphics&lt;/h3&gt;&#xA;&lt;p&gt;计算机图形学中由采样带来的“瑕疵”有很多，包括锯齿、摩尔纹、车轮效应。&lt;/p&gt;&#xA;&lt;p&gt;Jaggies（Staircase Pattern）：锯齿，也被称作楼梯模式&lt;/p&gt;&#xA;&lt;img src = &#34;jaggies.png&#34; alt = &#34;锯齿&#34; /&gt;&#xD;&#xA;&lt;p&gt;Moiré Patterns in Imaging：摩尔纹&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
