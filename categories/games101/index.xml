<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GAMES101 on 子春廿一</title>
    <link>https://nju-wrd.github.io/categories/games101/</link>
    <description>Recent content in GAMES101 on 子春廿一</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Sat, 11 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://nju-wrd.github.io/categories/games101/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>图形学实验笔记丨A0</title>
      <link>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a0/</link>
      <pubDate>Sat, 11 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a0/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a style=&#34;color: #0000FF;&#34; href=&#34;http://games-cn.org/forums/forum/graphics-intro/&#34; target=&#34;_blank&#34;&gt;论坛链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;要实现之前立的flag了，因为换了电脑加上前面的都忘掉了，所以重新完成一下原来已经做过的内容。在这个过程中大概率还要重新补一下前面的学习内容。&lt;/p&gt;&#xA;&lt;p&gt;本次作业主要目的是熟悉虚拟机的使用、使用C++与Eigen库编写简单的程序和用cmake进行编译,由于涉及虚拟机的安装，所以内容很长，可以参考实验的&lt;a style=&#34;color: #0000FF;&#34; href=&#34;pa0.pdf&#34; target=&#34;_blank&#34;&gt;Pdf文档&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业内容&#34;&gt;作业内容&lt;/h2&gt;&#xA;&lt;p&gt;给定一个点 P=(2,1), 将该点绕原点先逆时针旋转 45*◦*，再平移 (1,2), 计算出变换后点的坐标（要求用齐次坐标进行计算）。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;cmath&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;eigen3/Eigen/Core&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;eigen3/Eigen/Dense&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;iostream&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sin(&lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; M_PI &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;180.0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=-&lt;/span&gt;a;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Vector3f v(&lt;span style=&#34;color:#ae81ff&#34;&gt;2.0f&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0f&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0f&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Matrix3f i,j;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; a, b, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, a, a, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以在此基础上熟悉一下Eigen库的使用，为后续实验打下基础。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨03 Transformation</title>
      <link>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A803-transformation/</link>
      <pubDate>Fri, 10 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A803-transformation/</guid>
      <description>&lt;h3 id=&#34;scale缩放&#34;&gt;Scale（缩放）&lt;/h3&gt;&#xA;&lt;image src = &#34;scale.png&#34; alt = &#34;缩放变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;缩放可以对x和y采取相同的缩放比例，也可以不同。&lt;/p&gt;&#xA;&lt;h3 id=&#34;reflection对称&#34;&gt;Reflection（对称）&lt;/h3&gt;&#xA;&lt;image src = &#34;reflection.png&#34; alt = &#34;对称变换&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;shear剪切&#34;&gt;Shear（剪切）&lt;/h3&gt;&#xA;&lt;image src = &#34;shear.png&#34; alt = &#34;剪切变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里是水平方向上的切变。&lt;/p&gt;&#xA;&lt;h3 id=&#34;rotation旋转&#34;&gt;Rotation（旋转）&lt;/h3&gt;&#xA;&lt;image src = &#34;rotation.png&#34; alt = &#34;旋转变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里是二维的旋转，并且我们默认它是绕着原点旋转，逆时针方向旋转。θ也就是默认为逆时针旋转的方向。&lt;/p&gt;&#xA;&lt;p&gt;推导过程：&lt;/p&gt;&#xA;&lt;image src = &#34;tuidao.png&#34; alt = &#34;推导过程&#34; /&gt;&#xD;&#xA;&lt;p&gt;并以此类推，计算出所有的参数。&lt;/p&gt;&#xA;&lt;h2 id=&#34;linear-transformations线性变换&#34;&gt;Linear Transformations（线性变换）&lt;/h2&gt;&#xA;&lt;image src = &#34;linear.png&#34; alt = &#34;线性变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;如果一个变换可以写成一个矩阵去乘输入的坐标，得到变换后的坐标，这个变换就是线性变换。上述介绍的几种变换都是线性变换。&lt;/p&gt;&#xA;&lt;h2 id=&#34;homogeneous-coordinates齐次坐标&#34;&gt;Homogeneous coordinates（齐次坐标）&lt;/h2&gt;&#xA;&lt;p&gt;为什么要引入齐次坐标？有一种变换非常特殊：平移变换。&lt;/p&gt;&#xA;&lt;image src = &#34;translation.png&#34; alt = &#34;平移变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;我们会发现，它的变换非常简单，但是我们不可以像刚刚一样写成一个和矩阵相乘的形式了。我们只能写成：&lt;/p&gt;&#xA;&lt;image src = &#34;translation2.png&#34; alt = &#34;平移变换的计算写法&#34; /&gt;&#xD;&#xA;&lt;p&gt;所以，平移变换不是一个线性变换。但我们并不像为平移变换引入一种特殊的表示方式，我们希望的是将它们用同一种计算方法来表示。因此引入了齐次坐标的形式。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨02 Review of Linear Algebra</title>
      <link>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A802-review-of-linear-algebra/</link>
      <pubDate>Mon, 06 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A802-review-of-linear-algebra/</guid>
      <description>&lt;h2 id=&#34;graphics-dependencies&#34;&gt;Graphics’ Dependencies&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Basic mathematics&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Linear algebra, calculus, statistics（线性代数、微积分、统计）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Basic physics&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Optics, Mechanics（光学、力学）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Misc&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Signal processing（信号处理）&lt;/li&gt;&#xA;&lt;li&gt;Numerical analysis（数值分析）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;And a bit of aesthetics（美学）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;vectors&#34;&gt;Vectors&lt;/h2&gt;&#xA;&lt;p&gt;一个向量通常写做一个字母加一个在其上方从左指向右的箭头，或者是用加粗的字母表示&lt;strong&gt;a&lt;/strong&gt;。也可以用起点和终点加上箭头来表示，AB = B - A，即从点A指向点B，用B点坐标减去A点坐标。向量是由长度和方向组成的，它没有一个绝对的开始位置，如果对向量进行平移实际上他仍然是相等的向量。&lt;/p&gt;&#xA;&lt;image src = &#34;vector.png&#34; alt = &#34;向量&#34; /&gt;&#xD;&#xA;&lt;p&gt;一个向量的长度用||&lt;strong&gt;a&lt;/strong&gt;||表示，利用向量的长度我们可以获得单位向量：&lt;strong&gt;u&lt;/strong&gt; = &lt;strong&gt;a&lt;/strong&gt; / ||&lt;strong&gt;a&lt;/strong&gt;||，我们可以用单位向量来表示方向，不关心它的长度。&lt;/p&gt;&#xA;&lt;h3 id=&#34;vector-addition向量加法&#34;&gt;Vector Addition（向量加法）&lt;/h3&gt;&#xA;&lt;p&gt;分为平行四边形法则和三角形法则，不过殊途同归，计算的结果是一样的。平行四边形法则，对于向量a和向量b我们都可以任意的移动，然后将&lt;strong&gt;a&lt;/strong&gt;和&lt;strong&gt;b&lt;/strong&gt;都进行一定的平移，使得他们围成一个平行四边形，红线就是计算的结果。三角形法则，我们要将向量相加，就将他们首尾相连拼接起来，最后形成的最开始和最后就是计算的结果，这个也同样适用于多个向量相加。&lt;/p&gt;&#xA;&lt;p&gt;以上是在几何上理解向量相加，在数学上向量相加，就是将他们的坐标给加起来。&lt;/p&gt;&#xA;&lt;image src = &#34;addition.png&#34; alt = &#34;向量的加法&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;cartesian-coordinates笛卡尔坐标&#34;&gt;cartesian coordinates（笛卡尔坐标）&lt;/h3&gt;&#xA;&lt;image src = &#34;cartesian coordinates.png&#34; alt = &#34;笛卡尔坐标系下的向量&#34; /&gt;&#xD;&#xA;&lt;p&gt;在坐标系下描述一个向量，我们永远认为这个向量从(0, 0)开始，&lt;strong&gt;X&lt;/strong&gt;是向右的单位向量，&lt;strong&gt;Y&lt;/strong&gt;是向上的单位向量，一个向量是多少，就由几个&lt;strong&gt;X&lt;/strong&gt;加上几个&lt;strong&gt;Y&lt;/strong&gt;来表示，通常它们是互相垂直的单位向量。如上图所示，这样的话，我们就可以直接用A&lt;sup&gt;⊤&lt;/sup&gt; = (4, 3)来表示这个向量。这里有一点，在图形学，默认向量是一个列向量。在此基础上，计算向量的长度也会很简单，公式如图右下角所示。&lt;/p&gt;&#xA;&lt;h3 id=&#34;dotscalar-product点积&#34;&gt;Dot（scalar） Product（点积）&lt;/h3&gt;&#xA;&lt;image src = &#34;dot.png&#34; alt = &#34;点乘&#34; /&gt;&#xD;&#xA;&lt;p&gt;点乘的计算如图所示，这里的θ是两个向量之间的夹角。两个向量点乘的结果是一个数字（标量），其实向量的点乘可以方便计算这个θ角。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨07 Shading 1(illumination, Shading)</title>
      <link>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A807-shading-1illumination-shading/</link>
      <pubDate>Thu, 02 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A807-shading-1illumination-shading/</guid>
      <description>&lt;h2 id=&#34;painters-algorithm画家算法&#34;&gt;Painter&amp;rsquo;s Algorithm（画家算法）&lt;/h2&gt;&#xA;&lt;p&gt;上节课我们学习了如何光栅化一个三角形，但是当画面中有多个三角形的时候，该如何去光栅化所有的图像？一个办法就是像油画家一样，先画远处的内容，再画稍近一点的内容，也就是按照图像本身在画面中的深度由远及近的进行光栅化。&lt;/p&gt;&#xA;&lt;p&gt;很直观的方式就是可以对所有的物体进行深度的排序（O（nlogn）），但是这样存在不可解决的排序顺序，如下图所示：&lt;/p&gt;&#xA;&lt;img src = &#34;unresolvable.png&#34; alt = &#34;不可解决的顺序&#34; /&gt;&#xD;&#xA;&lt;p&gt;他们在深度上存在一个互相遮挡的关系，就无法对他们进行深度的排序，画家算法在这里也就失效了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;z-buffer深度缓存depth-buffer&#34;&gt;Z-Buffer（深度缓存depth buffer）&lt;/h2&gt;&#xA;&lt;p&gt;图形学实际上采用的是Z-Buffer的方法，也就是对于每一个像素去存储离我们最近的深度也就是最浅的深度z-value的信息。&lt;/p&gt;&#xA;&lt;p&gt;对于实际完成，会渲染最终的成品，也就是预期的效果；在生成这个结果的同时，也会生成另外一个图像，这个图像只存看到的几何物体最浅的深度的信息，这个图就叫做depth buffer（z-buffer）。存储最终结果的叫做frame buffer，利用深度缓存的想法来维护遮挡信息。&lt;/p&gt;&#xA;&lt;p&gt;这里重要的一点是，现在我们用z来表示一点到摄像机的距离，且这个z永远是正的，也就是说z的数值越大离我们越远，数值越小离我们越近。这里和前面学习的变换当中的概念不同（变换当中，摄像机在原点朝着-z方向，因此距离越近，数字越大，且z为负的）。&lt;/p&gt;&#xA;&lt;img src = &#34;buffer.png&#34; alt = &#34;生成的渲染图和深度信息图&#34; /&gt;&#xD;&#xA;&lt;p&gt;左侧是渲染的结果，右侧是维护遮挡信息的深度图。可以看到，离我们越远，颜色也就越浅，离我们越近，颜色也就越深。&lt;/p&gt;&#xA;&lt;img src = &#34;algorithm.png&#34; alt = &#34;算法伪代码&#34; /&gt;&#xD;&#xA;&lt;p&gt;上图就是要实现的算法了，首先将深度缓存的所有像素一开始记录的深度初始化为无限大，即表示无限远。然后在每一个三角形进行光栅化的过程中，对于任意一个三角形的任意一个像素，如果现在要画的深度小于深度缓存记录好的深度，就更新深度缓存的值为更小的，并且把这个结果存到要渲染的frame-buffer里面去，否则什么都不做。&lt;/p&gt;&#xA;&lt;p&gt;时间复杂度为O（n），并且不会因为画三角形的顺序不同而产生不同结果（假设在同一像素上不同三角形不会有相同深度的值，因为用浮点型记录深度很难有相同值的存在）。&lt;/p&gt;&#xA;&lt;p&gt;在之前提到的反走样技术MSAA中，考虑到会在一个像素内设置多个采样点，因此在结合这样的技术的时候，对于不同的采样点，也要做相应的深度缓存。&lt;/p&gt;&#xA;&lt;h2 id=&#34;shading着色&#34;&gt;Shading（着色）&lt;/h2&gt;&#xA;&lt;p&gt;对不同物体应用不同的材质。&lt;/p&gt;&#xA;&lt;h3 id=&#34;a-simple-shading-modelblinn-phong-reflectance-model&#34;&gt;A Simple Shading Model（Blinn-Phong Reflectance Model）&lt;/h3&gt;&#xA;&lt;p&gt;在了解这个模型之前，我们可以先了解一下着色要考虑到的三个内容：高光、漫反射和环境光。高光指的是光源照射到一个相对来说较为光滑的平面，光线被反射到镜面反射附近位置产生的高亮，漫反射是指光线找到类似于墙壁这种比较粗糙的面上产生的各个方向的反射；而环境光是指由于各个面上都会发生反射，最终使得即使在光源无法照到的位置也能被看到，此处就是环境光。&lt;/p&gt;&#xA;&lt;p&gt;接下来看一些定义：&lt;/p&gt;&#xA;&lt;img src = &#34;definition.png&#34; alt = &#34;光的反射的数值定义&#34; /&gt;&#xD;&#xA;&lt;p&gt;我们考虑光照首先是在任何一个点上去考虑，也就是在一个shading point上去考虑它的着色结果是什么。那么对于这个point所属的一个物体表面上，我们认为在一个局部的一个非常小的范围内，这个表面永远是一个平面。那么在这个平面上，我们可以定义平面的法线向量n，观测方向为shading point 到观测点的方向，也就是向量v，从point看向光源的方向叫做光源方向，记作向量l。且这三个向量都被记为单位向量，长度为1。其次，对于shading point本身的一些属性，要定义一下和物体表面相关的信息。例如它是什么颜色，它有多么亮等等（color，shininess&amp;hellip;）。&lt;/p&gt;&#xA;&lt;p&gt;补充一点是，我们考虑的shading point是在局部的，也就是不考虑是否在阴影内等和其他物体产生联系的情况。&lt;/p&gt;&#xA;&lt;h4 id=&#34;diffusion&#34;&gt;diffusion&lt;/h4&gt;&#xA;&lt;p&gt;首先考虑漫反射的情况，当光照到物体表面的某一个点时，会被均匀的反射到各个不同的方向上去。&lt;/p&gt;&#xA;&lt;img src = &#34;diffusion.png&#34; alt = &#34;漫反射&#34; /&gt;&#xD;&#xA;&lt;p&gt;并且对于光线的不同入射角度，光的强度也会发生变化。总的来说，一个漫反射的部分单位面积会接收到多少光和光照方向与法线方向形成夹角的余弦值成正比。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨06 Rasterization 2（Antialiasing）</title>
      <link>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A806-rasterization-2antialiasing/</link>
      <pubDate>Thu, 14 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A806-rasterization-2antialiasing/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&lt;s&gt;在我开始写博客之前我已经学完了前面的五次课，并且完成了作业0和作业1。在我简单回顾之后，我本来是想把这一块补上的，因为前几节课还是有很多需要记住的点的。但是犹豫再三，我还是放弃了，因为还是那句话，这意味着我要补上前面的很多内容，会带来很多重复的工作量让我心生退却。不过我也给自己立了一个 Flag ，如果我下一次用到相关知识，或者说复习的时候忘记了，我就把它加上，这样它对我来说就是一个更加有意义的工作量了，我会更容易接受。&lt;/s&gt;&lt;/p&gt;&#xA;&lt;p&gt;课程内容来源：&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://www.bilibili.com/video/BV1X7411F744?spm_id_from=333.788.videopod.episodes&amp;vd_source=1837baf7c46a027b7e27b4ab7174fb85&#34; target=&#34;_blank&#34;&gt;GAMES101-现代计算机图形学入门-闫令琪&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;antialiasing&#34;&gt;Antialiasing&lt;/h2&gt;&#xA;&lt;img src = &#34;jaggie.png&#34; alt = &#34;锯齿&#34; /&gt;&#xD;&#xA;&lt;p&gt;锯齿是一种图片走样的结果，比如图中本来是一个三角形，但经过测试像素中心点在三角形内部还是外部并且将在内部的像素填上颜色的方式呈现在屏幕上时，就发生了锯齿的现象。所以我们要采用反走样技术来解决这种现象。&lt;/p&gt;&#xA;&lt;p&gt;在这之前我们先看看在计算机图形学中的采样。&lt;/p&gt;&#xA;&lt;p&gt;Rasterization = Sample 2D Positions，栅格化也就是采样2D平面内的位置&lt;/p&gt;&#xA;&lt;img src = &#34;rasterization.png&#34; alt = &#34;栅格化&#34; /&gt;&#xD;&#xA;&lt;p&gt;Photograph = Sample Image Sensor Plane，照片也就是采样图像传感器平面&lt;/p&gt;&#xA;&lt;img src = &#34;photograph.png&#34; alt = &#34;照片采样&#34; /&gt;&#xD;&#xA;&lt;p&gt;Video = Sample Time，视频也就是对时间采样，每隔一定时间采样一次&lt;/p&gt;&#xA;&lt;img src = &#34;video.png&#34; alt = &#34;视频采样&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;sampling-artifactserrors--mistakes--inaccuraciesin-computer-graphics&#34;&gt;Sampling Artifacts（Errors / Mistakes / Inaccuracies）in Computer Graphics&lt;/h3&gt;&#xA;&lt;p&gt;计算机图形学中由采样带来的“瑕疵”有很多，包括锯齿、摩尔纹、车轮效应。&lt;/p&gt;&#xA;&lt;p&gt;Jaggies（Staircase Pattern）：锯齿，也被称作楼梯模式&lt;/p&gt;&#xA;&lt;img src = &#34;jaggies.png&#34; alt = &#34;锯齿&#34; /&gt;&#xD;&#xA;&lt;p&gt;Moiré Patterns in Imaging：摩尔纹&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
