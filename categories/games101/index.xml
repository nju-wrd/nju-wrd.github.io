<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GAMES101 on 子春廿一</title>
    <link>http://localhost:1313/categories/games101/</link>
    <description>Recent content in GAMES101 on 子春廿一</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Wed, 22 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/games101/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>图形学实验笔记丨A1</title>
      <link>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a1/</link>
      <pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a1/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;我们已经学习了如何使用矩阵变换来排列二维或三维空间中的对象。所以现在是时候通过实现一些简单的变换矩阵来获得一些实际经验了。在接下来的三次作业中，我们将去模拟一个基于CPU的光栅化渲染器的简化版本。&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业内容&#34;&gt;作业内容&lt;/h2&gt;&#xA;&lt;p&gt;填写一个旋转矩阵和一个透视投影矩阵。给定三维下三个点v0(2.0, 0.0, −2.0)，v1(0.0, 2.0, −2.0)，v2(−2.0, 0.0, −2.0)，需要将这三个点的坐标变换为屏幕坐标并在屏幕上绘制出对应的线框三角形）在代码框架中，我们已经提供了draw_triangle函数，所以只需要去构建变换矩阵即可）。简而言之，我们需要进行模型、视图、投影、视口等变换来将三角形显示在屏幕上。在提供的代码框架中，我们留下了模型变换和投影变换的部分去完成。&lt;/p&gt;&#xA;&lt;p&gt;要记得每次复制代码框架之后，先完成cmake编译的工作。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mkdir build&#xD;&#xA;cd build&#xD;&#xA;cmake ..&#xD;&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;补充代码如下所示：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Matrix4f get_model_matrix(&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; rotation_angle)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;//TODO:Implement this function&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;//Create the model matrix for rotating the triangle around the Z axis.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;//Then return it.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;Eigen:Matrix4f model &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Matrix4f&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Identity()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; rotation_rad &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rotation_angle &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; MY_PI &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;180&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; co &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cos(rotation_rad),si &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sin(rotation_rad);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;model &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; co, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;si, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9; si, co, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; model;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Matrix4f get_projection_matrix(&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; eye_fov, &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; aspect_ratio,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                      &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; zNear,&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; zFar)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//Students will implement this function&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;//TODO:Implement this function&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;//Create the projection matrix for the given parameters.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;//Then return it.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Matrix4f projection &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Matrix4f&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Identity();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Matrix4f scale &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Matrix4f&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Identity();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Matrix4f perspective &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Matrix4f&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Identity();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; tb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; tan(eye_fov &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; zNear;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; rl &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tb &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; aspect_ratio;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; fn &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; zFar &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; zNear;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;scale &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; r1, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; tb, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; fn, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;perspective &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; zNear, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, zNear, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, zNear &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; zFar, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;zNear &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; zFar,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;projection &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scale &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; perspective;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; projection;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨05 Rasterization 1（Triangles）</title>
      <link>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A805-rasterization-1triangles/</link>
      <pubDate>Mon, 20 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A805-rasterization-1triangles/</guid>
      <description>&lt;h2 id=&#34;perspective-projection&#34;&gt;Perspective Projection&lt;/h2&gt;&#xA;&lt;p&gt;透视投影的第一步是将透视投影转换成正交投影，我们要保证近和远两个平面都是不变的，近、远两个平面都会被变成和近平面一样大。还记得在正交投影里，我们如何定义三维空间的长方体，分别是用x轴的覆盖定义它的左和右，用y轴的覆盖定义它的上和下，用z轴的覆盖表示远和近。在透视投影和正交投影中远和近的near和far是一样的，我们认为其已知。&lt;/p&gt;&#xA;&lt;p&gt;在做透视投影的时候，我们要把这个frustum变成正交投影的cube。该如何定义这个frustum或者说视锥呢？可见下图：&lt;/p&gt;&#xA;&lt;image src = &#34;frustum.png&#34; alt = &#34;视锥&#34; /&gt;&#xD;&#xA;&lt;p&gt;我们可以从摄像机出发看向某个区域，如果我们看的就是这个进的平面，那么我们可以给这个平面定义一个宽度和高度。因此我们定义宽高比（aspect ratio）为宽度除以高度，定义视角（field-of-view（fovY））为可以看到的角度的范围（垂直可视角度），这个角度一般用来定义可以看到的视界。通过这两个定义我们也可以推出水平的可视角度。&lt;/p&gt;&#xA;&lt;p&gt;我们也可以把这个概念迁移到空间中的定义，如下所示：&lt;/p&gt;&#xA;&lt;image src = &#34;transform.png&#34; alt = &#34;概念迁移&#34; /&gt;&#xD;&#xA;&lt;p&gt;从侧面看透视投影的三角形，我们获得了上述定义的两个量的计算。&lt;/p&gt;&#xA;&lt;h2 id=&#34;canonical-cube-to-screen&#34;&gt;Canonical Cube to Screen&lt;/h2&gt;&#xA;&lt;p&gt;对于图形学来说，我们抽象地认为一个屏幕是一个二维数组，数组中的每一个元素是一个像素。这个二维数组的大小也叫做分辨率，而屏幕是一个典型的光栅成像设备，光栅化就是指把东西画在屏幕上。像素（pixel）来源于picture element的缩写，在这门课里，我们把它认为成一个一个的小方块，并且在一个方块内的颜色不会有变化。&lt;/p&gt;&#xA;&lt;p&gt;我们可以定义屏幕空间在一个坐标系中，从屏幕的左下角为原点出发。像素的坐标我们用整数来描述，形如(x, y)（下标从0开始）。坐标范围从(0, 0)到(width - 1, height - 1)。虽然我们用整数坐标来表述像素坐标，但是像素的中心是在(x + 0.5, y + 0.5)。&lt;/p&gt;&#xA;&lt;p&gt;接下来要做的事情就是将图像映射到屏幕空间，即[-1,1]&lt;sup&gt;3&lt;/sup&gt;到屏幕上，所以这里暂时先不管z，只看xy。只要将xy从[-1,1]&lt;sup&gt;2&lt;/sup&gt;拉伸到[0, width]×[0, height]。这个变换的矩阵如下：&lt;/p&gt;&#xA;&lt;image src = &#34;juzhen.png&#34; alt = &#34;拉伸的矩阵&#34; /&gt;&#xD;&#xA;&lt;p&gt;左上角的3×3矩阵就是拉伸的部分，因为原来的中心在(0, 0)而现在的中心在(width/2, height/2)，所以要进行平移。这个变换就叫做视口变换。&lt;/p&gt;&#xA;&lt;p&gt;解决了变换的问题之后，要解决的是如何光栅化，也就是将三角形画到像素中。&lt;/p&gt;&#xA;&lt;h3 id=&#34;television-raster-display-crtcathode-ray-tube&#34;&gt;Television-Raster Display CRT（Cathode Ray Tube）&lt;/h3&gt;&#xA;&lt;p&gt;早期的显示器成像原理为阴极射线管，将电子加速并经过磁场的偏转打在屏幕上，由于这个过程足够快，所以可以在屏幕上看到完整的画面，而不是一个一个电子的光点。&lt;/p&gt;&#xA;&lt;image src = &#34;crt.png&#34; alt = &#34;阴极射线管&#34; /&gt;&#xD;&#xA;&lt;p&gt;通过一种扫描的方式，控制每一个电子打在什么位置，比如说可以在屏幕上从左往右，从上往下的画线。当画的足够密集时，基本上就可以覆盖整个屏幕了。为了让他画的快一点，可以隔一行画一条线，比如一开始画奇数行，到下一张图的时候只画偶数行，这个技术就叫做隔行扫描技术。这样，每张图的工作量都减少了一半，并且人眼很难感知察觉到这个中间缺少的部分，相当于每一次看到的都是完整的画面。但是对于高速运动的画面会造成严重的撕裂。&lt;/p&gt;&#xA;&lt;h3 id=&#34;frame-buffermemory-for-a-raster-display&#34;&gt;Frame Buffer：Memory for a Raster Display&lt;/h3&gt;&#xA;&lt;p&gt;现在拿到一个显示器，它如何知道要显示什么呢？其实，显示器是通过映射内存中的一块区域到屏幕上来生成图像。通过映射不同的区域，生成不同的图像。并且在这个过程中，这个内存通常来自于显存。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨04 Transformation Cont</title>
      <link>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A804-transformation-cont/</link>
      <pubDate>Wed, 15 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A804-transformation-cont/</guid>
      <description>&lt;h2 id=&#34;3d-transforms&#34;&gt;3D Transforms&lt;/h2&gt;&#xA;&lt;p&gt;这里可以类比二维的变化，依旧是使用齐次坐标系：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;3D point = (x, y, z, 1)&lt;sup&gt;⊤&lt;/sup&gt;&lt;/li&gt;&#xA;&lt;li&gt;3D vector = (x, y, z, 0)&lt;sup&gt;⊤&lt;/sup&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;并且同样的，当w≠0，(x, y, z, w)就是点(x/w, y/w, z/w, 1)。&lt;/p&gt;&#xA;&lt;image src = &#34;homogeneous3.png&#34; alt = &#34;3D下的齐次坐标矩阵&#34; /&gt;&#xD;&#xA;&lt;p&gt;针对3D下的齐次坐标矩阵，做更多的细节解释。&lt;/p&gt;&#xA;&lt;p&gt;在三维空间中，也是先应用线性变换，再应用平移变换。针对左上角的3×3矩阵，缩放变换则是一个对角矩阵，从上到下依次是x、y、z的缩放比例；旋转分为三种：&lt;/p&gt;&#xA;&lt;image src = &#34;rotate.png&#34; alt = &#34;3D下的旋转矩阵&#34; /&gt;&#xD;&#xA;&lt;p&gt;当我们想要在三维空间中进行任意地旋转很难写，我们可以从简单的开始写起，即绕着某一个轴旋转。我门可以看到，绕着哪个轴转，哪个轴的值就不变。剩下的二维矩阵就是一个二维下的旋转。这一点对于绕y轴的旋转有所不同，这是因为在右手坐标系中，x可以通过y叉乘z得到，z可以通过x叉乘y得到，而y是由z叉乘x得到，不是按照xyz的顺序，所以这里sin的正负相反。&lt;/p&gt;&#xA;&lt;p&gt;这样，三维空间的旋转，可以通过三个平面的旋转来表示：&lt;/p&gt;&#xA;&lt;p&gt;R&lt;sub&gt;xyz&lt;/sub&gt;(α, β, γ) = R&lt;sub&gt;x&lt;/sub&gt;(α)R&lt;sub&gt;y&lt;/sub&gt;(β)R&lt;sub&gt;z&lt;/sub&gt;(γ)&lt;/p&gt;&#xA;&lt;p&gt;这里的旋转都是默认的逆时针旋转。这三个角又被称为欧拉角。&lt;/p&gt;&#xA;&lt;image src = &#34;3drotate.png&#34; alt = &#34;飞行中的旋转组合&#34; /&gt;&#xD;&#xA;&lt;p&gt;飞机运行中的旋转也类似的可以分解为pitch、yaw、roll。&lt;/p&gt;&#xA;&lt;h3 id=&#34;rodrigues-rotation-formula&#34;&gt;Rodrigues’ Rotation Formula&lt;/h3&gt;&#xA;&lt;image src = &#34;formula.png&#34; alt = &#34;公式&#34; /&gt;&#xD;&#xA;&lt;p&gt;这样，绕任意轴旋转任意角度可以通过这个公式计算变换的结果。另外，三维空间中，如果绕着某一条平行于坐标轴的轴旋转，依旧可以采取先将该轴移回坐标轴进行旋转，再进行一个平移的逆变换的方式进行计算。&lt;/p&gt;&#xA;&lt;p&gt;（这里没有介绍四元数的概念，四元数可能主要用于插值）&lt;/p&gt;&#xA;&lt;h2 id=&#34;viewing观测-transformation&#34;&gt;Viewing（观测） transformation&lt;/h2&gt;&#xA;&lt;h3 id=&#34;view视图camera-translation&#34;&gt;View（视图）/Camera translation&lt;/h3&gt;&#xA;&lt;p&gt;我们最终的目的是把一个三维空间世界看到的内容转化为二维空间中的一个图像。可以先想想如何拍一张照片，首先找到一个地方，并安排好要拍的内容（model transformation），然后找到一个角度来放置照相机（view transformation），最后拍下（projection transformation）。这个过程也可以简称为mvp变换。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学实验笔记丨A0</title>
      <link>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a0/</link>
      <pubDate>Sat, 11 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a0/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a style=&#34;color: #0000FF;&#34; href=&#34;http://games-cn.org/forums/forum/graphics-intro/&#34; target=&#34;_blank&#34;&gt;论坛链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;要实现之前立的flag了，因为换了电脑加上前面的都忘掉了，所以重新完成一下原来已经做过的内容。在这个过程中大概率还要重新补一下前面的学习内容。&lt;/p&gt;&#xA;&lt;p&gt;本次作业主要目的是熟悉虚拟机的使用、使用C++与Eigen库编写简单的程序和用cmake进行编译,由于涉及虚拟机的安装，所以内容很长，可以参考实验的&lt;a style=&#34;color: #0000FF;&#34; href=&#34;pa0.pdf&#34; target=&#34;_blank&#34;&gt;Pdf文档&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业内容&#34;&gt;作业内容&lt;/h2&gt;&#xA;&lt;p&gt;给定一个点 P=(2,1), 将该点绕原点先逆时针旋转 45°，再平移 (1,2), 计算出变换后点的坐标（要求用齐次坐标进行计算）。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;cmath&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;eigen3/Eigen/Core&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;eigen3/Eigen/Dense&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;iostream&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; si &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sin(&lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; M_PI &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;180.0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Vector3f v(&lt;span style=&#34;color:#ae81ff&#34;&gt;2.0f&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0f&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0f&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Eigen&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Matrix3f i,j;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; si, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;si, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, si, si, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以在此基础上熟悉一下Eigen库的使用，为后续实验打下基础。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨03 Transformation</title>
      <link>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A803-transformation/</link>
      <pubDate>Fri, 10 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A803-transformation/</guid>
      <description>&lt;h3 id=&#34;scale缩放&#34;&gt;Scale（缩放）&lt;/h3&gt;&#xA;&lt;image src = &#34;scale.png&#34; alt = &#34;缩放变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;缩放可以对x和y采取相同的缩放比例，也可以不同。&lt;/p&gt;&#xA;&lt;h3 id=&#34;reflection对称&#34;&gt;Reflection（对称）&lt;/h3&gt;&#xA;&lt;image src = &#34;reflection.png&#34; alt = &#34;对称变换&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;shear剪切&#34;&gt;Shear（剪切）&lt;/h3&gt;&#xA;&lt;image src = &#34;shear.png&#34; alt = &#34;剪切变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里是水平方向上的切变。&lt;/p&gt;&#xA;&lt;h3 id=&#34;rotation旋转&#34;&gt;Rotation（旋转）&lt;/h3&gt;&#xA;&lt;image src = &#34;rotation.png&#34; alt = &#34;旋转变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里是二维的旋转，并且我们默认它是绕着原点旋转，逆时针方向旋转。θ也就是默认为逆时针旋转的方向。&lt;/p&gt;&#xA;&lt;p&gt;推导过程：&lt;/p&gt;&#xA;&lt;image src = &#34;tuidao.png&#34; alt = &#34;推导过程&#34; /&gt;&#xD;&#xA;&lt;p&gt;并以此类推，计算出所有的参数。&lt;/p&gt;&#xA;&lt;h2 id=&#34;linear-transformations线性变换&#34;&gt;Linear Transformations（线性变换）&lt;/h2&gt;&#xA;&lt;image src = &#34;linear.png&#34; alt = &#34;线性变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;如果一个变换可以写成一个矩阵去乘输入的坐标，得到变换后的坐标，这个变换就是线性变换。上述介绍的几种变换都是线性变换。&lt;/p&gt;&#xA;&lt;h2 id=&#34;homogeneous-coordinates齐次坐标&#34;&gt;Homogeneous coordinates（齐次坐标）&lt;/h2&gt;&#xA;&lt;p&gt;为什么要引入齐次坐标？有一种变换非常特殊：平移变换。&lt;/p&gt;&#xA;&lt;image src = &#34;translation.png&#34; alt = &#34;平移变换&#34; /&gt;&#xD;&#xA;&lt;p&gt;我们会发现，它的变换非常简单，但是我们不可以像刚刚一样写成一个和矩阵相乘的形式了。我们只能写成：&lt;/p&gt;&#xA;&lt;image src = &#34;translation2.png&#34; alt = &#34;平移变换的计算写法&#34; /&gt;&#xD;&#xA;&lt;p&gt;所以，平移变换不是一个线性变换。但我们并不像为平移变换引入一种特殊的表示方式，我们希望的是将它们用同一种计算方法来表示。因此引入了齐次坐标的形式。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨02 Review of Linear Algebra</title>
      <link>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A802-review-of-linear-algebra/</link>
      <pubDate>Mon, 06 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A802-review-of-linear-algebra/</guid>
      <description>&lt;h2 id=&#34;graphics-dependencies&#34;&gt;Graphics’ Dependencies&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Basic mathematics&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Linear algebra, calculus, statistics（线性代数、微积分、统计）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Basic physics&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Optics, Mechanics（光学、力学）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Misc&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Signal processing（信号处理）&lt;/li&gt;&#xA;&lt;li&gt;Numerical analysis（数值分析）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;And a bit of aesthetics（美学）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;vectors&#34;&gt;Vectors&lt;/h2&gt;&#xA;&lt;p&gt;一个向量通常写做一个字母加一个在其上方从左指向右的箭头，或者是用加粗的字母表示&lt;strong&gt;a&lt;/strong&gt;。也可以用起点和终点加上箭头来表示，AB = B - A，即从点A指向点B，用B点坐标减去A点坐标。向量是由长度和方向组成的，它没有一个绝对的开始位置，如果对向量进行平移实际上他仍然是相等的向量。&lt;/p&gt;&#xA;&lt;image src = &#34;vector.png&#34; alt = &#34;向量&#34; /&gt;&#xD;&#xA;&lt;p&gt;一个向量的长度用||&lt;strong&gt;a&lt;/strong&gt;||表示，利用向量的长度我们可以获得单位向量：&lt;strong&gt;u&lt;/strong&gt; = &lt;strong&gt;a&lt;/strong&gt; / ||&lt;strong&gt;a&lt;/strong&gt;||，我们可以用单位向量来表示方向，不关心它的长度。&lt;/p&gt;&#xA;&lt;h3 id=&#34;vector-addition向量加法&#34;&gt;Vector Addition（向量加法）&lt;/h3&gt;&#xA;&lt;p&gt;分为平行四边形法则和三角形法则，不过殊途同归，计算的结果是一样的。平行四边形法则，对于向量a和向量b我们都可以任意的移动，然后将&lt;strong&gt;a&lt;/strong&gt;和&lt;strong&gt;b&lt;/strong&gt;都进行一定的平移，使得他们围成一个平行四边形，红线就是计算的结果。三角形法则，我们要将向量相加，就将他们首尾相连拼接起来，最后形成的最开始和最后就是计算的结果，这个也同样适用于多个向量相加。&lt;/p&gt;&#xA;&lt;p&gt;以上是在几何上理解向量相加，在数学上向量相加，就是将他们的坐标给加起来。&lt;/p&gt;&#xA;&lt;image src = &#34;addition.png&#34; alt = &#34;向量的加法&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;cartesian-coordinates笛卡尔坐标&#34;&gt;cartesian coordinates（笛卡尔坐标）&lt;/h3&gt;&#xA;&lt;image src = &#34;cartesian coordinates.png&#34; alt = &#34;笛卡尔坐标系下的向量&#34; /&gt;&#xD;&#xA;&lt;p&gt;在坐标系下描述一个向量，我们永远认为这个向量从(0, 0)开始，&lt;strong&gt;X&lt;/strong&gt;是向右的单位向量，&lt;strong&gt;Y&lt;/strong&gt;是向上的单位向量，一个向量是多少，就由几个&lt;strong&gt;X&lt;/strong&gt;加上几个&lt;strong&gt;Y&lt;/strong&gt;来表示，通常它们是互相垂直的单位向量。如上图所示，这样的话，我们就可以直接用A&lt;sup&gt;⊤&lt;/sup&gt; = (4, 3)来表示这个向量。这里有一点，在图形学，默认向量是一个列向量。在此基础上，计算向量的长度也会很简单，公式如图右下角所示。&lt;/p&gt;&#xA;&lt;h3 id=&#34;dotscalar-product点积&#34;&gt;Dot（scalar） Product（点积）&lt;/h3&gt;&#xA;&lt;image src = &#34;dot.png&#34; alt = &#34;点乘&#34; /&gt;&#xD;&#xA;&lt;p&gt;点乘的计算如图所示，这里的θ是两个向量之间的夹角。两个向量点乘的结果是一个数字（标量），其实向量的点乘可以方便计算这个θ角。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨07 Shading 1(illumination, Shading)</title>
      <link>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A807-shading-1illumination-shading/</link>
      <pubDate>Thu, 02 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A807-shading-1illumination-shading/</guid>
      <description>&lt;h2 id=&#34;painters-algorithm画家算法&#34;&gt;Painter&amp;rsquo;s Algorithm（画家算法）&lt;/h2&gt;&#xA;&lt;p&gt;上节课我们学习了如何光栅化一个三角形，但是当画面中有多个三角形的时候，该如何去光栅化所有的图像？一个办法就是像油画家一样，先画远处的内容，再画稍近一点的内容，也就是按照图像本身在画面中的深度由远及近的进行光栅化。&lt;/p&gt;&#xA;&lt;p&gt;很直观的方式就是可以对所有的物体进行深度的排序（O（nlogn）），但是这样存在不可解决的排序顺序，如下图所示：&lt;/p&gt;&#xA;&lt;img src = &#34;unresolvable.png&#34; alt = &#34;不可解决的顺序&#34; /&gt;&#xD;&#xA;&lt;p&gt;他们在深度上存在一个互相遮挡的关系，就无法对他们进行深度的排序，画家算法在这里也就失效了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;z-buffer深度缓存depth-buffer&#34;&gt;Z-Buffer（深度缓存depth buffer）&lt;/h2&gt;&#xA;&lt;p&gt;图形学实际上采用的是Z-Buffer的方法，也就是对于每一个像素去存储离我们最近的深度也就是最浅的深度z-value的信息。&lt;/p&gt;&#xA;&lt;p&gt;对于实际完成，会渲染最终的成品，也就是预期的效果；在生成这个结果的同时，也会生成另外一个图像，这个图像只存看到的几何物体最浅的深度的信息，这个图就叫做depth buffer（z-buffer）。存储最终结果的叫做frame buffer，利用深度缓存的想法来维护遮挡信息。&lt;/p&gt;&#xA;&lt;p&gt;这里重要的一点是，现在我们用z来表示一点到摄像机的距离，且这个z永远是正的，也就是说z的数值越大离我们越远，数值越小离我们越近。这里和前面学习的变换当中的概念不同（变换当中，摄像机在原点朝着-z方向，因此距离越近，数字越大，且z为负的）。&lt;/p&gt;&#xA;&lt;img src = &#34;buffer.png&#34; alt = &#34;生成的渲染图和深度信息图&#34; /&gt;&#xD;&#xA;&lt;p&gt;左侧是渲染的结果，右侧是维护遮挡信息的深度图。可以看到，离我们越远，颜色也就越浅，离我们越近，颜色也就越深。&lt;/p&gt;&#xA;&lt;img src = &#34;algorithm.png&#34; alt = &#34;算法伪代码&#34; /&gt;&#xD;&#xA;&lt;p&gt;上图就是要实现的算法了，首先将深度缓存的所有像素一开始记录的深度初始化为无限大，即表示无限远。然后在每一个三角形进行光栅化的过程中，对于任意一个三角形的任意一个像素，如果现在要画的深度小于深度缓存记录好的深度，就更新深度缓存的值为更小的，并且把这个结果存到要渲染的frame-buffer里面去，否则什么都不做。&lt;/p&gt;&#xA;&lt;p&gt;时间复杂度为O（n），并且不会因为画三角形的顺序不同而产生不同结果（假设在同一像素上不同三角形不会有相同深度的值，因为用浮点型记录深度很难有相同值的存在）。&lt;/p&gt;&#xA;&lt;p&gt;在之前提到的反走样技术MSAA中，考虑到会在一个像素内设置多个采样点，因此在结合这样的技术的时候，对于不同的采样点，也要做相应的深度缓存。&lt;/p&gt;&#xA;&lt;h2 id=&#34;shading着色&#34;&gt;Shading（着色）&lt;/h2&gt;&#xA;&lt;p&gt;对不同物体应用不同的材质。&lt;/p&gt;&#xA;&lt;h3 id=&#34;a-simple-shading-modelblinn-phong-reflectance-model&#34;&gt;A Simple Shading Model（Blinn-Phong Reflectance Model）&lt;/h3&gt;&#xA;&lt;p&gt;在了解这个模型之前，我们可以先了解一下着色要考虑到的三个内容：高光、漫反射和环境光。高光指的是光源照射到一个相对来说较为光滑的平面，光线被反射到镜面反射附近位置产生的高亮，漫反射是指光线找到类似于墙壁这种比较粗糙的面上产生的各个方向的反射；而环境光是指由于各个面上都会发生反射，最终使得即使在光源无法照到的位置也能被看到，此处就是环境光。&lt;/p&gt;&#xA;&lt;p&gt;接下来看一些定义：&lt;/p&gt;&#xA;&lt;img src = &#34;definition.png&#34; alt = &#34;光的反射的数值定义&#34; /&gt;&#xD;&#xA;&lt;p&gt;我们考虑光照首先是在任何一个点上去考虑，也就是在一个shading point上去考虑它的着色结果是什么。那么对于这个point所属的一个物体表面上，我们认为在一个局部的一个非常小的范围内，这个表面永远是一个平面。那么在这个平面上，我们可以定义平面的法线向量n，观测方向为shading point 到观测点的方向，也就是向量v，从point看向光源的方向叫做光源方向，记作向量l。且这三个向量都被记为单位向量，长度为1。其次，对于shading point本身的一些属性，要定义一下和物体表面相关的信息。例如它是什么颜色，它有多么亮等等（color，shininess&amp;hellip;）。&lt;/p&gt;&#xA;&lt;p&gt;补充一点是，我们考虑的shading point是在局部的，也就是不考虑是否在阴影内等和其他物体产生联系的情况。&lt;/p&gt;&#xA;&lt;h4 id=&#34;diffusion&#34;&gt;diffusion&lt;/h4&gt;&#xA;&lt;p&gt;首先考虑漫反射的情况，当光照到物体表面的某一个点时，会被均匀的反射到各个不同的方向上去。&lt;/p&gt;&#xA;&lt;img src = &#34;diffusion.png&#34; alt = &#34;漫反射&#34; /&gt;&#xD;&#xA;&lt;p&gt;并且对于光线的不同入射角度，光的强度也会发生变化。总的来说，一个漫反射的部分单位面积会接收到多少光和光照方向与法线方向形成夹角的余弦值成正比。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图形学笔记丨06 Rasterization 2（Antialiasing）</title>
      <link>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A806-rasterization-2antialiasing/</link>
      <pubDate>Thu, 14 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%A806-rasterization-2antialiasing/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&lt;s&gt;在我开始写博客之前我已经学完了前面的五次课，并且完成了作业0和作业1。在我简单回顾之后，我本来是想把这一块补上的，因为前几节课还是有很多需要记住的点的。但是犹豫再三，我还是放弃了，因为还是那句话，这意味着我要补上前面的很多内容，会带来很多重复的工作量让我心生退却。不过我也给自己立了一个 Flag ，如果我下一次用到相关知识，或者说复习的时候忘记了，我就把它加上，这样它对我来说就是一个更加有意义的工作量了，我会更容易接受。&lt;/s&gt;&lt;/p&gt;&#xA;&lt;p&gt;课程内容来源：&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://www.bilibili.com/video/BV1X7411F744?spm_id_from=333.788.videopod.episodes&amp;vd_source=1837baf7c46a027b7e27b4ab7174fb85&#34; target=&#34;_blank&#34;&gt;GAMES101-现代计算机图形学入门-闫令琪&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;antialiasing&#34;&gt;Antialiasing&lt;/h2&gt;&#xA;&lt;img src = &#34;jaggie.png&#34; alt = &#34;锯齿&#34; /&gt;&#xD;&#xA;&lt;p&gt;锯齿是一种图片走样的结果，比如图中本来是一个三角形，但经过测试像素中心点在三角形内部还是外部并且将在内部的像素填上颜色的方式呈现在屏幕上时，就发生了锯齿的现象。所以我们要采用反走样技术来解决这种现象。&lt;/p&gt;&#xA;&lt;p&gt;在这之前我们先看看在计算机图形学中的采样。&lt;/p&gt;&#xA;&lt;p&gt;Rasterization = Sample 2D Positions，栅格化也就是采样2D平面内的位置&lt;/p&gt;&#xA;&lt;img src = &#34;rasterization.png&#34; alt = &#34;栅格化&#34; /&gt;&#xD;&#xA;&lt;p&gt;Photograph = Sample Image Sensor Plane，照片也就是采样图像传感器平面&lt;/p&gt;&#xA;&lt;img src = &#34;photograph.png&#34; alt = &#34;照片采样&#34; /&gt;&#xD;&#xA;&lt;p&gt;Video = Sample Time，视频也就是对时间采样，每隔一定时间采样一次&lt;/p&gt;&#xA;&lt;img src = &#34;video.png&#34; alt = &#34;视频采样&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;sampling-artifactserrors--mistakes--inaccuraciesin-computer-graphics&#34;&gt;Sampling Artifacts（Errors / Mistakes / Inaccuracies）in Computer Graphics&lt;/h3&gt;&#xA;&lt;p&gt;计算机图形学中由采样带来的“瑕疵”有很多，包括锯齿、摩尔纹、车轮效应。&lt;/p&gt;&#xA;&lt;p&gt;Jaggies（Staircase Pattern）：锯齿，也被称作楼梯模式&lt;/p&gt;&#xA;&lt;img src = &#34;jaggies.png&#34; alt = &#34;锯齿&#34; /&gt;&#xD;&#xA;&lt;p&gt;Moiré Patterns in Imaging：摩尔纹&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
