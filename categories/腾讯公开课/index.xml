<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>腾讯公开课 on 子春廿一</title>
    <link>http://localhost:1313/categories/%E8%85%BE%E8%AE%AF%E5%85%AC%E5%BC%80%E8%AF%BE/</link>
    <description>Recent content in 腾讯公开课 on 子春廿一</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Sun, 24 Nov 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/%E8%85%BE%E8%AE%AF%E5%85%AC%E5%BC%80%E8%AF%BE/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>24腾讯游戏客户端公开课作业丨01</title>
      <link>http://localhost:1313/posts/24%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E4%BD%9C%E4%B8%9A%E4%B8%A801/</link>
      <pubDate>Sun, 24 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/24%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E4%BD%9C%E4%B8%9A%E4%B8%A801/</guid>
      <description>&lt;h2 id=&#34;作业内容&#34;&gt;作业内容&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;编译UE5源码&lt;/li&gt;&#xA;&lt;li&gt;Androiod打包&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;过程&#34;&gt;过程&lt;/h2&gt;&#xA;&lt;p&gt;首先，需要安装 git ，安装的链接参考是 &lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://blog.csdn.net/weixin_42242910/article/details/136297201&#34; target=&#34;_blank&#34;&gt;windows安装git&lt;/a&gt; 。然后需要在你想存储的地方打开 git bash ，进行 git clone 。克隆 Unreal Engine 的官方源码需要一个 GitHub 账号，并且要和 Epic 账号绑定，才能加入 group 有权限下载源码，这一点可以参考官方的 &lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://www.epicgames.com/help/zh-CN/c-Category_EpicAccount/c-ConnectedAccounts/unreal-enginegithub-a000084938&#34; target=&#34;_blank&#34;&gt;help 文档页面&lt;/a&gt;。完成这一步之后需要在你的 git bash 界面设置你的账户，一种是通过修改配置文件，利用以下两条语句配置你的 Git 账号信息：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git config --global user.name &amp;#34;your-github-username&amp;#34;&#xD;&#xA;git config --global user.email &amp;#34;your-email@example.com&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后利用 &lt;code&gt;git clone https://github.com/EpicGames/UnrealEngine.git&lt;/code&gt;在 git bash 中进行下载。&lt;/p&gt;&#xA;&lt;p&gt;其次可以通过生成 ssh 密钥，首先在 Git Bash 中生成 SSH 密钥：&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;ssh-keygen -t rsa -b 4096 -C &amp;quot;your-email@example.com&amp;quot;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;通常在你的当前用户的 C:\Users\admin\.ssh下的id_rsa.pub 文件中，复制公钥内容并将其添加到 GitHub 的 SSH Keys 设置中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>2024腾讯游戏客户端公开课笔试</title>
      <link>http://localhost:1313/posts/2024%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AF%95/</link>
      <pubDate>Sun, 10 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2024%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AF%95/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;因为周六要打工没空，所以选择参加了11.10号的场次，在参加之前我除了知道这两场题目会不同之外，我还发现11.9对于编程语言限制的描述是&lt;div style=&#34;border-left:4px solid green;padding-left:10px;&#34;&gt;&lt;font color=#686868&gt;1道题目可使用：[C, C#, C++, Java, Python, Python 3] 1道题目可使用：[C++] 1道题目可使用：[C, C#, C++, Go, Groovy, Java, Javascript, Kotlin, Matlab, Object C, Pascal, Php, Pypy2, Pypy3, Python, Python 3, R, Ruby, Rust, Scala, Swift, Typescript]&lt;/font&gt;&lt;/div&gt;而11.10的表述是&lt;div style=&#34;border-left:4px solid green;padding-left:10px;&#34;&gt;&lt;font color=#686868&gt;2道题目可使用：[C, C++] 1道题目可使用：[C#, C++] 在线作答编程&lt;/font&gt;&lt;/div&gt;不知道会不会差别很大，大致回忆一下题目的内容，记不清的内容我会用自己理解的东西代替描述。&lt;/p&gt;&#xA;&lt;h2 id=&#34;q1&#34;&gt;Q1&lt;/h2&gt;&#xA;&lt;p&gt;第一道题是定义了一个完美平方数组，他会给你字符串的长度，以及相对应的由01组成的字符串，如果他能形成一个m * n的矩阵，满足外部都是1，中间都是0，就是完美数组，且当m == n的时候，是完美平方数组。输入的格式先是字符串的个数，然后接受每个字符串的长度和内容，满足完美平方数组的打印Yes，否则打印No。&lt;/p&gt;&#xA;&lt;h2 id=&#34;q2&#34;&gt;Q2&lt;/h2&gt;&#xA;&lt;p&gt;第二道题是会给出一个表达式，然后你要做的是解析表达式，解析成功的打印表达式的最终值，解析失败则打印XXX。要求解析的只有+-*/，且输入可能会有空格。&lt;/p&gt;&#xA;&lt;h2 id=&#34;q3&#34;&gt;Q3&lt;/h2&gt;&#xA;&lt;p&gt;第三道题是给定一个包含非负整数的 &lt;code&gt;m x n&lt;/code&gt; 矩阵 ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。且元素为0时，表示不可以通过。说明：每次只能向下或者向右移动一步。&lt;/p&gt;&#xA;&lt;h2 id=&#34;我的思路&#34;&gt;我的思路&lt;/h2&gt;&#xA;&lt;p&gt;第一题的话我是先判断是否满足平方，然后再简单的遍历每一个字符串的元素是否满足0，1的条件。&lt;/p&gt;&#xA;&lt;p&gt;第二题用了两个栈来解析，第一个栈对于数字操作，第二个对于op符操作，当遇到数字进数字栈，遇到符号且符号栈为空时进栈，栈不为空时，根据符号的优先级进行出栈以及计算的判断。不过中间会有一些细节的处理。&lt;/p&gt;&#xA;&lt;p&gt;第三题是很常见的dp题，因为某一点的最短路径只会来自于他的左边和上边，选择短的加上自己则是最短，所以可以划分为子问题。不过这里要对于0做特殊处理，我的处理是将此处的dp值设为int的最大值。随后循环生成打印即可。&lt;/p&gt;&#xA;&lt;p&gt;代码如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;style=&#34;position:relative;&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34; id = &#34;code1&#34;&gt;#include &amp;ltalgorithm&amp;gt&#xD;&#xA;#include &amp;ltiostream&amp;gt&#xD;&#xA;using namespace std;&#xD;&#xA;int main() {&#xD;&#xA;&#x9;int n,m;&#xD;&#xA;&#x9;cin &gt;&gt; m &gt;&gt; n;&#xD;&#xA;&#x9;int arr[100][100];&#xD;&#xA;&#x9;for(int i = 0 ;i &lt; m; i++){&#xD;&#xA;&#x9;for(int j = 0; j &lt; n; j++){&#xD;&#xA;&#x9;&#x9;cin &gt;&gt; arr[i][j];&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    int dp[100][100] = {0};&#xD;&#xA;    dp[0][0] = arr[0][0];&#xD;&#xA;    for(int i = 1 ;i &lt; m; i++){&#xD;&#xA;        if(arr[i][0] == 0){&#xD;&#xA;            while(i &lt; m){&#xD;&#xA;                dp[i][0] = INT32_MAX;&#xD;&#xA;                i++;&#xD;&#xA;            }&#xD;&#xA;        }else{&#xD;&#xA;            dp[i][0] = dp[i - 1][0] + arr[i][0];&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    for(int i = 1 ;i &lt; n; i++){&#xD;&#xA;        if(arr[0][i] == 0){&#xD;&#xA;            while(i &lt; n){&#xD;&#xA;                dp[0][i] = INT32_MAX;&#xD;&#xA;                i++;&#xD;&#xA;            }&#xD;&#xA;        }else {&#xD;&#xA;            dp[0][i] = dp[0][i - 1] + arr[0][i];&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    for(int i = 1 ;i &lt; m; i++){&#xD;&#xA;        for(int j = 1; j &lt; n; j++){&#xD;&#xA;            if(arr[i][j] == 0){&#xD;&#xA;                dp[i][j] = INT32_MAX;&#xD;&#xA;            }else {&#xD;&#xA;                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + arr[i][j];&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    printf(&#34;%d&#34;,dp[m - 1][n - 1]);&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;&lt;button class=&#34;copy-button&#34; data-clipboard-target=&#34;#code1&#34;&gt;Copy&lt;/button&gt;&#xD;&#xA;&lt;/div&gt;&#xD;&#xA;&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;&#xA;&lt;p&gt;只有第三题的代码的原因是，我没有在本地idea存储每一题的答案，所以只剩下最后的，就顺便贴上了。对于这次笔试，我得了60分，最后一题没有AC，可能还是因为我平常不会经常去有目的性的去刷题，所以做题目的速度比较慢，导致最后只差一点点但是来不及写完了。我做题的过程首先就是思路的产生，再到将思路转化为实践，最后是实践中的边界情况讨论。第一题我就写了半个小时，要花费很多时间去找到出错的边界。第二题也是一样的情况，写完第二题只剩半个小时了。而第三题一开始我甚至没看到障碍的情况，导致虽然找到了问题的核心，但距离写出题目浪费了很多时间，最后找到原因之后也已经来不及了，虽然最后还是花了几分钟把它写完了，不过算是有点可惜。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
