<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>软件分析 on 桐木</title>
    <link>http://localhost:1313/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/</link>
    <description>Recent content in 软件分析 on 桐木</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Mon, 11 Nov 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>软件分析学习笔记丨08指针分析</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A808%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 11 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A808%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;CHA存在一些问题,会导致不精确的常量分析，如下图所示：&lt;/p&gt;&#xA;&lt;img src = &#34;problem.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;由于CHA只考虑类名，不考虑上下文，所以会追踪到三个目标方法，导致&lt;code&gt;x = NAC&lt;/code&gt;，但实际上调用的只是其中一个，这是不精确的，结果应该是&lt;code&gt;x = 1&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction-to-pointer-analysis&#34;&gt;Introduction to Pointer Analysis&lt;/h2&gt;&#xA;&lt;p&gt;指针分析是一个基础性的静态分析，计算指针可以指向的内存位置。对于面向对象（侧重于Java）的程序。计算指针（变量或字段）可以指向的对象。指针分析被看作may-analysis，会过度计算指针可以指向的对象集合，即“指针可能指向哪些对象？”。&lt;/p&gt;&#xA;&lt;img src = &#34;example.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;如上图例子所示，指针分析就是将一个输入的程序，输出为指针和对象之间的指向关系。&lt;/p&gt;&#xA;&lt;p&gt;Pointer Analysis and Alias Analysis是两个密切但不相关的概念&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;指针分析：指针可以指向哪些对象？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;别名分析：两个指针可以指向同一个对象吗？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果两个指针（比如 p 和 q）引用同一个对象，那么 p 和 q 之间就是别名的关系。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p = new C();&#xD;&#xA;q = p;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;别名的信息是可以根据指针分析推导出来的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;applications-of-pointer-analysis&#34;&gt;Applications of Pointer Analysis&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Fundamental information&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Call graph, aliases, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Compiler optimization&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Virtual call inlining, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Bug detection&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Null pointer detection, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Security analysis&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Information flow analysis, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;key-factors-of-pointer-analysis&#34;&gt;Key Factors of Pointer Analysis&lt;/h2&gt;&#xA;&lt;p&gt;指针分析是一个复杂的系统，影响系统精度和效率的因素很多&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨07过程间分析</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A807%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A807%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;因为上周三忙着做团支书的工作以及各种其他事情，课上没有仔细的听，所以之后再花时间重新看b站的视频课程。顺便就此机会准备后面的课都通过视频的形式来学习了。这门课还是在观看视频的时候反复理解和思考才是更高效的，即使我之前会线下去上课，回来之后还是有一些地方要自己好好研究的。所以后续以这种形式既不会错过知识内容，也可以增加我的效率。&lt;/p&gt;&#xA;&lt;p&gt;从这节课开始就是从谭添老师开始上了，前面听说从这一部分开始会有一些动态的分析，而且难度也会开始变得更高。针对过程间分析我们要了解的主要有 Call Graph Construction（ CHA ）、Interprocedural Control-Flow Graph 和 Interprocedural Data-Flow Analysis。&lt;/p&gt;&#xA;&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;过程内分析过于保守，假设调用后都不是常量，丢失了精度。所以我们需要过程间分析，首先就需要调用图，来得到调用边（Call edges）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;call-graph-construction-cha-&#34;&gt;Call Graph Construction（ CHA ）&lt;/h2&gt;&#xA;&lt;p&gt;一个调用图是一个从 call-sites 到目标方法的调用边的集合。&lt;/p&gt;&#xA;&lt;img src=&#34;call-graph.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;本课程主要对 OOPLs 构建调用图(focus on Java)，这节课会学习Class hierarchy analysis（ CHA ），下节课会学习Pointer analysis（k-CFA）。&lt;/p&gt;&#xA;&lt;img src=&#34;1.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;越往上速度越快，越往下精度越高。&lt;/p&gt;&#xA;&lt;p&gt;了解JAVA中的call：&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;thead&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;th&gt;&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Static call&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Special call&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Virtual call&lt;/th&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/thead&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Instruction&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokestatic&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokespecial&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokeinterface&lt;br&gt;invokevirtual&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Receiver objects&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;×无实例&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;√有实例&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;√有实例&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Target methods&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Static methods (静态方法)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Constructors (构造函数)&lt;br&gt;&lt;strong&gt;·&lt;/strong&gt;Private instance methods (类自己的私有方法)&lt;br&gt;&lt;strong&gt;·&lt;/strong&gt;Superclass instance methods (父类的实例方法)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Other instance methods (其他实例方法)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;# Target methods 个数&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;1&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;1&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;≥1 (polymorphism) 多态&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Determinacy 确定时机&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Compile-time (编译时)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Compile-time (编译时)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Run-time (运行时)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;p&gt;构造调用图的关键在于处理virtual call，其中关键的一个步骤叫做Method Dispatch，基于：&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A3</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a3/</link>
      <pubDate>Wed, 06 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a3/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;因为开始写博客的时间已经完成了前两次的实验，所以也不打算重新补写前两次的实验笔记了。如果增加这个工作量我肯定会对写博客产生抵触心理，因为我补充了这个那我后续在其他方面不能不补充厚此薄彼吧，这样一下子积压了大量需要补充的内容压力过大会导致我直接化身怯战蜥蜴——放弃。&lt;/p&gt;&#xA;&lt;p&gt;作业3：死代码检测，并不是我们上课学习的内容，但是通过组合我前两次作业中实现的分析方法：&lt;strong&gt;活跃变量分析&lt;/strong&gt;和&lt;strong&gt;常量传播&lt;/strong&gt;，可以实现一个Java的死代码检测算法。&lt;/p&gt;&#xA;&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa3.html&#34; target=&#34;_blank&#34;&gt;作业 3：死代码检测 | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;死代码检测介绍&#34;&gt;死代码检测介绍&lt;/h2&gt;&#xA;&lt;p&gt;死代码指的是程序中不可达的（unreachable）代码（即不会被执行的代码），或者是执行结果永远不会被其他计算过程用到的代码。去除死代码可以在不影响程序输出的前提下简化程序、提高效率。我们在这次实验中考虑两种死代码：&lt;strong&gt;不可达代码&lt;/strong&gt;（unreachable code）和&lt;strong&gt;无用赋值&lt;/strong&gt;（unreachable code）。这好像正好分别对应了常量传播和活跃变量分析。&lt;/p&gt;&#xA;&lt;h3 id=&#34;不可达代码&#34;&gt;不可达代码&lt;/h3&gt;&#xA;&lt;p&gt;一个程序中永远不可能被执行的代码被称为不可达代码。我们考虑两种不可达代码：&lt;strong&gt;控制流不可达代码&lt;/strong&gt;（control-flow unreachable code）和&lt;strong&gt;分支不可达代码&lt;/strong&gt;（unreachable branch）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;控制流不可达代码&lt;/strong&gt;：在一个方法中，如果不存在从程序入口到达某一段代码的控制流路径，那么这一段代码就是控制流不可达的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：利用所在方法的控制流图（CFG，即 control-flow graph）检测出来。我们只需要从方法入口开始，遍历 CFG 并标记可达语句。当遍历结束时，那些没有被标记的语句就是&lt;strong&gt;控制流不可达&lt;/strong&gt;的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;分支不可达代码&lt;/strong&gt;：在 Java 中有两种分支语句：if 语句和 switch 语句。它们可能会导致分支不可达代码的出现。&lt;/p&gt;&#xA;&lt;p&gt;对于一个 if 语句，如果它的条件值（通过常量传播得知）是一个常数，那么无论程序怎么执行，它两个分支中的其中一个分支都不会被走到。这样的分支被称为&lt;strong&gt;不可达分支&lt;/strong&gt;。该分支下的代码也因此是不可达的，被称为分支不可达代码。&lt;/p&gt;&#xA;&lt;p&gt;对于一个 switch 语句，如果它的条件值是一个常数，那么不符合条件值的 case 分支就&lt;strong&gt;可能&lt;/strong&gt;是不可达的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：为了检测分支不可达代码，我们需要预先对被检测代码应用常量传播分析，通过它来告诉我们条件值是否为常量，然后在遍历 CFG 时，我们不进入相应的不可达分支。&lt;/p&gt;&#xA;&lt;h3 id=&#34;无用赋值&#34;&gt;无用赋值&lt;/h3&gt;&#xA;&lt;p&gt;一个局部变量在一条语句中被赋值，但再也没有被该语句后面的语句读取，这样的变量和语句分别被称为无用变量（dead variable，与活跃变量 live variable 相对）和无用赋值。无用赋值不会影响程序的输出，因而可以被去除。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：为了检测无用赋值，我们需要预先对被检测代码施用活跃变量分析。对于一个赋值语句，如果它等号左侧的变量（LHS 变量）是一个无用变量（换句话说，not live），那么我们可以把它标记为一个无用赋值。&lt;/p&gt;&#xA;&lt;p&gt;但需要注意的是，以上讨论有一种例外情况：有时即使等号左边的变量 &lt;code&gt;x&lt;/code&gt; 是无用变量，它所属的赋值语句 &lt;code&gt;x = expr&lt;/code&gt; 也不能被去除，因为右边的表达式 &lt;code&gt;expr&lt;/code&gt; 可能带有某些副作用。例如，当 &lt;code&gt;expr&lt;/code&gt; 是一个方法调用（&lt;code&gt;x = m()&lt;/code&gt;）时，它就有可能带有副作用，可能在m()中改变了某些值。对于这种情况，作业提供了一个 API 供检查等号右边的表达式是否可能带有副作用。如果带有副作用，那么为了保证 safety，即使 &lt;code&gt;x&lt;/code&gt; 不是一个活跃变量，也不应该把这个赋值语句标记为死代码。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
