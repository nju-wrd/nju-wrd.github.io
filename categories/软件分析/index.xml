<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>软件分析 on 子春廿一</title>
    <link>http://localhost:1313/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/</link>
    <description>Recent content in 软件分析 on 子春廿一</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Fri, 20 Dec 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>软件分析实验笔记丨A8</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a8/</link>
      <pubDate>Fri, 20 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a8/</guid>
      <description>&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa8.html&#34; target=&#34;_blank&#34;&gt;作业 8：污点分析&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业目标&#34;&gt;作业目标&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为 Java 实现污点分析。&lt;/li&gt;&#xA;&lt;li&gt;最后一次作业！ヾ(≧▽≦*)o&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在这次作业中，我们需要基于第 6 次作业实现的上下文敏感的指针分析来为 Java 实现污点分析（taint analysis）。为了让此次的污点分析不仅仅是个玩具，我们会在这次作业中学习一个叫做&lt;strong&gt;污点传播&lt;/strong&gt;（taint transfer）的技术，这样实现的污点分析就能够应用到生产实践中检测安全漏洞了。此外，taie 也提供了可配置的污点分析框架，帮助方便地设置污点分析中所需要的诸如 sources、sinks 等数据。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实现污点分析&#34;&gt;实现污点分析&lt;/h2&gt;&#xA;&lt;h3 id=&#34;分析范围&#34;&gt;分析范围&lt;/h3&gt;&#xA;&lt;p&gt;在这一小节中，我们来定义一下在这次作业中所需要实现的污点分析。和第 13 讲介绍的污点分析一样，我们会把一些特定的方法（通常是产生数据的 API）视作 taint sources，调用这些方法的语句会返回污点数据；为了和指针分析中的对象对应，这些污点数据也被叫做&lt;strong&gt;污点对象&lt;/strong&gt;（taint objects）。我们也把一些特定方法的某些参数视作 taint sinks。此外，为了达到更高的精度，需要实现一个&lt;strong&gt;上下文敏感的&lt;/strong&gt;污点分析。作为参考，已经写好了处理 sources 和 sinks 的规则：&lt;/p&gt;&#xA;&lt;image src = &#34;rule.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里，Sources 是二元组 ⟨m,u⟩ 的集合，其中 m 表示一个被视作 source 的方法的签名，而 u 是该方法返回的污点对象的类型。我们用 t&lt;sub&gt;l&lt;/sub&gt;&lt;sup&gt;u&lt;/sup&gt; 来表示一个污点对象，其中 u 是这个对象的类型，l 表示创建这个对象的调用点（call site）。简单起见，只需要使用&lt;strong&gt;空上下文&lt;/strong&gt;作为污点对象的堆上下文（heap context）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;污点传播&lt;/strong&gt;&lt;/em&gt;. 污点分析和指针分析看起来很相似，因为他们本质上都在跟踪程序中数据的流动——指针分析跟踪的是抽象的对象，污点分析跟踪的是污点对象。但是他们又有些微妙的不同：污点分析中的污点是一个更加抽象的概念——它与数据的&lt;strong&gt;内容&lt;/strong&gt;相关联，因此它可以在不同的对象之间&lt;strong&gt;传播&lt;/strong&gt;。我们把这样的现象叫做污点传播（taint transfer）。下面我们通过一个例子来学习这个概念：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;style=&#34;position:relative;&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34; id = &#34;code1&#34;&gt;String taint = getSecret(); // source&#xD;&#xA;StringBuilder sb = new StringBuilder();&#xD;&#xA;sb.append(&#34;abc&#34;);&#xD;&#xA;sb.append(taint); // taint is transferred to sb&#xD;&#xA;sb.append(&#34;xyz&#34;);&#xD;&#xA;String s = sb.toString(); // taint is transferred to s&#xD;&#xA;leak(s); // sink&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;  &lt;button class=&#34;copy-button&#34; data-clipboard-target=&#34;#code1&#34;&gt;Copy&lt;/button&gt;&#xD;&#xA;  &lt;/div&gt;&#xD;&#xA;&lt;p&gt;假设我们把 getSecret() 和 leak() 分别视作 source 和 sink，那么在这个例子中，第 1 行的代码首先通过方法调用获得了一份字符串类型的秘密数据（即污点对象）并把它保存在了变量 taint 中。然后，这份秘密数据会经过两次污点传播流入到第 7 行的 sink 中：&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨14以Datalog为基础的程序分析</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A814%E4%BB%A5datalog%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 18 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A814%E4%BB%A5datalog%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;对于同样的目标：从一组人当中选择出成人&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Imperative（命令式语言）：如何做&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;style=&#34;position:relative;&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34; id = &#34;code1&#34;&gt;Set&lt;Person&gt; selectAdults(Set&lt;Person&gt; persons) {&#xD;&#xA;&#x9;Set&lt;Person&gt; result = new HashSet&lt;&gt;();&#xD;&#xA;&#x9;for (Person person : persons)&#xD;&#xA;&#x9;&#x9;if (person.getAge() &gt;= 18)&#xD;&#xA;&#x9;&#x9;&#x9;result.add(person);&#xD;&#xA;&#x9;return result;&#xD;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;  &lt;button class=&#34;copy-button&#34; data-clipboard-target=&#34;#code1&#34;&gt;Copy&lt;/button&gt;&#xD;&#xA;  &lt;/div&gt;&#xD;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Declarative（声明式语言）：做什么&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;style=&#34;position:relative;&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34; id = &#34;code2&#34;&gt;SELECT * FROM Persons WHERE Age &gt;= 18;&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;  &lt;button class=&#34;copy-button&#34; data-clipboard-target=&#34;#code2&#34;&gt;Copy&lt;/button&gt;&#xD;&#xA;  &lt;/div&gt;&#xD;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;可以看出来声明式语言要比命令式语言简单很多。&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction-to-datalog&#34;&gt;Introduction to Datalog&lt;/h2&gt;&#xA;&lt;h3 id=&#34;datalog&#34;&gt;Datalog&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Datalog 是一种声明性逻辑编程语言，是 Prolog 的子集。&lt;/li&gt;&#xA;&lt;li&gt;它作为一种数据库语言出现（1980 年代中期）&lt;/li&gt;&#xA;&lt;li&gt;现在它有多种应用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序分析&lt;/li&gt;&#xA;&lt;li&gt;声明式网络&lt;/li&gt;&#xA;&lt;li&gt;大数据&lt;/li&gt;&#xA;&lt;li&gt;云计算&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Datalog = &lt;span style=&#34;color: #FF0000;&#34;&gt;Data&lt;/span&gt; + &lt;span style=&#34;color: #FF0000;&#34;&gt;Log&lt;/span&gt;ic（and, or, not）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无副作用&lt;/li&gt;&#xA;&lt;li&gt;无控制流&lt;/li&gt;&#xA;&lt;li&gt;无函数&lt;/li&gt;&#xA;&lt;li&gt;非图灵完备&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;predicates谓词&#34;&gt;Predicates（谓词）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在 Datalog 中，谓词 （relation） 是一组语句&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨13针对安全方面的静态分析</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A813%E9%92%88%E5%AF%B9%E5%AE%89%E5%85%A8%E6%96%B9%E9%9D%A2%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 16 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A813%E9%92%88%E5%AF%B9%E5%AE%89%E5%85%A8%E6%96%B9%E9%9D%A2%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;computer-security&#34;&gt;Computer Security&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Goals&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dependability&lt;/li&gt;&#xA;&lt;li&gt;Data safety&lt;/li&gt;&#xA;&lt;li&gt;…&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Adversaries&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Crackers&lt;/li&gt;&#xA;&lt;li&gt;Cyber attackers&lt;/li&gt;&#xA;&lt;li&gt;…&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;causes-of-exploited-vulnerabilities造成已被利用的漏洞的原因&#34;&gt;Causes of exploited vulnerabilities（造成已被利用的漏洞的原因）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Injection errors&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Information leaks&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这两点其实就是本节课要解决的问题&lt;/p&gt;&#xA;&lt;h2 id=&#34;information-flow-security&#34;&gt;Information Flow Security&lt;/h2&gt;&#xA;&lt;p&gt;我们要防止不必要的信息流动 保护信息安全&lt;/p&gt;&#xA;&lt;h3 id=&#34;access-control-vs-information-flow-security&#34;&gt;Access Control vs. Information Flow Security&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;访问控制（保护敏感数据的标准方法）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检查程序是否具有访问某些信息的权限&lt;/li&gt;&#xA;&lt;li&gt;关注信息的访问方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;信息流安全（端到端）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;跟踪信息如何流经程序，以确保程序安全地处理信息&lt;/li&gt;&#xA;&lt;li&gt;关注信息的传播方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;information-flow&#34;&gt;Information Flow&lt;/h3&gt;&#xA;&lt;p&gt;信息流：如果变量 x 中的信息被转移到变量 y，那么存在信息流 y → x&lt;/p&gt;&#xA;&lt;img src = &#34;example.png&#34; alt = &#34;示例&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;information-flow-security-1&#34;&gt;Information Flow Security&lt;/h3&gt;&#xA;&lt;p&gt;将信息流与安全联系起来&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将程序变量分类为不同的安全级别&lt;/li&gt;&#xA;&lt;li&gt;指定这些级别之间允许的流，即信息流策略&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;security-levels-classes&#34;&gt;Security Levels (Classes)&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;最基本的模型是两级策略，即一个变量被分为两个安全级别之一：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;H，意为高安全性、秘密信息&lt;/li&gt;&#xA;&lt;li&gt;L，表示低安全性，公共可观察信息&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;h = getPassword(); // h is high security&lt;/li&gt;&#xA;&lt;li&gt;broadcast(l);           // l is low security&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;安全级别可以建模为 lattice*&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A7</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a7/</link>
      <pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a7/</guid>
      <description>&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa7.html&#34; target=&#34;_blank&#34;&gt;作业 7：Alias-Aware 的过程间常量传播&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业目标&#34;&gt;作业目标&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为 Java 实现一个 alias-aware 的过程间常量传播分析&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在本次作业中，我们需要在作业4的基础上，进一步提高常量传播的精度。具体而言，我们需要借助之前作业中实现的指针分析，根据指针分析结果来得到程序中的别名（alias）信息，并用这一信息来在过程间常量传播中更精确地处理对象字段（field）和数组（array）。&lt;/p&gt;&#xA;&lt;p&gt;和作业4一样，常量传播中只需要考虑 int 类型的值，但在本次作业中，需要额外考虑程序中的别名，用别名信息来更精确地处理对字段和数组的存取。不过，可以忽略一些将在后续描述的情况。&lt;/p&gt;&#xA;&lt;h2 id=&#34;alias-aware的常量传播&#34;&gt;Alias-Aware的常量传播&lt;/h2&gt;&#xA;&lt;h3 id=&#34;别名&#34;&gt;别名&lt;/h3&gt;&#xA;&lt;p&gt;别名用于描述以下情况：一个内存中的数据位置可以通过不同的符号名来访问，这些指向内存中的同一位置的不同符号互为别名 。在 Java 中，对实例字段和数组的访问可以形成别名，举例来说，如果变量 x 和 y 指向相同的对象，那么 x.f 和 y.f 这两个字段访问构成了别名，因为它们实际上指向同一个字段；如果变量 a 和 b 指向同一个数组，并且 i 和 j 有相同的值，那么 a[i] 和 b[j] 这两个数组访问构成了别名，因为它们实际上指向同一个数组中的同一个位置。&lt;/p&gt;&#xA;&lt;p&gt;在别名存在的情况下，通过对一个字段/数组的访问来修改一个实例字段/数组将会同时修改与这一访问相关的所有别名值。举例来说，如果 x.f，y.f 和 z.f 互为别名，那么 store 语句 x.f = 5; 不仅将 x.f 的值修改为 5，而且同时将 y.f 和 z.f 的值设为 5。因此，为了在常量传播中精确地分析字段和数组的值，我们需要取得被分析程序的别名信息。&lt;/p&gt;&#xA;&lt;p&gt;值得注意的是，Java 中的静态字段不能拥有别名：对一个静态字段 T.f，它有唯一的符号名（即 T.f），且只能通过 T.f 被访问。由于不需要考虑别名的存在，对静态字段的处理要比对实例字段和数组的处理简单。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨11上下文敏感指针分析I</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A811%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90i/</link>
      <pubDate>Sat, 07 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A811%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90i/</guid>
      <description>&lt;h2 id=&#34;problem-of-context-insensitive--pointer-analysis&#34;&gt;Problem of Context-Insensitive  Pointer Analysis&lt;/h2&gt;&#xA;&lt;image src = &#34;problem.png&#34; alt = &#34;存在的问题&#34;/&gt;&#xD;&#xA;&lt;p&gt;在 CI（Content Insensitive）中，处理 x.get() 时，因为 x 是Number类型，所以这里会 Dispatch 到两个方法，并且将两条边都加入 CG 中。但是，其实可以看到有一条边是明显冗余的，在实际执行中并不是 x 的指向目标，这在常量传播分析当中会直接导致 i 成为一个 NAC 。&lt;/p&gt;&#xA;&lt;image src = &#34;via.png&#34; alt = &#34;改变后&#34;/&gt;&#xD;&#xA;&lt;p&gt;采用 CS（Content Sensitive）后，由于对上下文敏感了，所以现在对于 id(n) 的调用，分为两次去分析。&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;再简单总结一下 CI 带来的imprecision 的原因。&lt;/p&gt;&#xA;&lt;p&gt;在动态执行中，一个方法可能在不同的调用上下文中被多次调用，而在不同调用上下文中，该方法中的变量可能指向不同的对象，在 CI 指针分析中，不同上下文的对象被混合并传播到程序的其它部分（通过返回值或副作用），导致虚假的数据流。&lt;/p&gt;&#xA;&lt;p&gt;上下文敏感性模型通过区分不同上下文的不同数据流来调用上下文，以提高精度。最古老且最著名的上下文敏感性策略是调用点敏感性（ call-string ）：每个方法上下文都表示为调用点的链，即方法的一个调用点、；调用者的一个调用点；调用者的调用者的一个调用点等。&lt;/p&gt;&#xA;&lt;image src = &#34;example.png&#34; alt = &#34;例子&#34;/&gt;&#xD;&#xA;&lt;p&gt;在 CS 中，这里的方法 id(Number)有两个上下文：[1] 和 [2]。&lt;/p&gt;&#xA;&lt;h3 id=&#34;cloning-based-context-sensitivity&#34;&gt;Cloning-Based Context Sensitivity&lt;/h3&gt;&#xA;&lt;p&gt;基于克隆的上下文敏感分析是最直接的方法来实现上下文敏感性。在基于克隆的上下文相关指针分析中，每种方法都由一个或多个上下文来限定，变量也由上下文（从它们声明的函数继承而来）进行限定，本质上，每种方法和其变量都被克隆，每个上下文一个克隆。&lt;/p&gt;&#xA;&lt;h3 id=&#34;context-sensitive-heap&#34;&gt;Context-Sensitive Heap&lt;/h3&gt;&#xA;&lt;p&gt;OO 程序（例如 Java ）通常是堆密集型，在实践中，为了提高精度，对堆抽象也应用上下文敏感性，抽象对象也由上下文（称为堆上下文）限定，最常见的做法是从分配对象的方法中继承上下文。上下文敏感的堆抽象在分配站点抽象之上提供了一个更细粒度的堆模型。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨12上下文敏感指针分析II</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A812%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90ii/</link>
      <pubDate>Sat, 07 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A812%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90ii/</guid>
      <description>&lt;h2 id=&#34;context-sensitive-pointer-analysis-algorithms&#34;&gt;Context Sensitive Pointer Analysis: Algorithms&lt;/h2&gt;&#xA;&lt;h3 id=&#34;how-to-implement-context-sensitive-pointer-analysis&#34;&gt;How to Implement Context-Sensitive Pointer Analysis&lt;/h3&gt;&#xA;&lt;img src = &#34;dependent.png&#34; alt = &#34;相互依赖的过程&#34; /&gt;&#xD;&#xA;&lt;p&gt;类似于上下文无关指针分析，依旧是在构建 PFG 的同时利用 PFG 传播指针信息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;cs-pointer-analysis-algorithm&#34;&gt;C.S. Pointer Analysis: Algorithm&lt;/h3&gt;&#xA;&lt;p&gt;算法如下所示：&lt;/p&gt;&#xA;&lt;img src = &#34;algorithm.png&#34; alt = &#34;算法&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里和前面类似，主要是加上了限定的上下文，就不再赘述，对于上下文的信息，在调用规则里也有体现。&lt;/p&gt;&#xA;&lt;h2 id=&#34;context-sensitivity-variants&#34;&gt;Context Sensitivity Variants&lt;/h2&gt;&#xA;&lt;h3 id=&#34;call-site-sensitivity&#34;&gt;Call-Site Sensitivity&lt;/h3&gt;&#xA;&lt;img src = &#34;variant.png&#34; alt = &#34;select&#34; /&gt;&#xD;&#xA;&lt;p&gt;Select 算法会根据三个参数来确定，分别是调用者上下文，调用点，有堆上下文的接收对象。&lt;/p&gt;&#xA;&lt;p&gt;上下文无关可以被视为 C.S.分析框架中上下文敏感性的一个特例：Select(,,) = []&lt;/p&gt;&#xA;&lt;p&gt;每个上下文都由一系列调用点（调用链）组成，在方法调用时，将调用位置追加到调用者上下文中作为被调用者上下文，本质上是对调用栈的抽象。&lt;/p&gt;&#xA;&lt;img src = &#34;call-string.png&#34; alt = &#34;call-string&#34; /&gt;&#xD;&#xA;&lt;p&gt;这个方法存在一定的问题，看下图例子：&lt;/p&gt;&#xA;&lt;img src = &#34;example.png&#34; alt = &#34;call-string&#34; /&gt;&#xD;&#xA;&lt;p&gt;可以看到在函数之间循环的调用时，会导致调用链无限变长。所以这里的 k 其实就是用于对上下文抽象的限制。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A6</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a6/</link>
      <pubDate>Sat, 07 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a6/</guid>
      <description>&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa6.html&#34; target=&#34;_blank&#34;&gt;作业 6：上下文敏感的指针分析&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业目标&#34;&gt;作业目标&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为 Java 实现一个上下文敏感的指针分析框架。&lt;/li&gt;&#xA;&lt;li&gt;作为指针分析的一部分，随着指针分析一起实现调用图（call graph）构建。&lt;/li&gt;&#xA;&lt;li&gt;实现几种常见的上下文敏感策略（context sensitivity variants）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;新的分析规则&#34;&gt;新的分析规则&lt;/h2&gt;&#xA;&lt;p&gt;在这一节中，我们引入与上次实验类似的新的指针分析规则来处理静态字段、数组索引和静态方法调用，主要区别在于上下文的部分&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;静态字段&lt;/strong&gt;的处理很简单：我们只需要在静态字段和变量之间传值。我们用 T.f 表示静态字段 T.f 的指针，然后定义如下规则来处理静态字段的 store 和 load：&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;thead&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;th&gt;类型&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;语句&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;规则（在上下文c下）&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;PFG 边&lt;/th&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/thead&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Static Store&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;T.f = y&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;1.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;T.f ← c:y&lt;/sub&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Static Load&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;y = T.f&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;2.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;c:y ← T.f&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;p&gt;常规指针分析不区分对不同&lt;strong&gt;数组索引&lt;/strong&gt;（位置）的 load 和 store。假设 c&amp;rsquo;:o&lt;sub&gt;i&lt;/sub&gt; 代表一个具有上下文c&amp;rsquo;的数组对象，那么我们用 c&amp;rsquo;:o&lt;sub&gt;i&lt;/sub&gt;[∗] 表示一个指向数组中所有对象的指针（无论保存在数组的什么位置）。基于这样的处理，我们定义了数组 store 和 load 的规则：&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A5</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a5/</link>
      <pubDate>Sun, 24 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a5/</guid>
      <description>&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa5.html&#34; target=&#34;_blank&#34;&gt;作业 5：非上下文敏感指针分析&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业目标&#34;&gt;作业目标&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为 Java 实现非上下文敏感的指针分析。&lt;/li&gt;&#xA;&lt;li&gt;为指针分析实现一个调用图的实时构建算法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在本次作业中，我们将在 Tai-e 上为 Java 实现一个非上下文敏感的指针分析，并在指针分析的过程中实时构建调用图。如果实现正确，该调用图会比用类层次结构分析（CHA）建立的更加精确。&lt;/p&gt;&#xA;&lt;p&gt;在本次作业中，我们将学习如何处理课上没有涉及的一些 Java 特性，即静态字段、数组和静态方法，这样我们的指针分析就可以处理 Java 中所有类型的指针了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;新的分析规则&#34;&gt;新的分析规则&lt;/h2&gt;&#xA;&lt;p&gt;在这一节中，我们引入新的指针分析规则来处理静态字段、数组索引和静态方法调用。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;静态字段&lt;/strong&gt;的处理很简单：我们只需要在静态字段和变量之间传值。我们用 T.f 表示静态字段 &lt;code&gt;T.f&lt;/code&gt; 的指针，然后定义如下规则来处理静态字段的 store 和 load：&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;thead&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;th&gt;类型&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;语句&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;规则&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;PFG 边&lt;/th&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/thead&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Static Store&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;T.f = y&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;1.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;        &lt;td&gt;T.f ← y&lt;/sub&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Static Load&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;y = T.f&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;2.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;y ← T.f&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;p&gt;常规指针分析不区分对不同&lt;strong&gt;数组索引&lt;/strong&gt;（位置）的 load 和 store。假设 o&lt;sub&gt;i&lt;/sub&gt; 代表一个数组对象，那么我们用 o&lt;sub&gt;i&lt;/sub&gt;[∗] 表示一个指向数组中所有对象的指针（无论保存在数组的什么位置）。基于这样的处理，我们定义了数组 store 和 load 的规则：&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨10指针分析基础II</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A810%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80ii/</link>
      <pubDate>Thu, 21 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A810%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80ii/</guid>
      <description>&lt;h2 id=&#34;pointer-analysis-with-method-calls&#34;&gt;Pointer Analysis with Method Calls&lt;/h2&gt;&#xA;&lt;p&gt;过程间指针分析需要调用图，在 &lt;a style=&#34;color: #0000FF;&#34; href = &#34;https://nju-wrd.github.io//posts/软件分析学习笔记丨07过程间分析/#01&#34; target=&#34;_blank&#34; &gt;07 过程间分析中&lt;/a&gt;，我们采用了 CHA 方法来构造调用图。但是它本身是不精确的，因为它在一些情况下引入虚假的调用边和指向关系。&lt;/p&gt;&#xA;&lt;p&gt;而利用指针分析的方法，会比CHA更加精确。并且这种好处对调用图和指向关系的构建都会带来更精确的好处。规则如下：&lt;/p&gt;&#xA;&lt;img src = &#34;rule.png&#34; alt = &#34;规则&#34;/&gt;&#xD;&#xA;&lt;p&gt;我们来一点一点解析这里面的符号所代表的含义。这里的 Dispatch(o&lt;sub&gt;i&lt;/sub&gt;,k) 和前面 CHA 中的本质上是一样的，它利用 receive object o&lt;sub&gt;i&lt;/sub&gt; 的类型和调用点方法的签名 k 来找到实际的调用方法 m 。m&lt;sub&gt;this&lt;/sub&gt; 代表当前找到的目标方法的 this 变量。a&lt;sub&gt;j&lt;/sub&gt; 表示调用的第 j 个参数。m&lt;sub&gt;pj&lt;/sub&gt; 表示 m 的第 j 个参数。所以为了将调用的参数对应传递给 m 的参数，会在他们之间加上 PFG 边进行指向信息的传递。&lt;/p&gt;&#xA;&lt;img src = &#34;edge.png&#34; alt = &#34;加边&#34;/&gt;&#xD;&#xA;&lt;p&gt;m&lt;sub&gt;ret&lt;/sub&gt; 代表 m 的返回值，将返回值赋给调用点的左值。&lt;/p&gt;&#xA;&lt;p&gt;这里可以思考一个问题也就是为什么我们在处理 m&lt;sub&gt;this&lt;/sub&gt; 的时候，不和参数一样直接添加 PFG Edge ？&lt;/p&gt;&#xA;&lt;img src = &#34;example.png&#34; alt = &#34;例子&#34;/&gt;&#xD;&#xA;&lt;p&gt;首先我们知道在 Java 中，this 是一个很重要的变量，方法中可能会频繁地使用 this 变量，所以 this 变量的指向信息的正确性十分重要。我们再来看上图的例子，如果我们直接引入新 PFG Edge ，会导致给方法的 this 引入虚假的指向关系。具体来说在下面的三个方法中，其实每个方法的 this 的指向的类都是声明方法的类本身。而在 x 调用foo方法的时候，如果直接引入 PFG Edge，会将 x 原来所有的指向信息都流入找到的方法的 this ，但其实最终 this 只会是其中一个，而这由具体调用到哪个方法所决定。所以为了避免给 this 引入虚假的指向信息，我们不能和参数一样直接添加 PFG Edge。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A4</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a4/</link>
      <pubDate>Wed, 13 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a4/</guid>
      <description>&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa4.html&#34; target=&#34;_blank&#34;&gt;作业 4：类层次结构分析与过程间常量传播&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业目标&#34;&gt;作业目标&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为 Java 实现一个类层次结构分析（Class Hierarchy Analysis，CHA）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;实现过程间常量传播。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;实现过程间数据流传播的 worklist 求解器。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;&#xA;&lt;h3 id=&#34;完成-chabuilder-类&#34;&gt;完成 CHABuilder 类&lt;/h3&gt;&#xA;&lt;h4 id=&#34;jmethod-dispatchjclasssubsignature&#34;&gt;JMethod dispatch(JClass,Subsignature)&lt;/h4&gt;&#xA;&lt;p&gt;该方法实现了如下图所示的 Dispatch 方法。特别地，如果找不到满足要求的方法，返回 null。&lt;/p&gt;&#xA;&lt;img src = &#34;dispatch.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里要了解三个类， JMethod 、 JClass 、 Subsignature 。其中， &lt;strong&gt;JMethod&lt;/strong&gt; 表示 Tai-e 中的 Java 方法，每个 JMethod 的实例关联着一个方法并包含该方法的各种信息。&lt;strong&gt;boolean isAbstract()&lt;/strong&gt;: 如果该 JMethod 是一个没有方法体的抽象方法，则返回 true ，否则返回 false； &lt;strong&gt;JClass&lt;/strong&gt; 表示 Tai-e 中的 Java 类，每个 JClass 的实例关联着一个类并包含该类的各种信息。&lt;strong&gt;JClass getSuperClass()&lt;/strong&gt;: 返回该类的父类。如果这个类在类层次结构的顶端（没有父类），比如 java.lang.Object，则返回 null。&lt;strong&gt;JMethod getDeclaredMethod(Subsignature)&lt;/strong&gt;: 根据子签名返回该类中声明的对应方法。如果该类中没有该子签名对应的方法，则返回 null。&lt;strong&gt;boolean isInterface()&lt;/strong&gt;: 返回该类是否是一个接口； &lt;strong&gt;Subsignature&lt;/strong&gt; 表示 Tai-e 中的子签名，一个方法的子签名只包含它的方法名和方法签名的描述符，举个例子，下面方法 foo 的子签名是：“T foo(P,Q,R)” ，而它的完整签名是：“&amp;lt;C: T foo(P,Q,R)&amp;gt;”。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨09指针分析基础I</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A809%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80i/</link>
      <pubDate>Tue, 12 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A809%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80i/</guid>
      <description>&lt;h2 id=&#34;pointer-analysis-rules&#34;&gt;Pointer Analysis: Rules&lt;/h2&gt;&#xA;&lt;h3 id=&#34;domains-and-notations域和符号&#34;&gt;Domains and Notations（域和符号）&lt;/h3&gt;&#xA;&lt;table border=&#34;0&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Variables:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;x, y ∈ V&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Fields:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;f, g ∈ F&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Objects:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;o&lt;sub&gt;i&lt;/sub&gt;, o&lt;sub&gt;j&lt;/sub&gt; ∈ O&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Instance fields:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;o&lt;sub&gt;i&lt;/sub&gt;.f, o&lt;sub&gt;j&lt;/sub&gt;.g ∈ O × F&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Pointers:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Pointer = V ⋃ (O × F)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Points-to relations:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;pt : Pointer → 𝒫𝒫(O)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;P(O) denotes the powerset of O（P(O)表示 O 的幂集）&lt;/li&gt;&#xA;&lt;li&gt;pt(p) denotes the points-to set of （pt(p) 表示 p 的指向的集合）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;how-to-implement-pointer-analysis&#34;&gt;How to Implement Pointer Analysis&lt;/h2&gt;&#xA;&lt;table border=&#34;0&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;thead&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;th&gt;Kind&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Statement&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Rule&lt;/th&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/thead&gt;&#xD;&#xA;  &lt;tbody align=&#34;center&#34;&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;New&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;i: x = new T()&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;1.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Assign&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;x = y&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;2.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Store&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;x.f = y&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;3.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Load&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;y = x.f&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;4.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;规则中上面为条件，下面为结论。&#xD;&#xA;&lt;p&gt;本质上，指针分析是在指针（变量和字段）之间传播指向信息。我们使用一个 graph 来连接相关指针，当 pt(x) 发生变化时，传播更改的部分到 x 的后继。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨08指针分析</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A808%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 11 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A808%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;CHA存在一些问题,会导致不精确的常量分析，如下图所示：&lt;/p&gt;&#xA;&lt;img src = &#34;problem.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;由于CHA只考虑类名，不考虑上下文，所以会追踪到三个目标方法，导致&lt;code&gt;x = NAC&lt;/code&gt;，但实际上调用的只是其中一个，这是不精确的，结果应该是&lt;code&gt;x = 1&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction-to-pointer-analysis&#34;&gt;Introduction to Pointer Analysis&lt;/h2&gt;&#xA;&lt;p&gt;指针分析是一个基础性的静态分析，计算指针可以指向的内存位置。对于面向对象（侧重于Java）的程序。计算指针（变量或字段）可以指向的对象。指针分析被看作may-analysis，会过度计算指针可以指向的对象集合，即“指针可能指向哪些对象？”。&lt;/p&gt;&#xA;&lt;img src = &#34;example.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;如上图例子所示，指针分析就是将一个输入的程序，输出为指针和对象之间的指向关系。&lt;/p&gt;&#xA;&lt;p&gt;Pointer Analysis and Alias Analysis是两个密切但不相关的概念&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;指针分析：指针可以指向哪些对象？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;别名分析：两个指针可以指向同一个对象吗？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果两个指针（比如 p 和 q）引用同一个对象，那么 p 和 q 之间就是别名的关系。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p = new C();&#xD;&#xA;q = p;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;别名的信息是可以根据指针分析推导出来的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;applications-of-pointer-analysis&#34;&gt;Applications of Pointer Analysis&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Fundamental information&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Call graph, aliases, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Compiler optimization&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Virtual call inlining, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Bug detection&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Null pointer detection, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Security analysis&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Information flow analysis, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;key-factors-of-pointer-analysis&#34;&gt;Key Factors of Pointer Analysis&lt;/h2&gt;&#xA;&lt;p&gt;指针分析是一个复杂的系统，影响系统精度和效率的因素很多&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨07过程间分析</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A807%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A807%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;因为上周三忙着做团支书的工作以及各种其他事情，课上没有仔细的听，所以之后再花时间重新看b站的视频课程。顺便就此机会准备后面的课都通过视频的形式来学习了。这门课还是在观看视频的时候反复理解和思考才是更高效的，即使我之前会线下去上课，回来之后还是有一些地方要自己好好研究的。所以后续以这种形式既不会错过知识内容，也可以增加我的效率。&lt;/p&gt;&#xA;&lt;p&gt;从这节课开始就是从谭添老师开始上了，前面听说从这一部分开始会有一些动态的分析，而且难度也会开始变得更高。针对过程间分析我们要了解的主要有 Call Graph Construction（ CHA ）、Interprocedural Control-Flow Graph 和 Interprocedural Data-Flow Analysis。&lt;/p&gt;&#xA;&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;过程内分析过于保守，假设调用后都不是常量，丢失了精度。所以我们需要过程间分析，首先就需要调用图，来得到调用边（Call edges）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;call-graph-construction-cha-&#34;&gt;Call Graph Construction（ CHA ）&lt;/h2&gt;&#xA;&lt;p&gt;一个调用图是一个从 call-sites 到目标方法的调用边的集合。&lt;/p&gt;&#xA;&lt;img src=&#34;call-graph.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;本课程主要对 OOPLs 构建调用图(focus on Java)，这节课会学习Class hierarchy analysis（ CHA ），下节课会学习Pointer analysis（k-CFA）。&lt;/p&gt;&#xA;&lt;img src=&#34;1.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;越往上速度越快，越往下精度越高。&lt;/p&gt;&#xA;&lt;p&gt;了解JAVA中的call：&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;thead&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;th&gt;&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Static call&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Special call&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Virtual call&lt;/th&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/thead&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Instruction&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokestatic&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokespecial&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokeinterface&lt;br&gt;invokevirtual&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Receiver objects&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;×无实例&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;√有实例&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;√有实例&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Target methods&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Static methods (静态方法)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Constructors (构造函数)&lt;br&gt;&lt;strong&gt;·&lt;/strong&gt;Private instance methods (类自己的私有方法)&lt;br&gt;&lt;strong&gt;·&lt;/strong&gt;Superclass instance methods (父类的实例方法)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Other instance methods (其他实例方法)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;# Target methods 个数&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;1&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;1&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;≥1 (polymorphism) 多态&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Determinacy 确定时机&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Compile-time (编译时)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Compile-time (编译时)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Run-time (运行时)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;p&gt;构造调用图的关键在于处理virtual call，其中关键的一个步骤叫做Method Dispatch，基于：&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A3</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a3/</link>
      <pubDate>Wed, 06 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a3/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;因为开始写博客的时间已经完成了前两次的实验，所以也不打算重新补写前两次的实验笔记了。如果增加这个工作量我肯定会对写博客产生抵触心理，因为我补充了这个那我后续在其他方面不能不补充厚此薄彼吧，这样一下子积压了大量需要补充的内容压力过大会导致我直接化身怯战蜥蜴——放弃。&lt;/p&gt;&#xA;&lt;p&gt;作业3：死代码检测，并不是我们上课学习的内容，但是通过组合我前两次作业中实现的分析方法：&lt;strong&gt;活跃变量分析&lt;/strong&gt;和&lt;strong&gt;常量传播&lt;/strong&gt;，可以实现一个Java的死代码检测算法。&lt;/p&gt;&#xA;&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa3.html&#34; target=&#34;_blank&#34;&gt;作业 3：死代码检测 | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;死代码检测介绍&#34;&gt;死代码检测介绍&lt;/h2&gt;&#xA;&lt;p&gt;死代码指的是程序中不可达的（unreachable）代码（即不会被执行的代码），或者是执行结果永远不会被其他计算过程用到的代码。去除死代码可以在不影响程序输出的前提下简化程序、提高效率。我们在这次实验中考虑两种死代码：&lt;strong&gt;不可达代码&lt;/strong&gt;（unreachable code）和&lt;strong&gt;无用赋值&lt;/strong&gt;（unreachable code）。这好像正好分别对应了常量传播和活跃变量分析。&lt;/p&gt;&#xA;&lt;h3 id=&#34;不可达代码&#34;&gt;不可达代码&lt;/h3&gt;&#xA;&lt;p&gt;一个程序中永远不可能被执行的代码被称为不可达代码。我们考虑两种不可达代码：&lt;strong&gt;控制流不可达代码&lt;/strong&gt;（control-flow unreachable code）和&lt;strong&gt;分支不可达代码&lt;/strong&gt;（unreachable branch）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;控制流不可达代码&lt;/strong&gt;：在一个方法中，如果不存在从程序入口到达某一段代码的控制流路径，那么这一段代码就是控制流不可达的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：利用所在方法的控制流图（CFG，即 control-flow graph）检测出来。我们只需要从方法入口开始，遍历 CFG 并标记可达语句。当遍历结束时，那些没有被标记的语句就是&lt;strong&gt;控制流不可达&lt;/strong&gt;的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;分支不可达代码&lt;/strong&gt;：在 Java 中有两种分支语句：if 语句和 switch 语句。它们可能会导致分支不可达代码的出现。&lt;/p&gt;&#xA;&lt;p&gt;对于一个 if 语句，如果它的条件值（通过常量传播得知）是一个常数，那么无论程序怎么执行，它两个分支中的其中一个分支都不会被走到。这样的分支被称为&lt;strong&gt;不可达分支&lt;/strong&gt;。该分支下的代码也因此是不可达的，被称为分支不可达代码。&lt;/p&gt;&#xA;&lt;p&gt;对于一个 switch 语句，如果它的条件值是一个常数，那么不符合条件值的 case 分支就&lt;strong&gt;可能&lt;/strong&gt;是不可达的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：为了检测分支不可达代码，我们需要预先对被检测代码应用常量传播分析，通过它来告诉我们条件值是否为常量，然后在遍历 CFG 时，我们不进入相应的不可达分支。&lt;/p&gt;&#xA;&lt;h3 id=&#34;无用赋值&#34;&gt;无用赋值&lt;/h3&gt;&#xA;&lt;p&gt;一个局部变量在一条语句中被赋值，但再也没有被该语句后面的语句读取，这样的变量和语句分别被称为无用变量（dead variable，与活跃变量 live variable 相对）和无用赋值。无用赋值不会影响程序的输出，因而可以被去除。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：为了检测无用赋值，我们需要预先对被检测代码施用活跃变量分析。对于一个赋值语句，如果它等号左侧的变量（LHS 变量）是一个无用变量（换句话说，not live），那么我们可以把它标记为一个无用赋值。&lt;/p&gt;&#xA;&lt;p&gt;但需要注意的是，以上讨论有一种例外情况：有时即使等号左边的变量 &lt;code&gt;x&lt;/code&gt; 是无用变量，它所属的赋值语句 &lt;code&gt;x = expr&lt;/code&gt; 也不能被去除，因为右边的表达式 &lt;code&gt;expr&lt;/code&gt; 可能带有某些副作用。例如，当 &lt;code&gt;expr&lt;/code&gt; 是一个方法调用（&lt;code&gt;x = m()&lt;/code&gt;）时，它就有可能带有副作用，可能在m()中改变了某些值。对于这种情况，作业提供了一个 API 供检查等号右边的表达式是否可能带有副作用。如果带有副作用，那么为了保证 safety，即使 &lt;code&gt;x&lt;/code&gt; 不是一个活跃变量，也不应该把这个赋值语句标记为死代码。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
