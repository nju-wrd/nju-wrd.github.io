<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 桐木</title>
    <link>https://nju-wrd.github.io/posts/</link>
    <description>Recent content in Posts on 桐木</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Sun, 10 Nov 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://nju-wrd.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>我的博客网站搭建进展丨01</title>
      <link>https://nju-wrd.github.io/posts/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%B1%95%E4%B8%A801/</link>
      <pubDate>Sun, 10 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%B1%95%E4%B8%A801/</guid>
      <description>&lt;h2 id=&#34;2024-11-07&#34;&gt;2024-11-07&lt;/h2&gt;&#xA;&lt;p&gt;在我写了几篇博客之后，通过实际的编写过程和这期间看到的别的内容，我发现用单纯的Markdown语法来写并不能达到我想要的效果。并且我通过对比发现我在Typora里编辑的 html 语法是可以被识别到并正确运行的，不过可能由于我本身博客的框架基础，在web页面并没有被正确加载，所以我决定研究一下我的 post 具体是怎样被加载的。&lt;/p&gt;&#xA;&lt;p&gt;经过研究发现，我的书写内容没有问题，post 的加载也没有问题，在&lt;a href=&#34;https://juejin.cn/post/7119681369831112741&#34;&gt;修复Hugo静态生成器中忽略原始HTML的方法&lt;/a&gt;中我找到了问题的答案，原来是因为渲染的markdown不能理解我在短代码中的HTML。从Hugo V.0.60开始，默认的markdown渲染器是Gold mark。Goldmark渲染引擎默认忽略了原始HTML。所以我必须使用配置参数来告诉它。这个解决方案可以让Markdown渲染器使用Goldmark渲染器，通过配置考虑原始HTML。&lt;/p&gt;&#xA;&lt;p&gt;修复方法是在配置文件中加入&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;style=&#34;position:relative;&#34;&gt;&lt;pre&gt;&lt;code id = &#34;code1&#34;&gt;[markup]&#xD;&#xA;  [markup.goldmark]&#xD;&#xA;    [markup.goldmark.renderer]&#xD;&#xA;      unsafe = true&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;&lt;button class=&#34;copy-button&#34; data-clipboard-target=&#34;#code1&#34;&gt;Copy&lt;/button&gt;&#xD;&#xA;&lt;/div&gt;&#xD;&#xA;&lt;p&gt;这里我正在使用 config.toml 文件，若是 yaml 文件参考文章给出的格式。这时候我之前的 html 语句就被正确加载了。&lt;/p&gt;&#xA;&lt;p&gt;第二个问题是我之前插入了很多图片都没有被正确加载，我觉得可能是因为文件路径的问题。因为上一个问题我是先问的 gpt ，其实 gpt 给出的方案和正确方案是比较类似的，但他没有意识到她提到的 blackfriday 渲染器已经不再使用了，导致我花费很多时间找到真正的原因，所以这一次我也觉得先在搜索引擎中找答案。根据 &lt;a href=&#34;https://blog.csdn.net/qq_38340601/article/details/108900666&#34;&gt;hugo 导入图片的两种方式&lt;/a&gt;我也完成了我的图片导入。但是后续我想到了一些问题，就是我的 content\cn\posts 内文件本身是没有额外文件夹的，但是在 hugo 启动之后生成的 public 文件夹中是针对每个 md 文件有一个文件夹的，其中放了 html 文件，所以我的做法就是将图片放在这个文件夹之下。我想到的是什么呢，就是说这个文件是一个缓存文件，如果我执行了清除缓存的命令，我里面的图片就没了，我测试了一下，果然没了。但是 edge 里面还能看到，我猜测是因为 edge 本身缓存了这个图片，于是我打开 chrome 试了一下果然，这张图片已经看不到了，所以我现在要理解这个过程，将图片放在一个一劳永逸的地方。为什么我不直接放在 content 目录先呢，因为这里面原来都是单独的 md 文件，我担心将 md 文件放入文件夹中会影响 hugo 构建的过程。这次我直接询问 gpt 得到了答案，我可以在 post 文件夹下额外新建一个对应 md 文件的文件夹，然后将相应的图片放入即可，这样 hugo 自然会将图片放入 public 对应的文件夹和 html 文件在一起。在这之前，~~我找到了回收站中被清除的图片。~~我重新上传了需要的图片。&lt;/p&gt;</description>
    </item>
    <item>
      <title>网络安全与检测技术作业丨01</title>
      <link>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E4%BD%9C%E4%B8%9A%E4%B8%A801/</link>
      <pubDate>Sat, 09 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E4%BD%9C%E4%B8%9A%E4%B8%A801/</guid>
      <description>&lt;h2 id=&#34;题目&#34;&gt;题目&lt;/h2&gt;&#xA;&lt;p&gt;作业的内容是&lt;a style=&#34;color: #0000FF;&#34; href=&#34;网络安全与检测技术作业 1.pdf&#34; target=&#34;_blank&#34;&gt;网络安全与检测技术 作业 1&lt;/a&gt;，其中第八题的内容是：&lt;/p&gt;&#xA;&lt;img src=&#34;8.png&#34; /&gt;&#xD;&#xA;&lt;h2 id=&#34;我的答案&#34;&gt;我的答案&lt;/h2&gt;&#xA;&lt;p&gt;1.(1)Mi=Dk(Ci⊕Ci−1)⊕Ci-1&lt;/p&gt;&#xA;&lt;p&gt;(2)在AES-CBS-STAR模式中，每个密文分组Ci依赖于前一个密文分组Ci−1，即加密过程是串行的，无法进行并行化。&lt;/p&gt;&#xA;&lt;p&gt;解密过程中Mi的计算也依赖于前一个密文分组Ci−1，因此，解密过程也是串行的。&lt;/p&gt;&#xA;&lt;p&gt;所以AES-CBS-STAR模式既不能并行加密，也不能并行解密。&lt;/p&gt;&#xA;&lt;p&gt;(3)由于C0=IV0是已知的，对手能够根据选择的明文和已知的IV，推测出初始密文分组C1或其他分组。然后攻击者可以分析密文序列中的变化趋势，利用IV的已知值推断出明文。&lt;/p&gt;&#xA;&lt;p&gt;2.(1)在ECB模式中，每个分组的加密是独立的，只会影响第8个明文分组的第17比特。&lt;/p&gt;&#xA;&lt;p&gt;(2)CTR模式的密文模块之间是独立的，因此一个密文模块的污染只会影响相应的明文模块。第2和第3个明文分组都将被污染。&lt;/p&gt;&#xA;&lt;p&gt;(3)OFB模式中,密文生成是通过明文与一个伪随机序列进行异或来完成的,密文模块之间是独立的，只会影响第7个明文分组。&lt;/p&gt;&#xA;&lt;p&gt;(4)CBC模式中，每个明文分组与前一个密文分组进行异或操作,会影响当前分组的解密结果和下一个分组的解密结果。会影响第9个明文分组的第16和第17比特，以及第10个明文分组的第16和第17比特。&lt;/p&gt;&#xA;&lt;p&gt;(5)CFB模式中，密文是通过明文与来自加密器输出的前几个比特进行异或来生成的。会影响第12个明文分组的第3到第6比特，以及以后所有明文分组的所有比特。&lt;/p&gt;&#xA;&lt;p&gt;3.这种方法与RSA不等价在RSA中，e（相当于这里的E）的选择是有一定条件的，通常要求e与(P-1)(Q-1)互质，这样才能保证解密的唯一性和正确性。而这里不满足RSA中的选择条件，解密指数D未必存在，或者可能存在多个解，无法保证解密过程的正确性。所以该方法不是RSA算法。&lt;/p&gt;&#xA;&lt;p&gt;4.假设我们希望找到一对新的分组C1和C2，使得：&lt;/p&gt;&#xA;&lt;p&gt;RSAH(C1,C2)=RSAH(B1,B2)即&lt;/p&gt;&#xA;&lt;p&gt;RSA(E(C1)⊕C2)=RSA(E(B1)⊕B2)&lt;/p&gt;&#xA;&lt;p&gt;由于RSA是一个可逆操作，给定密文，我们可以通过逆向操作（即RSA解密）得到对应的明文。因此，如果我们有密文E(B1)⊕B2，我们可以通过适当选择C1和C2来调整这个结果，使其匹配。&lt;/p&gt;&#xA;&lt;p&gt;我们可以选择：&lt;/p&gt;&#xA;&lt;p&gt;C2=B2⊕(E(C1)⊕E(B1))这样，RSA(C1,C2)就会与RSA(B1,B2)相同。因此，该Hash函数是不安全的，它不满足抗弱碰撞性。&lt;/p&gt;&#xA;&lt;p&gt;5.攻击者可以利用逐字节比较的特性，通过逐字节猜测sig_bytes的正确值。在每次对比时，比较操作会在不匹配的字节处提前结束。可以通过监控每次比较的时间差来判断哪些字节匹配。通常，匹配的字节会导致较长的比较时间（因为继续进行字节比较），而不匹配的字节会导致较短的比较时间。利用这个反馈信息，攻击者就可以逐步恢复正确的签名。&lt;/p&gt;&#xA;&lt;p&gt;我们可以使用常数时间比较：&lt;/p&gt;&#xA;&lt;p&gt;importhmac&lt;/p&gt;&#xA;&lt;p&gt;defverify(key,msg,sig_bytes):&lt;/p&gt;&#xA;&lt;p&gt;returnhmac.compare_digest(HMAC(key,msg),sig_bytes)&lt;/p&gt;&#xA;&lt;p&gt;6.(1)Bob能解密密文c并获得明文m的条件是密文c中包含了可以通过对称加密解密或通过私钥解签名获得的明文。&lt;/p&gt;&#xA;&lt;p&gt;(a)这种方式使用了哈希函数对密文Enc(K,m)进行哈希计算。哈希函数是单向的，Bob无法获得明文m，&lt;/p&gt;&#xA;&lt;p&gt;(b)中，c1是通过对称加密得到的密文，Bob使用对称密钥K可以解密c1得到m。c2只是Enc(K,m)的哈希，Bob不需要它来获取明文m。(c)中c1是加密后的密文，Bob可以使用K解密得到m，c2是对m的MAC（消息认证码），它主要用于验证消息的完整性。&lt;/p&gt;&#xA;&lt;p&gt;(d)中c1是加密的密文，Bob可以解密它得到m。c2是对加密后密文的MAC，用于完整性验证。&lt;/p&gt;&#xA;&lt;p&gt;(e)这里，c是Alice使用私钥SKA对加密消息Enc(K,m)的签名。Bob可以使用Alice的公钥PKA来验证签名，然后Bob可以根据对称密钥K解密Enc(K,m)。&lt;/p&gt;&#xA;&lt;p&gt;(f)中c1是加密后的明文m，Bob使用K解密得到m。c2是对明文m的签名（加密过），Bob可以解密c2并验证签名，但这不会影响c1中的解密过程。&lt;/p&gt;&#xA;&lt;p&gt;Bob能解密c获得明文m的方式是(b)、(c)、(d)、(e)、(f)。&lt;/p&gt;&#xA;&lt;p&gt;(2) (a)是通过哈希函数对密文进行处理，而哈希函数本身是单向的，不涉及加密，所以不能提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(b)是对称加密的密文，提供了机密性保护，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(c)是对称加密的密文，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(d)是对称加密的密文，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(e)是加密的密文，提供了机密性保护，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(f)是对称加密的密文，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;可以提供机密性保护的方式是(b)、(c)、(d)、(e)、(f)。&lt;/p&gt;&#xA;&lt;p&gt;(3) (a)只能提供单向验证，但不能验证消息是否在传输中被篡改，不能提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(b)中c2是Enc(K,m)的哈希值，可以用于验证密文是否被篡改，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(c)中c2是对消息m的MAC，可以验证消息的完整性，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(d)中c2是对密文Enc(K,m)的MAC，可以验证密文是否被篡改，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(e)Sign(SKA,Enc(K,m))是对密文的签名，可以验证密文是否被篡改，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(f)中c2是对明文m的签名的加密，可以用于验证消息的完整性，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;可以提供完整性保护的方式是(b)、(c)、(d)、(e)、(f)。&lt;/p&gt;&#xA;&lt;p&gt;(4)选择方式(c)：c=c1,c2:c1=Enc(K,m),c2=MAC(K,m)，它同时提供了机密性和完整性保护。为了防止重放攻击，我们可以在消息中添加时间戳或唯一的随机数nonce。&lt;/p&gt;&#xA;&lt;p&gt;7.(1)一种可能的攻击角度是伪造人脸图像进行攻击，即通过技术手段制造或操控一个与目标人物极为相似的面部图像或视频，从而欺骗门禁系统，绕过人脸识别机制进入系统。具体攻击方法可能包括以下几种：&lt;/p&gt;&#xA;&lt;p&gt;照片攻击：使用目标用户的照片，将其展示给门禁系统的摄像头来欺骗系统。&lt;/p&gt;&#xA;&lt;p&gt;视频攻击：通过录制目标用户的正常活动（例如走路、说话等），再通过播放视频来进行攻击，模拟目标的面部动态。&lt;/p&gt;&#xA;&lt;p&gt;3D模型攻击：通过3D打印技术制造出目标人物的面部模型，并将其放置在摄像头前，试图欺骗识别系统。&lt;/p&gt;&#xA;&lt;p&gt;深度学习攻击：利用深度学习技术生成目标人物的虚假面部图像或视频，进行欺骗。&lt;/p&gt;&#xA;&lt;p&gt;威胁模型：&lt;/p&gt;&#xA;&lt;p&gt;资产：门禁后的区域安全、生物识别数据、门禁系统完整性。&lt;/p&gt;&#xA;&lt;p&gt;对手：外部无通行权限的攻击者，获取门禁后的被保护的东西&lt;/p&gt;&#xA;&lt;p&gt;漏洞：识别技术不精确、缺乏活体检测、数据传输不加密。&lt;/p&gt;&#xA;&lt;p&gt;威胁：伪造身份、深度伪造、数据截获。&lt;/p&gt;&#xA;&lt;p&gt;风险：高价值区域和用户数据泄露，漏洞可能性较大。&lt;/p&gt;&#xA;&lt;p&gt;防御：活体检测、多因素认证、加密传输。&lt;/p&gt;&#xA;&lt;p&gt;(2)安全性质：&lt;/p&gt;&#xA;&lt;p&gt;KnowYourThreatModel：&#xA;确定潜在威胁和攻击者，包括外部黑客、内部员工、以及中间人。了解攻击者的动机、能力和目标。&lt;/p&gt;&#xA;&lt;p&gt;SecurityisEconomics：&#xA;评估安全防护的成本和攻击的潜在损失，确保在合理的成本范围内实现最佳安全效果。&lt;/p&gt;</description>
    </item>
    <item>
      <title>网络安全与检测技术学习笔记丨01</title>
      <link>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A801/</link>
      <pubDate>Sat, 09 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A801/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;这次学习是因为该课程布置了第一次作业，所以需要补充学习一下遗漏的内容。由于这门课是本研共修课程，在开学第一周本科生们就已经选好课并且开始上课了，但是我们新入学的研究生从第三周才能选好课并开始上课。这导致我最终其实第四周左右才选上这门课，所以遗漏了前面的很多内容，上课时感到很不连贯也就没有细听了，最终决定采用根据PPT自学的形式来完成这次布置的第一次作业。&lt;/p&gt;&#xA;&lt;h2 id=&#34;lec01-intro&#34;&gt;Lec01 Intro&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Ethics&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通常可以闯入自己的系统&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这是评估自己系统的好办法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;在获得他人明确许可的情况下，通常可以闯入他人的系统&lt;/li&gt;&#xA;&lt;li&gt;未经许可闯入他人的系统是不道德且犯罪的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;系统失效的原因：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Reliability：意外故障&lt;/li&gt;&#xA;&lt;li&gt;Usability：因用户操作错误而引起的问题&lt;/li&gt;&#xA;&lt;li&gt;Design and goal oversights：设计过程中的疏忽、错误和遗漏&lt;/li&gt;&#xA;&lt;li&gt;Security：他人故意造成的故障&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Security VS. Correctness：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;System correctness：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;系统满足规范&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于合理输入，获得合理输出&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;System security：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在面对攻击时保留系统属性&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于不合理的的输入，输出不完全错误&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;主要区别：主动干扰&lt;/p&gt;&#xA;&lt;p&gt;Course Overview&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如何考虑安全和隐私&#xA;&lt;ul&gt;&#xA;&lt;li&gt;“Security Mind” ——一种思考系统的全新方式&lt;/li&gt;&#xA;&lt;li&gt;Security Principles&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;安全和隐私的&lt;strong&gt;技术&lt;/strong&gt;方面&#xA;&lt;ul&gt;&#xA;&lt;li&gt;漏洞和攻击技术&lt;/li&gt;&#xA;&lt;li&gt;防御技术&lt;/li&gt;&#xA;&lt;li&gt;如何构建具有强大安全属性的计算机系统&lt;/li&gt;&#xA;&lt;li&gt;如何衡量当今技术提供的保护和限制&lt;/li&gt;&#xA;&lt;li&gt;攻击在实践中的工作原理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;主题包括&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本密码学&lt;/li&gt;&#xA;&lt;li&gt;认证&lt;/li&gt;&#xA;&lt;li&gt;密钥管理&lt;/li&gt;&#xA;&lt;li&gt;可用安全性（人工身份验证）&lt;/li&gt;&#xA;&lt;li&gt;网络安全&lt;/li&gt;&#xA;&lt;li&gt;数据安全和隐私&#xA;&lt;ul&gt;&#xA;&lt;li&gt;匿名和差分隐私&lt;/li&gt;&#xA;&lt;li&gt;联邦学习&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Emerging Technologies 的安全&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ML的安全性&lt;/li&gt;&#xA;&lt;li&gt;自动驾驶汽车的安全性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;lec02-secbasics&#34;&gt;Lec02 SecBasics&lt;/h2&gt;&#xA;&lt;h3 id=&#34;objects&#34;&gt;Objects&lt;/h3&gt;&#xA;&lt;h4 id=&#34;confidentiality保密性&#34;&gt;Confidentiality（保密性）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Confidentiality 是信息的隐瞒&lt;/li&gt;&#xA;&lt;li&gt;Data Confidentiality：确保私人或机密信息不会提供给或披露给未经授权的个人&lt;/li&gt;&#xA;&lt;li&gt;&lt;font color=gray&gt;Privacy：确保个人控制或影响哪些和他们有关的信息被收集，以及这些信息会被谁以及向谁披露&lt;/font&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;integrity完整性&#34;&gt;Integrity（完整性）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Integrity 是防止未经授权的更改&lt;/li&gt;&#xA;&lt;li&gt;Data Integrity：确保数据和信息仅以指定和授权的方式进行更改&lt;/li&gt;&#xA;&lt;li&gt;System Integrity：确保系统以不受损害的方式执行预期功能，不受故意或无意的未经授权的操作对系统执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;availability可用性&#34;&gt;Availability（可用性）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Availability 是使用信息或资源的能力&lt;/li&gt;&#xA;&lt;li&gt;确保系统迅速工作，并且不会拒绝向授权用户提供服务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;thread-modeling&#34;&gt;Thread Modeling&lt;/h3&gt;&#xA;&lt;p&gt;Assets：我们要保护什么？这个资产有多少价值？&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨07过程间分析</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A807%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A807%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;因为上周三忙着做团支书的工作以及各种其他事情，课上没有仔细的听，所以之后再花时间重新看b站的视频课程。顺便就此机会准备后面的课都通过视频的形式来学习了。实话实说的话，李樾老师的课确实要更精彩更吸引我一些，当然没有说谭添老师不好的意思，从内容上来说这门课始终都是非常棒的，但是李樾老师线下的课和线上不一样，因为李樾老师的&lt;strong&gt;课程&lt;/strong&gt;本身也十分的幽默风趣，他上课提到的一些包括用于举例子以及给我们讲的一些非课程相关的知识是和视频内不一样的，所以我自然不想错过，无论刮风下雨。但是这门课还是在观看视频的时候反复理解和思考才是更高效的，即使我之前会线下去上课，回来之后还是有一些地方要自己好好研究的。所以后续以这种形式既不会错过知识内容，也可以增加我的效率。&lt;/p&gt;&#xA;&lt;p&gt;从这节课开始就是从谭添老师开始上了，前面听说从这一部分开始会有一些s动态的分析，而且难度也会开始变得更高。针对过程间分析我们要了解的主要有 Call Graph Construction（ CHA ）、Interprocedural Control-Flow Graph 和 Interprocedural Data-Flow Analysis。&lt;/p&gt;&#xA;&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;过程内分析过于保守，假设调用后都不是常量，丢失了精度。所以我们需要过程间分析，首先就需要调用图，来得到调用边（Call edges）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;call-graph-construction-cha-&#34;&gt;Call Graph Construction（ CHA ）&lt;/h2&gt;&#xA;&lt;p&gt;一个调用图是一个从 call-sites 到目标方法的调用边的集合。&lt;/p&gt;&#xA;&lt;img src=&#34;call-graph.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;本课程主要对 OOPLs 构建调用图(focus on Java)，这节课会学习Class hierarchy analysis（ CHA ），下节课会学习Pointer analysis（k-CFA）。&lt;/p&gt;&#xA;&lt;img src=&#34;1.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;越往上速度越快，越往下精度越高。&lt;/p&gt;&#xA;&lt;p&gt;了解JAVA中的call：&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;thead&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;th&gt;&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Static call&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Special call&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Virtual call&lt;/th&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/thead&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Instruction&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokestatic&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokespecial&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokeinterface&lt;br&gt;invokevirtual&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Receiver objects&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;×无实例&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;√有实例&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;√有实例&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Target methods&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Static methods (静态方法)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Constructors (构造函数)&lt;br&gt;&lt;strong&gt;·&lt;/strong&gt;Private instance methods (类自己的私有方法)&lt;br&gt;&lt;strong&gt;·&lt;/strong&gt;Superclass instance methods (父类的实例方法)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Other instance methods (其他实例方法)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;# Target methods 个数&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;1&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;1&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;≥1 (polymorphism) 多态&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Determinacy 确定时机&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Compile-time (编译时)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Compile-time (编译时)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Run-time (运行时)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;p&gt;构造调用图的关键在于处理virtual call，其中关键的一个步骤叫做Method Dispatch，基于：&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A3</title>
      <link>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a3/</link>
      <pubDate>Wed, 06 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a3/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;因为开始写博客的时间已经完成了前两次的实验，所以也不打算重新补写前两次的实验笔记了。如果增加这个工作量我肯定会对写博客产生抵触心理，因为我补充了这个那我后续在其他方面不能不补充厚此薄彼吧，这样一下子积压了大量需要补充的内容压力过大会导致我直接化身怯战蜥蜴——放弃。&lt;/p&gt;&#xA;&lt;p&gt;作业3：死代码检测，并不是我们上课学习的内容，但是通过组合我前两次作业中实现的分析方法：&lt;strong&gt;活跃变量分析&lt;/strong&gt;和&lt;strong&gt;常量传播&lt;/strong&gt;，可以实现一个Java的死代码检测算法。&lt;/p&gt;&#xA;&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa3.html&#34; target=&#34;_blank&#34;&gt;作业 3：死代码检测 | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;死代码检测介绍&#34;&gt;死代码检测介绍&lt;/h2&gt;&#xA;&lt;p&gt;死代码指的是程序中不可达的（unreachable）代码（即不会被执行的代码），或者是执行结果永远不会被其他计算过程用到的代码。去除死代码可以在不影响程序输出的前提下简化程序、提高效率。我们在这次实验中考虑两种死代码：&lt;strong&gt;不可达代码&lt;/strong&gt;（unreachable code）和&lt;strong&gt;无用赋值&lt;/strong&gt;（unreachable code）。这好像正好分别对应了常量传播和活跃变量分析。&lt;/p&gt;&#xA;&lt;h3 id=&#34;不可达代码&#34;&gt;不可达代码&lt;/h3&gt;&#xA;&lt;p&gt;一个程序中永远不可能被执行的代码被称为不可达代码。我们考虑两种不可达代码：&lt;strong&gt;控制流不可达代码&lt;/strong&gt;（control-flow unreachable code）和&lt;strong&gt;分支不可达代码&lt;/strong&gt;（unreachable branch）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;控制流不可达代码&lt;/strong&gt;：在一个方法中，如果不存在从程序入口到达某一段代码的控制流路径，那么这一段代码就是控制流不可达的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：利用所在方法的控制流图（CFG，即 control-flow graph）检测出来。我们只需要从方法入口开始，遍历 CFG 并标记可达语句。当遍历结束时，那些没有被标记的语句就是&lt;strong&gt;控制流不可达&lt;/strong&gt;的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;分支不可达代码&lt;/strong&gt;：在 Java 中有两种分支语句：if 语句和 switch 语句。它们可能会导致分支不可达代码的出现。&lt;/p&gt;&#xA;&lt;p&gt;对于一个 if 语句，如果它的条件值（通过常量传播得知）是一个常数，那么无论程序怎么执行，它两个分支中的其中一个分支都不会被走到。这样的分支被称为&lt;strong&gt;不可达分支&lt;/strong&gt;。该分支下的代码也因此是不可达的，被称为分支不可达代码。&lt;/p&gt;&#xA;&lt;p&gt;对于一个 switch 语句，如果它的条件值是一个常数，那么不符合条件值的 case 分支就&lt;strong&gt;可能&lt;/strong&gt;是不可达的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：为了检测分支不可达代码，我们需要预先对被检测代码应用常量传播分析，通过它来告诉我们条件值是否为常量，然后在遍历 CFG 时，我们不进入相应的不可达分支。&lt;/p&gt;&#xA;&lt;h3 id=&#34;无用赋值&#34;&gt;无用赋值&lt;/h3&gt;&#xA;&lt;p&gt;一个局部变量在一条语句中被赋值，但再也没有被该语句后面的语句读取，这样的变量和语句分别被称为无用变量（dead variable，与活跃变量 live variable 相对）和无用赋值。无用赋值不会影响程序的输出，因而可以被去除。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：为了检测无用赋值，我们需要预先对被检测代码施用活跃变量分析。对于一个赋值语句，如果它等号左侧的变量（LHS 变量）是一个无用变量（换句话说，not live），那么我们可以把它标记为一个无用赋值。&lt;/p&gt;&#xA;&lt;p&gt;但需要注意的是，以上讨论有一种例外情况：有时即使等号左边的变量 &lt;code&gt;x&lt;/code&gt; 是无用变量，它所属的赋值语句 &lt;code&gt;x = expr&lt;/code&gt; 也不能被去除，因为右边的表达式 &lt;code&gt;expr&lt;/code&gt; 可能带有某些副作用。例如，当 &lt;code&gt;expr&lt;/code&gt; 是一个方法调用（&lt;code&gt;x = m()&lt;/code&gt;）时，它就有可能带有副作用，可能在m()中改变了某些值。对于这种情况，作业提供了一个 API 供检查等号右边的表达式是否可能带有副作用。如果带有副作用，那么为了保证 safety，即使 &lt;code&gt;x&lt;/code&gt; 不是一个活跃变量，也不应该把这个赋值语句标记为死代码。&lt;/p&gt;</description>
    </item>
    <item>
      <title>去除冗余的Java依赖</title>
      <link>https://nju-wrd.github.io/posts/%E5%8E%BB%E9%99%A4%E5%86%97%E4%BD%99%E7%9A%84java%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Mon, 04 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%8E%BB%E9%99%A4%E5%86%97%E4%BD%99%E7%9A%84java%E4%BE%9D%E8%B5%96/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;这是本周三我要分享的论文，在这里浅谈一下我对于&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://ieeexplore.ieee.org/abstract/document/10549332&#34; target=&#34;_blank&#34;&gt;Efficiently Trimming the Fat: Streamlining Software Dependencies with Java Reflection and Dependency Analysis&lt;/a&gt;的理解。&lt;/p&gt;&#xA;&lt;h2 id=&#34;contributions&#34;&gt;Contributions&lt;/h2&gt;&#xA;&lt;div style=&#34;border-left:4px solid green;padding-left:10px;&#34;&gt;&lt;font color=#686868&gt;&#xD;&#xA;An effective debloating tool called Slimming &lt;br&gt;&lt;br&gt;&#xD;&#xA;Comprehensive datasets. (1) a high-quality benchmark including 3,520 reflective calls captured by dynamic techniques from a collection of framework-based Java projects for evaluating the effectiveness of reflection analysis techniques; (2) a dataset of 40 projects with 100% test coverage for Java byte code instructions for evaluating the reliability of debloating solutions.”&lt;/font&gt;&lt;/div&gt;&#xD;&#xA;这篇文章的贡献包括提供了有效的去臃肿工具，以及一个全面的数据集，分别提供用于评估反射分析有效性和可靠性。包含3520个从框架型JAVA项目中通过动态技术捕获的反射调用，还包含40个字节码指令测试覆盖率达100%的JAVA项目。&#xD;&#xA;&lt;div style=&#34;border-left:4px solid green;padding-left:10px;&#34;&gt;&lt;font color=#686868&gt;Data Availability. We provided a reproduction package, including the above datasets, an available tool, and experiment raw data, on the [website](https://slimming-fat.github.io/) for facilitating future research.&lt;/font&gt;&lt;/div&gt;&#xD;&#xA;&lt;p&gt;另外还提供了&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://slimming-fat.github.io/&#34; target=&#34;_blank&#34;&gt;在线网站&lt;/a&gt;方便你来复现文章的内容。&lt;/p&gt;</description>
    </item>
    <item>
      <title>对于MLIR的理解</title>
      <link>https://nju-wrd.github.io/posts/%E5%AF%B9%E4%BA%8Emlir%E7%9A%84%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sun, 03 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E5%AF%B9%E4%BA%8Emlir%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;下周三也就是11.6日，将要轮到我来做组会的论文分享，所以寻找到这篇论文来阅读。&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://xgdsmileboy.github.io/files/paper/issta24-fuzz.pdf&#34; target=&#34;_blank&#34;&gt;Fuzzing MLIR Compiler Infrastructure via Operation Dependency Analysis&lt;/a&gt;从标题来看我第一感觉是和我们组内的工作接近的，不过是否真的接近还得等我阅读完再做总结。说来也是机缘巧合，这篇文章是我在ISSTA2024的Accepted Papers找到的。首先我是看到他的标题是针对编译，针对中间代码生成有关的工作，然后发现是国人作者，再然后发现论文的作者之一&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://sites.google.com/site/junjiechen08/&#34; target=&#34;_blank&#34;&gt;Junjie Chen&lt;/a&gt;是曾经来南大做过论文报告的老师。当时刚刚进组，我的导师兼老板让我来参加一场学术报告，我对这个老师就印象深刻，因为他看起来很年轻，我当时一直在想他是学生还是老师，能够和其他许多看起来就经验更丰富，研究多年的教授专家坐在一起。现在想来这位老师也是十分努力和优秀啊，不愧是国家优青项目或的人，值得我去学习。&lt;/p&gt;&#xA;&lt;h2 id=&#34;mlir&#34;&gt;MLIR&lt;/h2&gt;&#xA;&lt;p&gt;由于想要看懂这篇论文，首先要知道MLIR是什么，于是我找到了&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://arxiv.org/pdf/2002.11054&#34; target=&#34;_blank&#34;&gt;MLIR: ACompiler Infrastructure for the End of Moore’s Law&lt;/a&gt;，这篇论文详细介绍了MLIR是什么，它能解决什么样的问题，以及最重要的一点如何实现。这里结合对&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://www.lei.chat/zh/posts/&#34; target=&#34;_blank&#34;&gt;系列文章&lt;/a&gt;的阅读进行了总结。&lt;/p&gt;&#xA;&lt;p&gt;看完发现很复杂，并且和我们目前的项目有一定偏差，所以先放下了，去看另一篇文章。&lt;/p&gt;</description>
    </item>
    <item>
      <title>我的第一篇博客</title>
      <link>https://nju-wrd.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sat, 02 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://nju-wrd.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</guid>
      <description>&lt;h2 id=&#34;契机与想法&#34;&gt;契机与想法&lt;/h2&gt;&#xA;&lt;p&gt;这是我的第一篇博客，同时也是我参加王道助教工作的第一天，在这个工作的时间搭建了一个简单的博客网站。首先，想要写博客这个想法的契机来源于我在写南京大学软件分析课程作业时，遇到了未通过的样例且思索无果，可以说我是百思不得其解，但是又十分想要AC。这时我在搜索引擎上搜索而看到的一个计算机领域前辈大佬的笔记&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://blog.wohin.me/posts/nju-program-analysis-a2/&#34; target=&#34;_blank&#34;&gt;南大软分实验笔记｜A2&lt;/a&gt;，我为这样形式的内容而感到惊喜，不仅让我解决了当时遇到的困难，还给我一种启发。说实话，这是我第一次在计算机领域接触到这种记录自己的心路历程以及解决问题过程的形式，单纯的记录与分享却让我受益良多，无论是从问题解决还是解决问题的能力上。&lt;/p&gt;&#xA;&lt;p&gt;其实，这种感叹和惊喜从我开始在南大读研之后就常常发生。像是打开了新世纪的大门。在原来，程序员的世界在我看来是一个黑白，理性，充满逻辑的世界。给我的抽象感觉是一个摆放在黑白棋盘格上的天平，纯粹的同时不会给我的生活带来太多的色彩。现在我认识到了许多优秀的老师~~（单方面）~~以及见到了许多优秀的课程让我觉得原来学计算机也这么有意思。&lt;/p&gt;&#xA;&lt;p&gt;在这之后，我想到我还有那么多优秀的课想要去学，有很多感兴趣的事情想要去做，加上平时的作业与科研也可以以这样一种形式来呈现，还想到自己曾经想过的写日记的想法等等。在昨天凌晨一点我再也克制不住这样的想法，于是起来开始准备搭建这样的一个属于我自己的博客网站，一个我在计算机，在程序员世界的小家，同时会存下现实中的美好。&lt;/p&gt;&#xA;&lt;h2 id=&#34;博客搭建进度&#34;&gt;博客搭建进度&lt;/h2&gt;&#xA;&lt;p&gt;因为我对于前端不太熟悉，对于这样一件事情也是很茫然的。所以这个博客的搭建也完全来自于对Bonan前辈（上文的佬）在自己博客上的分享&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://blog.wohin.me/about/&#34; target=&#34;_blank&#34;&gt;About Me&lt;/a&gt;的拙劣模仿，以及结合在b站上的教程&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://www.bilibili.com/video/BV1bovfeaEtQ?spm_id_from=333.788.videopod.episodes&amp;vd_source=1837baf7c46a027b7e27b4ab7174fb85&#34; target=&#34;_blank&#34;&gt;Hugo + Github免费搭建博客&lt;/a&gt;的方式下，完成了一个小demo。由于非常喜欢这种简约的风格，所以没有换其他主题。我目前的想法除了完成这个主题的使用，同时将字体换成&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://github.com/lxgw/LxgwWenKai&#34; target=&#34;_blank&#34;&gt;“霞鹜文楷”&lt;/a&gt;，然后调整一下我的博客的结构，丰富其中的结构设计，以及加入深色模式功能和GitHub自动部署。目前完成了更换字体以及调整结构只留下了一条博客的目录，后续需要设计丰富一下。但是我现在可以先开始着手写一些内容了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;王道助教&#34;&gt;王道助教&lt;/h2&gt;&#xA;&lt;p&gt;因为之前参加过王道的线上培训课程，主要是做一个项目，现在看来是很简单了，但是当时帮助我掌握了很多知识和技巧。提到这个是因为王道当时上课的云龙老师在当时的课程群内发布了一条招聘助教的信息。我一想只需要在线上给同学们答疑就可以拿工资，多是一件美事，于是立马加了云龙老师的微信然后表达了我的意愿。虽然我没参加过这个叫做C语言督学营的课，但是我满足考研上岸211或985学校的同学，也算是拥有了一个面试的资格。想着都是一些简单的数据结构，我也就没有多做准备等待面试即可。就在昨天上午，十点半的时间，刚起床不久，我正吃着我母亲特地从菜市场给我带回来的咸豆腐脑和包子，刚刚把豆腐脑上撒的辣油和花生碎给拌开。也许是因为最近跟我母亲表达了我蛮喜欢吃花生米的意愿，所以上面的花生碎非常多。尝了没几口，收到了云龙老师的信息。就挺突然的，“现在是否方便面试，微信语音电话，预计10到15分钟的时间”，那我自然是积极回复，可以说是秒回了一句“龙哥你好方便的”。然后我便和母亲交代我有点事一会来吃，并叮嘱她一会不要来喊我，然后回房间等待面试。面试很快，9&#39;28，虽然说有些回答的磕磕绊绊，因为我对于一些专业术语反应的有点慢，归根到底我想还是记得不够牢固啊。总之，11:22分我收到了通过面试的消息，或许这是我第一份通过且接受的职位，也是我即将利用本专业知识赚取的第一碗金。是的，这时我就已经开始幻想轻松的答疑工作+拿钱了。我还挺上心的，我去看了基本上一大半的课件，完成了一大半的OJ题目，还挺费时间的，后来觉得不是太大问题，看了一下大纲就没在细细品读了。结果，今天的现实给了我沉重的打击，一是今天是周六，学习的同学比之前多特别多，虽然对于这个一共大约620人7个群的数量来说还算能接受，但也比较多了，二是遇到的问题基本上都是一长串的代码，因为是新手，他们不会根据报错和提示找到问题根源，所以我只能让他们发所有的源代码给我自己测试，还好都是比较基础的数据结构不算难理解，也很少遇到代码写的很奇怪的同学。不过我觉得这也在某种程度上加深我对数据结构的理解，真是教学相长啊。还有一个比较难受的特殊原因是，今天本来是要和我母亲一起去参加她同事儿子的婚礼，在这样的情况下，就让人比较纠结，最终我还是去了，在五点多解决了最后一个存在的问题之后。不过后续是我又早早回来了，因为在外面确实不方便，还好婚礼地点离我家不算远，加上我又有小电驴。这篇博客就是我回来之后开始写的，马上今天的答疑也快结束了。哦！我还写了一份不同时间点的提醒的文案，我要贴在下面留着，最下面是我找到的另外两个劝学的名言但没用上的。&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xA;&lt;colgroup&gt;&#xA;    &lt;col style=&#34;width: 26%&#34;&gt;&#xA;    &lt;col style=&#34;width: 74%&#34;&gt;&#xA;  &lt;/colgroup&gt;&#xA;  &lt;thead&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;th&gt;时间点&lt;/th&gt;&#xA;      &lt;th&gt;提醒文案&lt;/th&gt;&#xA;    &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;早上9点开始&lt;/td&gt;&#xA;      &lt;td&gt;同学们早上好！为学患无疑，以则进也。遇到问题是进步的开始，大家可以在群里@我，我会努力帮助大家解答，如果问题较多可能会回复不及时还请大家多多包涵。如果漏了某些同学的问题还得麻烦再次提醒我一下，期待今天大家的提问。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;中午十二点休息&lt;/td&gt;&#xA;      &lt;td&gt;午休时间到，大家注意休息，保持充沛的精神体力，两点后答疑继续哦。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;下午两点开始&lt;/td&gt;&#xA;      &lt;td&gt;下午的答疑开始了，大家可以继续向我提问啦。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;晚上六点休息&lt;/td&gt;&#xA;      &lt;td&gt;晚饭时间到，休息一会，七点继续哦。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;晚上七点开始&lt;/td&gt;&#xA;      &lt;td&gt;晚上的答疑开始啦，欢迎提问。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;晚上十点结束&lt;/td&gt;&#xA;      &lt;td&gt;今天的答疑时间就结束了哦，如果有遗漏和不清晰的地方可以再次@我！今天的学习也辛苦了，大家注意休息，可以早睡早起明天继续努力。同学们下次见！&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;人生在勤，勤则不匮。&lt;/td&gt;&#xA;      &lt;td&gt;人学始知道，不学非自然。——孟郊《劝学》&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;一会我就要发十点的文案了，幻想今天的答疑工作能收到好评。&lt;/p&gt;&#xA;&lt;h2 id=&#34;第一篇的总结&#34;&gt;第一篇的总结&lt;/h2&gt;&#xA;&lt;p&gt;万事开头难，虽然翻过了一座山，后面还有各种各样的山坡和丘陵，希望我能坚持记录。接下来可能会先写下周要分享的论文和下周二要交的论文报告。之后还可能会有软件分析的A3,A4作业，顺带一提我本来想补一下以前的内容，让这个成一套体系，但我仔细想了想先设立这个工作可能会让我有放弃的想法，所以我放弃了这个想法。之后应该还会有网安的作业，网易雷火比赛作品的开发日志，games101的学习记录等等，给自己画个小饼，希望自己多多加油努力呀！&lt;/p&gt;&#xA;&lt;p&gt;附一张我觉得有趣的图片：&lt;/p&gt;&#xA;&lt;img src=&#34;screen-shoot.jpg&#34; /&gt;&#xA;&lt;p&gt;是我在某时间点之前，将我的文案草稿全部复制粘贴好，到点就发，看着很好笑。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
