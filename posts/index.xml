<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 子春廿一</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on 子春廿一</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Sun, 24 Nov 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>24腾讯游戏客户端公开课作业丨01</title>
      <link>http://localhost:1313/posts/24%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E4%BD%9C%E4%B8%9A%E4%B8%A801/</link>
      <pubDate>Sun, 24 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/24%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E4%BD%9C%E4%B8%9A%E4%B8%A801/</guid>
      <description>&lt;h2 id=&#34;作业内容&#34;&gt;作业内容&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;编译UE5源码&lt;/li&gt;&#xA;&lt;li&gt;Androiod打包&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;过程&#34;&gt;过程&lt;/h2&gt;&#xA;&lt;p&gt;首先，需要安装 git ，安装的链接参考是 &lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://blog.csdn.net/weixin_42242910/article/details/136297201&#34; target=&#34;_blank&#34;&gt;windows安装git&lt;/a&gt; 。然后需要在你想存储的地方打开 git bash ，进行 git clone 。克隆 Unreal Engine 的官方源码需要一个 GitHub 账号，并且要和 Epic 账号绑定，才能加入 group 有权限下载源码，这一点可以参考官方的 &lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://www.epicgames.com/help/zh-CN/c-Category_EpicAccount/c-ConnectedAccounts/unreal-enginegithub-a000084938&#34; target=&#34;_blank&#34;&gt;help 文档页面&lt;/a&gt;。完成这一步之后需要在你的 git bash 界面设置你的账户，一种是通过修改配置文件，利用以下两条语句配置你的 Git 账号信息：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git config --global user.name &amp;#34;your-github-username&amp;#34;&#xD;&#xA;git config --global user.email &amp;#34;your-email@example.com&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后利用 &lt;code&gt;git clone https://github.com/EpicGames/UnrealEngine.git&lt;/code&gt;在 git bash 中进行下载。&lt;/p&gt;&#xA;&lt;p&gt;其次可以通过生成 ssh 密钥，首先在 Git Bash 中生成 SSH 密钥：&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;ssh-keygen -t rsa -b 4096 -C &amp;quot;your-email@example.com&amp;quot;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;通常在你的当前用户的 C:\Users\admin\.ssh下的id_rsa.pub 文件中，复制公钥内容并将其添加到 GitHub 的 SSH Keys 设置中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A5</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a5/</link>
      <pubDate>Sun, 24 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a5/</guid>
      <description>&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa5.html&#34; target=&#34;_blank&#34;&gt;作业 5：非上下文敏感指针分析&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业目标&#34;&gt;作业目标&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为 Java 实现非上下文敏感的指针分析。&lt;/li&gt;&#xA;&lt;li&gt;为指针分析实现一个调用图的实时构建算法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在本次作业中，我们将在 Tai-e 上为 Java 实现一个非上下文敏感的指针分析，并在指针分析的过程中实时构建调用图。如果实现正确，该调用图会比用类层次结构分析（CHA）建立的更加精确。&lt;/p&gt;&#xA;&lt;p&gt;在本次作业中，我们将学习如何处理课上没有涉及的一些 Java 特性，即静态字段、数组和静态方法，这样我们的指针分析就可以处理 Java 中所有类型的指针了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;新的分析规则&#34;&gt;新的分析规则&lt;/h2&gt;&#xA;&lt;p&gt;在这一节中，我们引入新的指针分析规则来处理静态字段、数组索引和静态方法调用。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;静态字段&lt;/strong&gt;的处理很简单：我们只需要在静态字段和变量之间传值。我们用 T.f 表示静态字段 &lt;code&gt;T.f&lt;/code&gt; 的指针，然后定义如下规则来处理静态字段的 store 和 load：&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;thead&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;th&gt;类型&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;语句&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;规则&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;PFG 边&lt;/th&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/thead&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Static Store&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;T.f = y&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;1.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;        &lt;td&gt;T.f ← y&lt;/sub&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Static Load&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;y = T.f&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;2.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;y ← T.f&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;p&gt;常规指针分析不区分对不同&lt;strong&gt;数组索引&lt;/strong&gt;（位置）的 load 和 store。假设 o&lt;sub&gt;i&lt;/sub&gt; 代表一个数组对象，那么我们用 o&lt;sub&gt;i&lt;/sub&gt;i[∗] 表示一个指向数组中所有对象的指针（无论保存在数组的什么位置）。基于这样的处理，我们定义了数组 store 和 load 的规则：&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨10指针分析基础II</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A810%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80ii/</link>
      <pubDate>Thu, 21 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A810%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80ii/</guid>
      <description>&lt;h2 id=&#34;pointer-analysis-with-method-calls&#34;&gt;Pointer Analysis with Method Calls&lt;/h2&gt;&#xA;&lt;p&gt;过程间指针分析需要调用图，在 &lt;a style=&#34;color: #0000FF;&#34; href = &#34;https://nju-wrd.github.io//posts/软件分析学习笔记丨07过程间分析/#01&#34; target=&#34;_blank&#34; &gt;07 过程间分析中&lt;/a&gt;，我们采用了 CHA 方法来构造调用图。但是它本身是不精确的，因为它在一些情况下引入虚假的调用边和指向关系。&lt;/p&gt;&#xA;&lt;p&gt;而利用指针分析的方法，会比CHA更加精确。并且这种好处对调用图和指向关系的构建都会带来更精确的好处。规则如下：&lt;/p&gt;&#xA;&lt;img src = &#34;rule.png&#34; alt = &#34;规则&#34;/&gt;&#xD;&#xA;&lt;p&gt;我们来一点一点解析这里面的符号所代表的含义。这里的 Dispatch(o&lt;sub&gt;i&lt;/sub&gt;,k) 和前面 CHA 中的本质上是一样的，它利用 receive object o&lt;sub&gt;i&lt;/sub&gt; 的类型和调用点方法的签名 k 来找到实际的调用方法 m 。m&lt;sub&gt;this&lt;/sub&gt; 代表当前找到的目标方法的 this 变量。a&lt;sub&gt;j&lt;/sub&gt; 表示调用的第 j 个参数。m&lt;sub&gt;pj&lt;/sub&gt; 表示 m 的第 j 个参数。所以为了将调用的参数对应传递给 m 的参数，会在他们之间加上 PFG 边进行指向信息的传递。&lt;/p&gt;&#xA;&lt;img src = &#34;edge.png&#34; alt = &#34;加边&#34;/&gt;&#xD;&#xA;&lt;p&gt;m&lt;sub&gt;ret&lt;/sub&gt; 代表 m 的返回值，将返回值赋给调用点的左值。&lt;/p&gt;&#xA;&lt;p&gt;这里可以思考一个问题也就是为什么我们在处理 m&lt;sub&gt;this&lt;/sub&gt; 的时候，不和参数一样直接添加 PFG Edge ？&lt;/p&gt;&#xA;&lt;img src = &#34;example.png&#34; alt = &#34;例子&#34;/&gt;&#xD;&#xA;&lt;p&gt;首先我们知道在 Java 中，this 是一个很重要的变量，方法中可能会频繁地使用 this 变量，所以 this 变量的指向信息的正确性十分重要。我们再来看上图的例子，如果我们直接引入新 PFG Edge ，会导致给方法的 this 引入虚假的指向关系。具体来说在下面的三个方法中，其实每个方法的 this 的指向的类都是声明方法的类本身。而在 x 调用foo方法的时候，如果直接引入 PFG Edge，会将 x 原来所有的指向信息都流入找到的方法的 this ，但其实最终 this 只会是其中一个，而这由具体调用到哪个方法所决定。所以为了避免给 this 引入虚假的指向信息，我们不能和参数一样直接添加 PFG Edge。&lt;/p&gt;</description>
    </item>
    <item>
      <title>现代计算机图形学入门学习笔记丨06 Rasterization 2（Antialiasing）</title>
      <link>http://localhost:1313/posts/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A806-rasterization-2antialiasing/</link>
      <pubDate>Thu, 14 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A806-rasterization-2antialiasing/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;在我开始写博客之前我已经学完了前面的五次课，并且完成了作业0和作业1。在我简单回顾之后，我本来是想把这一块补上的，因为前几节课还是有很多需要记住的点的。但是犹豫再三，我还是放弃了，因为还是那句话，这意味着我要补上前面的很多内容，会带来很多重复的工作量让我心生退却。不过我也给自己立了一个 Flag ，如果我下一次用到相关知识，或者说复习的时候忘记了，我就把它加上，这样它对我来说就是一个更加有意义的工作量了，我会更容易接受。&lt;/p&gt;&#xA;&lt;h2 id=&#34;antialiasing&#34;&gt;Antialiasing&lt;/h2&gt;&#xA;&lt;img src = &#34;jaggie.png&#34; alt = &#34;锯齿&#34; /&gt;&#xD;&#xA;&lt;p&gt;锯齿是一种图片走样的结果，比如图中本来是一个三角形，但经过测试像素中心点在三角形内部还是外部并且将在内部的像素填上颜色的方式呈现在屏幕上时，就发生了锯齿的现象。所以我们要采用反走样技术来解决这种现象。&lt;/p&gt;&#xA;&lt;p&gt;在这之前我们先看看在计算机图形学中的采样。&lt;/p&gt;&#xA;&lt;p&gt;Rasterization = Sample 2D Positions，栅格化也就是采样2D平面内的位置&lt;/p&gt;&#xA;&lt;img src = &#34;rasterization.png&#34; alt = &#34;栅格化&#34; /&gt;&#xD;&#xA;&lt;p&gt;Photograph = Sample Image Sensor Plane，照片也就是采样图像传感器平面&lt;/p&gt;&#xA;&lt;img src = &#34;photograph.png&#34; alt = &#34;照片采样&#34; /&gt;&#xD;&#xA;&lt;p&gt;Video = Sample Time，视频也就是对时间采样，每隔一定时间采样一次&lt;/p&gt;&#xA;&lt;img src = &#34;video.png&#34; alt = &#34;视频采样&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;sampling-artifactserrors--mistakes--inaccuraciesin-computer-graphics&#34;&gt;Sampling Artifacts（Errors / Mistakes / Inaccuracies）in Computer Graphics&lt;/h3&gt;&#xA;&lt;p&gt;计算机图形学中由采样带来的“瑕疵”有很多，包括锯齿、摩尔纹、车轮效应。&lt;/p&gt;&#xA;&lt;p&gt;Jaggies（Staircase Pattern）：锯齿，也被称作楼梯模式&lt;/p&gt;&#xA;&lt;img src = &#34;jaggies.png&#34; alt = &#34;锯齿&#34; /&gt;&#xD;&#xA;&lt;p&gt;Moiré Patterns in Imaging：摩尔纹&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A4</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a4/</link>
      <pubDate>Wed, 13 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a4/</guid>
      <description>&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa4.html&#34; target=&#34;_blank&#34;&gt;作业 4：类层次结构分析与过程间常量传播&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;作业目标&#34;&gt;作业目标&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为 Java 实现一个类层次结构分析（Class Hierarchy Analysis，CHA）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;实现过程间常量传播。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;实现过程间数据流传播的 worklist 求解器。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;&#xA;&lt;h3 id=&#34;完成-chabuilder-类&#34;&gt;完成 CHABuilder 类&lt;/h3&gt;&#xA;&lt;h4 id=&#34;jmethod-dispatchjclasssubsignature&#34;&gt;JMethod dispatch(JClass,Subsignature)&lt;/h4&gt;&#xA;&lt;p&gt;该方法实现了如下图所示的 Dispatch 方法。特别地，如果找不到满足要求的方法，返回 null。&lt;/p&gt;&#xA;&lt;img src = &#34;dispatch.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里要了解三个类， JMethod 、 JClass 、 Subsignature 。其中， &lt;strong&gt;JMethod&lt;/strong&gt; 表示 Tai-e 中的 Java 方法，每个 JMethod 的实例关联着一个方法并包含该方法的各种信息。&lt;strong&gt;boolean isAbstract()&lt;/strong&gt;: 如果该 JMethod 是一个没有方法体的抽象方法，则返回 true ，否则返回 false； &lt;strong&gt;JClass&lt;/strong&gt; 表示 Tai-e 中的 Java 类，每个 JClass 的实例关联着一个类并包含该类的各种信息。&lt;strong&gt;JClass getSuperClass()&lt;/strong&gt;: 返回该类的父类。如果这个类在类层次结构的顶端（没有父类），比如 java.lang.Object，则返回 null。&lt;strong&gt;JMethod getDeclaredMethod(Subsignature)&lt;/strong&gt;: 根据子签名返回该类中声明的对应方法。如果该类中没有该子签名对应的方法，则返回 null。&lt;strong&gt;boolean isInterface()&lt;/strong&gt;: 返回该类是否是一个接口； &lt;strong&gt;Subsignature&lt;/strong&gt; 表示 Tai-e 中的子签名，一个方法的子签名只包含它的方法名和方法签名的描述符，举个例子，下面方法 foo 的子签名是：“T foo(P,Q,R)” ，而它的完整签名是：“&amp;lt;C: T foo(P,Q,R)&amp;gt;”。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨09指针分析基础I</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A809%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80i/</link>
      <pubDate>Tue, 12 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A809%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80i/</guid>
      <description>&lt;h2 id=&#34;pointer-analysis-rules&#34;&gt;Pointer Analysis: Rules&lt;/h2&gt;&#xA;&lt;h3 id=&#34;domains-and-notations域和符号&#34;&gt;Domains and Notations（域和符号）&lt;/h3&gt;&#xA;&lt;table border=&#34;0&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Variables:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;x, y ∈ V&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Fields:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;f, g ∈ F&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Objects:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;o&lt;sub&gt;i&lt;/sub&gt;, o&lt;sub&gt;j&lt;/sub&gt; ∈ O&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Instance fields:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;o&lt;sub&gt;i&lt;/sub&gt;.f, o&lt;sub&gt;j&lt;/sub&gt;.g ∈ O × F&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Pointers:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Pointer = V ⋃ (O × F)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Points-to relations:&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;pt : Pointer → 𝒫𝒫(O)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;P(O) denotes the powerset of O（P(O)表示 O 的幂集）&lt;/li&gt;&#xA;&lt;li&gt;pt(p) denotes the points-to set of （pt(p) 表示 p 的指向的集合）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;how-to-implement-pointer-analysis&#34;&gt;How to Implement Pointer Analysis&lt;/h2&gt;&#xA;&lt;table border=&#34;0&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;thead&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;th&gt;Kind&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Statement&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Rule&lt;/th&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/thead&gt;&#xD;&#xA;  &lt;tbody align=&#34;center&#34;&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;New&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;i: x = new T()&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;1.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Assign&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;x = y&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;2.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Store&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;x.f = y&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;3.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Load&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;y = x.f&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;img src = &#34;4.png&#34; /&gt;&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;规则中上面为条件，下面为结论。&#xD;&#xA;&lt;p&gt;本质上，指针分析是在指针（变量和字段）之间传播指向信息。我们使用一个 graph 来连接相关指针，当 pt(x) 发生变化时，传播更改的部分到 x 的后继。&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨08指针分析</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A808%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 11 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A808%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;CHA存在一些问题,会导致不精确的常量分析，如下图所示：&lt;/p&gt;&#xA;&lt;img src = &#34;problem.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;由于CHA只考虑类名，不考虑上下文，所以会追踪到三个目标方法，导致&lt;code&gt;x = NAC&lt;/code&gt;，但实际上调用的只是其中一个，这是不精确的，结果应该是&lt;code&gt;x = 1&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction-to-pointer-analysis&#34;&gt;Introduction to Pointer Analysis&lt;/h2&gt;&#xA;&lt;p&gt;指针分析是一个基础性的静态分析，计算指针可以指向的内存位置。对于面向对象（侧重于Java）的程序。计算指针（变量或字段）可以指向的对象。指针分析被看作may-analysis，会过度计算指针可以指向的对象集合，即“指针可能指向哪些对象？”。&lt;/p&gt;&#xA;&lt;img src = &#34;example.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;如上图例子所示，指针分析就是将一个输入的程序，输出为指针和对象之间的指向关系。&lt;/p&gt;&#xA;&lt;p&gt;Pointer Analysis and Alias Analysis是两个密切但不相关的概念&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;指针分析：指针可以指向哪些对象？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;别名分析：两个指针可以指向同一个对象吗？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果两个指针（比如 p 和 q）引用同一个对象，那么 p 和 q 之间就是别名的关系。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p = new C();&#xD;&#xA;q = p;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;别名的信息是可以根据指针分析推导出来的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;applications-of-pointer-analysis&#34;&gt;Applications of Pointer Analysis&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Fundamental information&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Call graph, aliases, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Compiler optimization&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Virtual call inlining, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Bug detection&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Null pointer detection, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Security analysis&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Information flow analysis, …&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;key-factors-of-pointer-analysis&#34;&gt;Key Factors of Pointer Analysis&lt;/h2&gt;&#xA;&lt;p&gt;指针分析是一个复杂的系统，影响系统精度和效率的因素很多&lt;/p&gt;</description>
    </item>
    <item>
      <title>2024腾讯游戏客户端公开课笔试</title>
      <link>http://localhost:1313/posts/2024%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AF%95/</link>
      <pubDate>Sun, 10 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2024%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AF%95/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;因为周六要打工没空，所以选择参加了11.10号的场次，在参加之前我除了知道这两场题目会不同之外，我还发现11.9对于编程语言限制的描述是&lt;div style=&#34;border-left:4px solid green;padding-left:10px;&#34;&gt;&lt;font color=#686868&gt;1道题目可使用：[C, C#, C++, Java, Python, Python 3] 1道题目可使用：[C++] 1道题目可使用：[C, C#, C++, Go, Groovy, Java, Javascript, Kotlin, Matlab, Object C, Pascal, Php, Pypy2, Pypy3, Python, Python 3, R, Ruby, Rust, Scala, Swift, Typescript]&lt;/font&gt;&lt;/div&gt;而11.10的表述是&lt;div style=&#34;border-left:4px solid green;padding-left:10px;&#34;&gt;&lt;font color=#686868&gt;2道题目可使用：[C, C++] 1道题目可使用：[C#, C++] 在线作答编程&lt;/font&gt;&lt;/div&gt;不知道会不会差别很大，大致回忆一下题目的内容，记不清的内容我会用自己理解的东西代替描述。&lt;/p&gt;&#xA;&lt;h2 id=&#34;q1&#34;&gt;Q1&lt;/h2&gt;&#xA;&lt;p&gt;第一道题是定义了一个完美平方数组，他会给你字符串的长度，以及相对应的由01组成的字符串，如果他能形成一个m * n的矩阵，满足外部都是1，中间都是0，就是完美数组，且当m == n的时候，是完美平方数组。输入的格式先是字符串的个数，然后接受每个字符串的长度和内容，满足完美平方数组的打印Yes，否则打印No。&lt;/p&gt;&#xA;&lt;h2 id=&#34;q2&#34;&gt;Q2&lt;/h2&gt;&#xA;&lt;p&gt;第二道题是会给出一个表达式，然后你要做的是解析表达式，解析成功的打印表达式的最终值，解析失败则打印XXX。要求解析的只有+-*/，且输入可能会有空格。&lt;/p&gt;&#xA;&lt;h2 id=&#34;q3&#34;&gt;Q3&lt;/h2&gt;&#xA;&lt;p&gt;第三道题是给定一个包含非负整数的 &lt;code&gt;m x n&lt;/code&gt; 矩阵 ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。且元素为0时，表示不可以通过。说明：每次只能向下或者向右移动一步。&lt;/p&gt;&#xA;&lt;h2 id=&#34;我的思路&#34;&gt;我的思路&lt;/h2&gt;&#xA;&lt;p&gt;第一题的话我是先判断是否满足平方，然后再简单的遍历每一个字符串的元素是否满足0，1的条件。&lt;/p&gt;&#xA;&lt;p&gt;第二题用了两个栈来解析，第一个栈对于数字操作，第二个对于op符操作，当遇到数字进数字栈，遇到符号且符号栈为空时进栈，栈不为空时，根据符号的优先级进行出栈以及计算的判断。不过中间会有一些细节的处理。&lt;/p&gt;&#xA;&lt;p&gt;第三题是很常见的dp题，因为某一点的最短路径只会来自于他的左边和上边，选择短的加上自己则是最短，所以可以划分为子问题。不过这里要对于0做特殊处理，我的处理是将此处的dp值设为int的最大值。随后循环生成打印即可。&lt;/p&gt;&#xA;&lt;p&gt;代码如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;style=&#34;position:relative;&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34; id = &#34;code1&#34;&gt;#include &amp;ltalgorithm&amp;gt&#xD;&#xA;#include &amp;ltiostream&amp;gt&#xD;&#xA;using namespace std;&#xD;&#xA;int main() {&#xD;&#xA;&#x9;int n,m;&#xD;&#xA;&#x9;cin &gt;&gt; m &gt;&gt; n;&#xD;&#xA;&#x9;int arr[100][100];&#xD;&#xA;&#x9;for(int i = 0 ;i &lt; m; i++){&#xD;&#xA;&#x9;for(int j = 0; j &lt; n; j++){&#xD;&#xA;&#x9;&#x9;cin &gt;&gt; arr[i][j];&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    int dp[100][100] = {0};&#xD;&#xA;    dp[0][0] = arr[0][0];&#xD;&#xA;    for(int i = 1 ;i &lt; m; i++){&#xD;&#xA;        if(arr[i][0] == 0){&#xD;&#xA;            while(i &lt; m){&#xD;&#xA;                dp[i][0] = INT32_MAX;&#xD;&#xA;                i++;&#xD;&#xA;            }&#xD;&#xA;        }else{&#xD;&#xA;            dp[i][0] = dp[i - 1][0] + arr[i][0];&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    for(int i = 1 ;i &lt; n; i++){&#xD;&#xA;        if(arr[0][i] == 0){&#xD;&#xA;            while(i &lt; n){&#xD;&#xA;                dp[0][i] = INT32_MAX;&#xD;&#xA;                i++;&#xD;&#xA;            }&#xD;&#xA;        }else {&#xD;&#xA;            dp[0][i] = dp[0][i - 1] + arr[0][i];&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    for(int i = 1 ;i &lt; m; i++){&#xD;&#xA;        for(int j = 1; j &lt; n; j++){&#xD;&#xA;            if(arr[i][j] == 0){&#xD;&#xA;                dp[i][j] = INT32_MAX;&#xD;&#xA;            }else {&#xD;&#xA;                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + arr[i][j];&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    printf(&#34;%d&#34;,dp[m - 1][n - 1]);&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;&lt;button class=&#34;copy-button&#34; data-clipboard-target=&#34;#code1&#34;&gt;Copy&lt;/button&gt;&#xD;&#xA;&lt;/div&gt;&#xD;&#xA;&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;&#xA;&lt;p&gt;只有第三题的代码的原因是，我没有在本地idea存储每一题的答案，所以只剩下最后的，就顺便贴上了。对于这次笔试，我得了60分，最后一题没有AC，可能还是因为我平常不会经常去有目的性的去刷题，所以做题目的速度比较慢，导致最后只差一点点但是来不及写完了。我做题的过程首先就是思路的产生，再到将思路转化为实践，最后是实践中的边界情况讨论。第一题我就写了半个小时，要花费很多时间去找到出错的边界。第二题也是一样的情况，写完第二题只剩半个小时了。而第三题一开始我甚至没看到障碍的情况，导致虽然找到了问题的核心，但距离写出题目浪费了很多时间，最后找到原因之后也已经来不及了，虽然最后还是花了几分钟把它写完了，不过算是有点可惜。&lt;/p&gt;</description>
    </item>
    <item>
      <title>我的博客网站搭建进展丨01</title>
      <link>http://localhost:1313/posts/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%B1%95%E4%B8%A801/</link>
      <pubDate>Sun, 10 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%B1%95%E4%B8%A801/</guid>
      <description>&lt;h2 id=&#34;2024-11-07&#34;&gt;2024-11-07&lt;/h2&gt;&#xA;&lt;p&gt;在我写了几篇博客之后，通过实际的编写过程和这期间看到的别的内容，我发现用单纯的Markdown语法来写并不能达到我想要的效果。并且我通过对比发现我在Typora里编辑的 html 语法是可以被识别到并正确运行的，不过可能由于我本身博客的框架基础，在web页面并没有被正确加载，所以我决定研究一下我的 post 具体是怎样被加载的。&lt;/p&gt;&#xA;&lt;p&gt;经过研究发现，我的书写内容没有问题，post 的加载也没有问题，在&lt;a href=&#34;https://juejin.cn/post/7119681369831112741&#34;&gt;修复Hugo静态生成器中忽略原始HTML的方法&lt;/a&gt;中我找到了问题的答案，原来是因为渲染的markdown不能理解我在短代码中的HTML。从Hugo V.0.60开始，默认的markdown渲染器是Gold mark。Goldmark渲染引擎默认忽略了原始HTML。所以我必须使用配置参数来告诉它。这个解决方案可以让Markdown渲染器使用Goldmark渲染器，通过配置考虑原始HTML。&lt;/p&gt;&#xA;&lt;p&gt;修复方法是在配置文件中加入&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;style=&#34;position:relative;&#34;&gt;&lt;pre&gt;&lt;code id = &#34;code1&#34;&gt;[markup]&#xD;&#xA;  [markup.goldmark]&#xD;&#xA;    [markup.goldmark.renderer]&#xD;&#xA;      unsafe = true&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;&lt;button class=&#34;copy-button&#34; data-clipboard-target=&#34;#code1&#34;&gt;Copy&lt;/button&gt;&#xD;&#xA;&lt;/div&gt;&#xD;&#xA;&lt;p&gt;这里我正在使用 config.toml 文件，若是 yaml 文件参考文章给出的格式。这时候我之前的 html 语句就被正确加载了。&lt;/p&gt;&#xA;&lt;p&gt;第二个问题是我之前插入了很多图片都没有被正确加载，我觉得可能是因为文件路径的问题。因为上一个问题我是先问的 gpt ，其实 gpt 给出的方案和正确方案是比较类似的，但他没有意识到她提到的 blackfriday 渲染器已经不再使用了，导致我花费很多时间找到真正的原因，所以这一次我也觉得先在搜索引擎中找答案。根据 &lt;a href=&#34;https://blog.csdn.net/qq_38340601/article/details/108900666&#34;&gt;hugo 导入图片的两种方式&lt;/a&gt;我也完成了我的图片导入。但是后续我想到了一些问题，就是我的 content\cn\posts 内文件本身是没有额外文件夹的，但是在 hugo 启动之后生成的 public 文件夹中是针对每个 md 文件有一个文件夹的，其中放了 html 文件，所以我的做法就是将图片放在这个文件夹之下。我想到的是什么呢，就是说这个文件是一个缓存文件，如果我执行了清除缓存的命令，我里面的图片就没了，我测试了一下，果然没了。但是 edge 里面还能看到，我猜测是因为 edge 本身缓存了这个图片，于是我打开 chrome 试了一下果然，这张图片已经看不到了，所以我现在要理解这个过程，将图片放在一个一劳永逸的地方。为什么我不直接放在 content 目录先呢，因为这里面原来都是单独的 md 文件，我担心将 md 文件放入文件夹中会影响 hugo 构建的过程。这次我直接询问 gpt 得到了答案，我可以在 post 文件夹下额外新建一个对应 md 文件的文件夹，然后将相应的图片放入即可，这样 hugo 自然会将图片放入 public 对应的文件夹和 html 文件在一起。在这之前，~~我找到了回收站中被清除的图片。~~我重新上传了需要的图片。&lt;/p&gt;</description>
    </item>
    <item>
      <title>网络安全与检测技术作业丨01</title>
      <link>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E4%BD%9C%E4%B8%9A%E4%B8%A801/</link>
      <pubDate>Sat, 09 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E4%BD%9C%E4%B8%9A%E4%B8%A801/</guid>
      <description>&lt;h2 id=&#34;题目&#34;&gt;题目&lt;/h2&gt;&#xA;&lt;p&gt;作业的内容是&lt;a style=&#34;color: #0000FF;&#34; href=&#34;网络安全与检测技术作业 1.pdf&#34; target=&#34;_blank&#34;&gt;网络安全与检测技术 作业 1&lt;/a&gt;，其中第八题的内容是：&lt;/p&gt;&#xA;&lt;img src=&#34;8.png&#34; /&gt;&#xD;&#xA;&lt;h2 id=&#34;我的答案&#34;&gt;我的答案&lt;/h2&gt;&#xA;&lt;p&gt;1.(1)Mi=Dk(Ci⊕Ci−1)⊕Ci-1&lt;/p&gt;&#xA;&lt;p&gt;(2)在AES-CBS-STAR模式中，每个密文分组Ci依赖于前一个密文分组Ci−1，即加密过程是串行的，无法进行并行化。&lt;/p&gt;&#xA;&lt;p&gt;解密过程中Mi的计算也依赖于前一个密文分组Ci−1，因此，解密过程也是串行的。&lt;/p&gt;&#xA;&lt;p&gt;所以AES-CBS-STAR模式既不能并行加密，也不能并行解密。&lt;/p&gt;&#xA;&lt;p&gt;(3)由于C0=IV0是已知的，对手能够根据选择的明文和已知的IV，推测出初始密文分组C1或其他分组。然后攻击者可以分析密文序列中的变化趋势，利用IV的已知值推断出明文。&lt;/p&gt;&#xA;&lt;p&gt;2.(1)在ECB模式中，每个分组的加密是独立的，只会影响第8个明文分组的第17比特。&lt;/p&gt;&#xA;&lt;p&gt;(2)CTR模式的密文模块之间是独立的，因此一个密文模块的污染只会影响相应的明文模块。第2和第3个明文分组都将被污染。&lt;/p&gt;&#xA;&lt;p&gt;(3)OFB模式中,密文生成是通过明文与一个伪随机序列进行异或来完成的,密文模块之间是独立的，只会影响第7个明文分组。&lt;/p&gt;&#xA;&lt;p&gt;(4)CBC模式中，每个明文分组与前一个密文分组进行异或操作,会影响当前分组的解密结果和下一个分组的解密结果。会影响第9个明文分组的第16和第17比特，以及第10个明文分组的第16和第17比特。&lt;/p&gt;&#xA;&lt;p&gt;(5)CFB模式中，密文是通过明文与来自加密器输出的前几个比特进行异或来生成的。会影响第12个明文分组的第3到第6比特，以及以后所有明文分组的所有比特。&lt;/p&gt;&#xA;&lt;p&gt;3.这种方法与RSA不等价在RSA中，e（相当于这里的E）的选择是有一定条件的，通常要求e与(P-1)(Q-1)互质，这样才能保证解密的唯一性和正确性。而这里不满足RSA中的选择条件，解密指数D未必存在，或者可能存在多个解，无法保证解密过程的正确性。所以该方法不是RSA算法。&lt;/p&gt;&#xA;&lt;p&gt;4.假设我们希望找到一对新的分组C1和C2，使得：&lt;/p&gt;&#xA;&lt;p&gt;RSAH(C1,C2)=RSAH(B1,B2)即&lt;/p&gt;&#xA;&lt;p&gt;RSA(E(C1)⊕C2)=RSA(E(B1)⊕B2)&lt;/p&gt;&#xA;&lt;p&gt;由于RSA是一个可逆操作，给定密文，我们可以通过逆向操作（即RSA解密）得到对应的明文。因此，如果我们有密文E(B1)⊕B2，我们可以通过适当选择C1和C2来调整这个结果，使其匹配。&lt;/p&gt;&#xA;&lt;p&gt;我们可以选择：&lt;/p&gt;&#xA;&lt;p&gt;C2=B2⊕(E(C1)⊕E(B1))这样，RSA(C1,C2)就会与RSA(B1,B2)相同。因此，该Hash函数是不安全的，它不满足抗弱碰撞性。&lt;/p&gt;&#xA;&lt;p&gt;5.攻击者可以利用逐字节比较的特性，通过逐字节猜测sig_bytes的正确值。在每次对比时，比较操作会在不匹配的字节处提前结束。可以通过监控每次比较的时间差来判断哪些字节匹配。通常，匹配的字节会导致较长的比较时间（因为继续进行字节比较），而不匹配的字节会导致较短的比较时间。利用这个反馈信息，攻击者就可以逐步恢复正确的签名。&lt;/p&gt;&#xA;&lt;p&gt;我们可以使用常数时间比较：&lt;/p&gt;&#xA;&lt;p&gt;importhmac&lt;/p&gt;&#xA;&lt;p&gt;defverify(key,msg,sig_bytes):&lt;/p&gt;&#xA;&lt;p&gt;returnhmac.compare_digest(HMAC(key,msg),sig_bytes)&lt;/p&gt;&#xA;&lt;p&gt;6.(1)Bob能解密密文c并获得明文m的条件是密文c中包含了可以通过对称加密解密或通过私钥解签名获得的明文。&lt;/p&gt;&#xA;&lt;p&gt;(a)这种方式使用了哈希函数对密文Enc(K,m)进行哈希计算。哈希函数是单向的，Bob无法获得明文m，&lt;/p&gt;&#xA;&lt;p&gt;(b)中，c1是通过对称加密得到的密文，Bob使用对称密钥K可以解密c1得到m。c2只是Enc(K,m)的哈希，Bob不需要它来获取明文m。(c)中c1是加密后的密文，Bob可以使用K解密得到m，c2是对m的MAC（消息认证码），它主要用于验证消息的完整性。&lt;/p&gt;&#xA;&lt;p&gt;(d)中c1是加密的密文，Bob可以解密它得到m。c2是对加密后密文的MAC，用于完整性验证。&lt;/p&gt;&#xA;&lt;p&gt;(e)这里，c是Alice使用私钥SKA对加密消息Enc(K,m)的签名。Bob可以使用Alice的公钥PKA来验证签名，然后Bob可以根据对称密钥K解密Enc(K,m)。&lt;/p&gt;&#xA;&lt;p&gt;(f)中c1是加密后的明文m，Bob使用K解密得到m。c2是对明文m的签名（加密过），Bob可以解密c2并验证签名，但这不会影响c1中的解密过程。&lt;/p&gt;&#xA;&lt;p&gt;Bob能解密c获得明文m的方式是(b)、(c)、(d)、(e)、(f)。&lt;/p&gt;&#xA;&lt;p&gt;(2) (a)是通过哈希函数对密文进行处理，而哈希函数本身是单向的，不涉及加密，所以不能提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(b)是对称加密的密文，提供了机密性保护，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(c)是对称加密的密文，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(d)是对称加密的密文，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(e)是加密的密文，提供了机密性保护，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;(f)是对称加密的密文，可以提供机密性保护。&lt;/p&gt;&#xA;&lt;p&gt;可以提供机密性保护的方式是(b)、(c)、(d)、(e)、(f)。&lt;/p&gt;&#xA;&lt;p&gt;(3) (a)只能提供单向验证，但不能验证消息是否在传输中被篡改，不能提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(b)中c2是Enc(K,m)的哈希值，可以用于验证密文是否被篡改，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(c)中c2是对消息m的MAC，可以验证消息的完整性，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(d)中c2是对密文Enc(K,m)的MAC，可以验证密文是否被篡改，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(e)Sign(SKA,Enc(K,m))是对密文的签名，可以验证密文是否被篡改，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;(f)中c2是对明文m的签名的加密，可以用于验证消息的完整性，因此可以提供完整性保护。&lt;/p&gt;&#xA;&lt;p&gt;可以提供完整性保护的方式是(b)、(c)、(d)、(e)、(f)。&lt;/p&gt;&#xA;&lt;p&gt;(4)选择方式(c)：c=c1,c2:c1=Enc(K,m),c2=MAC(K,m)，它同时提供了机密性和完整性保护。为了防止重放攻击，我们可以在消息中添加时间戳或唯一的随机数nonce。&lt;/p&gt;&#xA;&lt;p&gt;7.(1)一种可能的攻击角度是伪造人脸图像进行攻击，即通过技术手段制造或操控一个与目标人物极为相似的面部图像或视频，从而欺骗门禁系统，绕过人脸识别机制进入系统。具体攻击方法可能包括以下几种：&lt;/p&gt;&#xA;&lt;p&gt;照片攻击：使用目标用户的照片，将其展示给门禁系统的摄像头来欺骗系统。&lt;/p&gt;&#xA;&lt;p&gt;视频攻击：通过录制目标用户的正常活动（例如走路、说话等），再通过播放视频来进行攻击，模拟目标的面部动态。&lt;/p&gt;&#xA;&lt;p&gt;3D模型攻击：通过3D打印技术制造出目标人物的面部模型，并将其放置在摄像头前，试图欺骗识别系统。&lt;/p&gt;&#xA;&lt;p&gt;深度学习攻击：利用深度学习技术生成目标人物的虚假面部图像或视频，进行欺骗。&lt;/p&gt;&#xA;&lt;p&gt;威胁模型：&lt;/p&gt;&#xA;&lt;p&gt;资产：门禁后的区域安全、生物识别数据、门禁系统完整性。&lt;/p&gt;&#xA;&lt;p&gt;对手：外部无通行权限的攻击者，获取门禁后的被保护的东西&lt;/p&gt;&#xA;&lt;p&gt;漏洞：识别技术不精确、缺乏活体检测、数据传输不加密。&lt;/p&gt;&#xA;&lt;p&gt;威胁：伪造身份、深度伪造、数据截获。&lt;/p&gt;&#xA;&lt;p&gt;风险：高价值区域和用户数据泄露，漏洞可能性较大。&lt;/p&gt;&#xA;&lt;p&gt;防御：活体检测、多因素认证、加密传输。&lt;/p&gt;&#xA;&lt;p&gt;(2)安全性质：&lt;/p&gt;&#xA;&lt;p&gt;KnowYourThreatModel：&#xA;确定潜在威胁和攻击者，包括外部黑客、内部员工、以及中间人。了解攻击者的动机、能力和目标。&lt;/p&gt;&#xA;&lt;p&gt;SecurityisEconomics：&#xA;评估安全防护的成本和攻击的潜在损失，确保在合理的成本范围内实现最佳安全效果。&lt;/p&gt;</description>
    </item>
    <item>
      <title>网络安全与检测技术学习笔记丨01</title>
      <link>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A801/</link>
      <pubDate>Sat, 09 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A801/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;这次学习是因为该课程布置了第一次作业，所以需要补充学习一下遗漏的内容。由于这门课是本研共修课程，在开学第一周本科生们就已经选好课并且开始上课了，但是我们新入学的研究生从第三周才能选好课并开始上课。这导致我最终其实第四周左右才选上这门课，所以遗漏了前面的很多内容，上课时感到很不连贯也就没有细听了，最终决定采用根据PPT自学的形式来完成这次布置的第一次作业。&lt;/p&gt;&#xA;&lt;h2 id=&#34;lec01-intro&#34;&gt;Lec01 Intro&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Ethics&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通常可以闯入自己的系统&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这是评估自己系统的好办法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;在获得他人明确许可的情况下，通常可以闯入他人的系统&lt;/li&gt;&#xA;&lt;li&gt;未经许可闯入他人的系统是不道德且犯罪的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;系统失效的原因：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Reliability：意外故障&lt;/li&gt;&#xA;&lt;li&gt;Usability：因用户操作错误而引起的问题&lt;/li&gt;&#xA;&lt;li&gt;Design and goal oversights：设计过程中的疏忽、错误和遗漏&lt;/li&gt;&#xA;&lt;li&gt;Security：他人故意造成的故障&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Security VS. Correctness：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;System correctness：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;系统满足规范&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于合理输入，获得合理输出&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;System security：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在面对攻击时保留系统属性&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于不合理的的输入，输出不完全错误&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;主要区别：主动干扰&lt;/p&gt;&#xA;&lt;p&gt;Course Overview&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如何考虑安全和隐私&#xA;&lt;ul&gt;&#xA;&lt;li&gt;“Security Mind” ——一种思考系统的全新方式&lt;/li&gt;&#xA;&lt;li&gt;Security Principles&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;安全和隐私的&lt;strong&gt;技术&lt;/strong&gt;方面&#xA;&lt;ul&gt;&#xA;&lt;li&gt;漏洞和攻击技术&lt;/li&gt;&#xA;&lt;li&gt;防御技术&lt;/li&gt;&#xA;&lt;li&gt;如何构建具有强大安全属性的计算机系统&lt;/li&gt;&#xA;&lt;li&gt;如何衡量当今技术提供的保护和限制&lt;/li&gt;&#xA;&lt;li&gt;攻击在实践中的工作原理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;主题包括&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本密码学&lt;/li&gt;&#xA;&lt;li&gt;认证&lt;/li&gt;&#xA;&lt;li&gt;密钥管理&lt;/li&gt;&#xA;&lt;li&gt;可用安全性（人工身份验证）&lt;/li&gt;&#xA;&lt;li&gt;网络安全&lt;/li&gt;&#xA;&lt;li&gt;数据安全和隐私&#xA;&lt;ul&gt;&#xA;&lt;li&gt;匿名和差分隐私&lt;/li&gt;&#xA;&lt;li&gt;联邦学习&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Emerging Technologies 的安全&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ML的安全性&lt;/li&gt;&#xA;&lt;li&gt;自动驾驶汽车的安全性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;lec02-secbasics&#34;&gt;Lec02 SecBasics&lt;/h2&gt;&#xA;&lt;h3 id=&#34;objects&#34;&gt;Objects&lt;/h3&gt;&#xA;&lt;h4 id=&#34;confidentiality保密性&#34;&gt;Confidentiality（保密性）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Confidentiality 是信息的隐瞒&lt;/li&gt;&#xA;&lt;li&gt;Data Confidentiality：确保私人或机密信息不会提供给或披露给未经授权的个人&lt;/li&gt;&#xA;&lt;li&gt;&lt;font color=gray&gt;Privacy：确保个人控制或影响哪些和他们有关的信息被收集，以及这些信息会被谁以及向谁披露&lt;/font&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;integrity完整性&#34;&gt;Integrity（完整性）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Integrity 是防止未经授权的更改&lt;/li&gt;&#xA;&lt;li&gt;Data Integrity：确保数据和信息仅以指定和授权的方式进行更改&lt;/li&gt;&#xA;&lt;li&gt;System Integrity：确保系统以不受损害的方式执行预期功能，不受故意或无意的未经授权的操作对系统执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;availability可用性&#34;&gt;Availability（可用性）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Availability 是使用信息或资源的能力&lt;/li&gt;&#xA;&lt;li&gt;确保系统迅速工作，并且不会拒绝向授权用户提供服务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;thread-modeling&#34;&gt;Thread Modeling&lt;/h3&gt;&#xA;&lt;p&gt;Assets：我们要保护什么？这个资产有多少价值？&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析学习笔记丨07过程间分析</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A807%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%A807%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;因为上周三忙着做团支书的工作以及各种其他事情，课上没有仔细的听，所以之后再花时间重新看b站的视频课程。顺便就此机会准备后面的课都通过视频的形式来学习了。这门课还是在观看视频的时候反复理解和思考才是更高效的，即使我之前会线下去上课，回来之后还是有一些地方要自己好好研究的。所以后续以这种形式既不会错过知识内容，也可以增加我的效率。&lt;/p&gt;&#xA;&lt;p&gt;从这节课开始就是从谭添老师开始上了，前面听说从这一部分开始会有一些动态的分析，而且难度也会开始变得更高。针对过程间分析我们要了解的主要有 Call Graph Construction（ CHA ）、Interprocedural Control-Flow Graph 和 Interprocedural Data-Flow Analysis。&lt;/p&gt;&#xA;&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;过程内分析过于保守，假设调用后都不是常量，丢失了精度。所以我们需要过程间分析，首先就需要调用图，来得到调用边（Call edges）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;call-graph-construction-cha-&#34;&gt;Call Graph Construction（ CHA ）&lt;/h2&gt;&#xA;&lt;p&gt;一个调用图是一个从 call-sites 到目标方法的调用边的集合。&lt;/p&gt;&#xA;&lt;img src=&#34;call-graph.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;本课程主要对 OOPLs 构建调用图(focus on Java)，这节课会学习Class hierarchy analysis（ CHA ），下节课会学习Pointer analysis（k-CFA）。&lt;/p&gt;&#xA;&lt;img src=&#34;1.png&#34; /&gt;&#xD;&#xA;&lt;p&gt;越往上速度越快，越往下精度越高。&lt;/p&gt;&#xA;&lt;p&gt;了解JAVA中的call：&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xD;&#xA;  &lt;thead&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;th&gt;&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Static call&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Special call&lt;/th&gt;&#xD;&#xA;      &lt;th&gt;Virtual call&lt;/th&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/thead&gt;&#xD;&#xA;  &lt;tbody&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Instruction&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokestatic&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokespecial&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;invokeinterface&lt;br&gt;invokevirtual&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Receiver objects&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;×无实例&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;√有实例&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;√有实例&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Target methods&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Static methods (静态方法)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Constructors (构造函数)&lt;br&gt;&lt;strong&gt;·&lt;/strong&gt;Private instance methods (类自己的私有方法)&lt;br&gt;&lt;strong&gt;·&lt;/strong&gt;Superclass instance methods (父类的实例方法)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;&lt;strong&gt;·&lt;/strong&gt;Other instance methods (其他实例方法)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;# Target methods 个数&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;1&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;1&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;≥1 (polymorphism) 多态&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;    &lt;tr&gt;&#xD;&#xA;      &lt;td&gt;Determinacy 确定时机&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Compile-time (编译时)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Compile-time (编译时)&lt;/td&gt;&#xD;&#xA;      &lt;td&gt;Run-time (运行时)&lt;/td&gt;&#xD;&#xA;    &lt;/tr&gt;&#xD;&#xA;  &lt;/tbody&gt;&#xD;&#xA;&lt;/table&gt;&#xD;&#xA;&lt;p&gt;构造调用图的关键在于处理virtual call，其中关键的一个步骤叫做Method Dispatch，基于：&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件分析实验笔记丨A3</title>
      <link>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a3/</link>
      <pubDate>Wed, 06 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%E4%B8%A8a3/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;因为开始写博客的时间已经完成了前两次的实验，所以也不打算重新补写前两次的实验笔记了。如果增加这个工作量我肯定会对写博客产生抵触心理，因为我补充了这个那我后续在其他方面不能不补充厚此薄彼吧，这样一下子积压了大量需要补充的内容压力过大会导致我直接化身怯战蜥蜴——放弃。&lt;/p&gt;&#xA;&lt;p&gt;作业3：死代码检测，并不是我们上课学习的内容，但是通过组合我前两次作业中实现的分析方法：&lt;strong&gt;活跃变量分析&lt;/strong&gt;和&lt;strong&gt;常量传播&lt;/strong&gt;，可以实现一个Java的死代码检测算法。&lt;/p&gt;&#xA;&lt;p&gt;课程网站为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/lectures.html&#34; target=&#34;_blank&#34;&gt;Static Program Analysis | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本次实验为&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://tai-e.pascal-lab.net/pa3.html&#34; target=&#34;_blank&#34;&gt;作业 3：死代码检测 | Tai-e&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;死代码检测介绍&#34;&gt;死代码检测介绍&lt;/h2&gt;&#xA;&lt;p&gt;死代码指的是程序中不可达的（unreachable）代码（即不会被执行的代码），或者是执行结果永远不会被其他计算过程用到的代码。去除死代码可以在不影响程序输出的前提下简化程序、提高效率。我们在这次实验中考虑两种死代码：&lt;strong&gt;不可达代码&lt;/strong&gt;（unreachable code）和&lt;strong&gt;无用赋值&lt;/strong&gt;（unreachable code）。这好像正好分别对应了常量传播和活跃变量分析。&lt;/p&gt;&#xA;&lt;h3 id=&#34;不可达代码&#34;&gt;不可达代码&lt;/h3&gt;&#xA;&lt;p&gt;一个程序中永远不可能被执行的代码被称为不可达代码。我们考虑两种不可达代码：&lt;strong&gt;控制流不可达代码&lt;/strong&gt;（control-flow unreachable code）和&lt;strong&gt;分支不可达代码&lt;/strong&gt;（unreachable branch）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;控制流不可达代码&lt;/strong&gt;：在一个方法中，如果不存在从程序入口到达某一段代码的控制流路径，那么这一段代码就是控制流不可达的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：利用所在方法的控制流图（CFG，即 control-flow graph）检测出来。我们只需要从方法入口开始，遍历 CFG 并标记可达语句。当遍历结束时，那些没有被标记的语句就是&lt;strong&gt;控制流不可达&lt;/strong&gt;的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;分支不可达代码&lt;/strong&gt;：在 Java 中有两种分支语句：if 语句和 switch 语句。它们可能会导致分支不可达代码的出现。&lt;/p&gt;&#xA;&lt;p&gt;对于一个 if 语句，如果它的条件值（通过常量传播得知）是一个常数，那么无论程序怎么执行，它两个分支中的其中一个分支都不会被走到。这样的分支被称为&lt;strong&gt;不可达分支&lt;/strong&gt;。该分支下的代码也因此是不可达的，被称为分支不可达代码。&lt;/p&gt;&#xA;&lt;p&gt;对于一个 switch 语句，如果它的条件值是一个常数，那么不符合条件值的 case 分支就&lt;strong&gt;可能&lt;/strong&gt;是不可达的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：为了检测分支不可达代码，我们需要预先对被检测代码应用常量传播分析，通过它来告诉我们条件值是否为常量，然后在遍历 CFG 时，我们不进入相应的不可达分支。&lt;/p&gt;&#xA;&lt;h3 id=&#34;无用赋值&#34;&gt;无用赋值&lt;/h3&gt;&#xA;&lt;p&gt;一个局部变量在一条语句中被赋值，但再也没有被该语句后面的语句读取，这样的变量和语句分别被称为无用变量（dead variable，与活跃变量 live variable 相对）和无用赋值。无用赋值不会影响程序的输出，因而可以被去除。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;检测方式&lt;/strong&gt;：为了检测无用赋值，我们需要预先对被检测代码施用活跃变量分析。对于一个赋值语句，如果它等号左侧的变量（LHS 变量）是一个无用变量（换句话说，not live），那么我们可以把它标记为一个无用赋值。&lt;/p&gt;&#xA;&lt;p&gt;但需要注意的是，以上讨论有一种例外情况：有时即使等号左边的变量 &lt;code&gt;x&lt;/code&gt; 是无用变量，它所属的赋值语句 &lt;code&gt;x = expr&lt;/code&gt; 也不能被去除，因为右边的表达式 &lt;code&gt;expr&lt;/code&gt; 可能带有某些副作用。例如，当 &lt;code&gt;expr&lt;/code&gt; 是一个方法调用（&lt;code&gt;x = m()&lt;/code&gt;）时，它就有可能带有副作用，可能在m()中改变了某些值。对于这种情况，作业提供了一个 API 供检查等号右边的表达式是否可能带有副作用。如果带有副作用，那么为了保证 safety，即使 &lt;code&gt;x&lt;/code&gt; 不是一个活跃变量，也不应该把这个赋值语句标记为死代码。&lt;/p&gt;</description>
    </item>
    <item>
      <title>去除冗余的Java依赖</title>
      <link>http://localhost:1313/posts/%E5%8E%BB%E9%99%A4%E5%86%97%E4%BD%99%E7%9A%84java%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Mon, 04 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%8E%BB%E9%99%A4%E5%86%97%E4%BD%99%E7%9A%84java%E4%BE%9D%E8%B5%96/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;这是本周三我要分享的论文，在这里浅谈一下我对于&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://ieeexplore.ieee.org/abstract/document/10549332&#34; target=&#34;_blank&#34;&gt;Efficiently Trimming the Fat: Streamlining Software Dependencies with Java Reflection and Dependency Analysis&lt;/a&gt;的理解。&lt;/p&gt;&#xA;&lt;h2 id=&#34;contributions&#34;&gt;Contributions&lt;/h2&gt;&#xA;&lt;div style=&#34;border-left:4px solid green;padding-left:10px;&#34;&gt;&lt;font color=#686868&gt;&#xD;&#xA;An effective debloating tool called Slimming &lt;br&gt;&lt;br&gt;&#xD;&#xA;Comprehensive datasets. (1) a high-quality benchmark including 3,520 reflective calls captured by dynamic techniques from a collection of framework-based Java projects for evaluating the effectiveness of reflection analysis techniques; (2) a dataset of 40 projects with 100% test coverage for Java byte code instructions for evaluating the reliability of debloating solutions.”&lt;/font&gt;&lt;/div&gt;&#xD;&#xA;这篇文章的贡献包括提供了有效的去臃肿工具，以及一个全面的数据集，分别提供用于评估反射分析有效性和可靠性。包含3520个从框架型JAVA项目中通过动态技术捕获的反射调用，还包含40个字节码指令测试覆盖率达100%的JAVA项目。&#xD;&#xA;&lt;div style=&#34;border-left:4px solid green;padding-left:10px;&#34;&gt;&lt;font color=#686868&gt;Data Availability. We provided a reproduction package, including the above datasets, an available tool, and experiment raw data, on the [website](https://slimming-fat.github.io/) for facilitating future research.&lt;/font&gt;&lt;/div&gt;&#xD;&#xA;&lt;p&gt;另外还提供了&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://slimming-fat.github.io/&#34; target=&#34;_blank&#34;&gt;在线网站&lt;/a&gt;方便你来复现文章的内容。&lt;/p&gt;</description>
    </item>
    <item>
      <title>我的第一篇博客</title>
      <link>http://localhost:1313/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sat, 02 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</guid>
      <description>&lt;h2 id=&#34;契机与想法&#34;&gt;契机与想法&lt;/h2&gt;&#xA;&lt;p&gt;这是我的第一篇博客，同时也是我参加王道助教工作的第一天，在这个工作的时间搭建了一个简单的博客网站。首先，想要写博客这个想法的契机来源于我在写南京大学软件分析课程作业时，遇到了未通过的样例且思索无果，可以说我是百思不得其解，但是又十分想要AC。这时我在搜索引擎上搜索而看到的一个计算机领域前辈大佬的笔记&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://blog.wohin.me/posts/nju-program-analysis-a2/&#34; target=&#34;_blank&#34;&gt;南大软分实验笔记｜A2&lt;/a&gt;，我为这样形式的内容而感到惊喜，不仅让我解决了当时遇到的困难，还给我一种启发。说实话，这是我第一次在计算机领域接触到这种记录自己的心路历程以及解决问题过程的形式，单纯的记录与分享却让我受益良多，无论是从问题解决还是解决问题的能力上。&lt;/p&gt;&#xA;&lt;p&gt;其实，这种感叹和惊喜从我开始在南大读研之后就常常发生。像是打开了新世纪的大门。在原来，程序员的世界在我看来是一个黑白，理性，充满逻辑的世界。给我的抽象感觉是一个摆放在黑白棋盘格上的天平，纯粹的同时不会给我的生活带来太多的色彩。现在我认识到了许多优秀的老师~~（单方面）~~以及见到了许多优秀的课程让我觉得原来学计算机也这么有意思。&lt;/p&gt;&#xA;&lt;p&gt;在这之后，我想到我还有那么多优秀的课想要去学，有很多感兴趣的事情想要去做，加上平时的作业与科研也可以以这样一种形式来呈现，还想到自己曾经想过的写日记的想法等等。在昨天凌晨一点我再也克制不住这样的想法，于是起来开始准备搭建这样的一个属于我自己的博客网站，一个我在计算机，在程序员世界的小家，同时会存下现实中的美好。&lt;/p&gt;&#xA;&lt;h2 id=&#34;博客搭建进度&#34;&gt;博客搭建进度&lt;/h2&gt;&#xA;&lt;p&gt;因为我对于前端不太熟悉，对于这样一件事情也是很茫然的。所以这个博客的搭建也完全来自于对Bonan前辈（上文的佬）在自己博客上的分享&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://blog.wohin.me/about/&#34; target=&#34;_blank&#34;&gt;About Me&lt;/a&gt;的拙劣模仿，以及结合在b站上的教程&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://www.bilibili.com/video/BV1bovfeaEtQ?spm_id_from=333.788.videopod.episodes&amp;vd_source=1837baf7c46a027b7e27b4ab7174fb85&#34; target=&#34;_blank&#34;&gt;Hugo + Github免费搭建博客&lt;/a&gt;的方式下，完成了一个小demo。由于非常喜欢这种简约的风格，所以没有换其他主题。我目前的想法除了完成这个主题的使用，同时将字体换成&lt;a style=&#34;color: #0000FF;&#34; href=&#34;https://github.com/lxgw/LxgwWenKai&#34; target=&#34;_blank&#34;&gt;“霞鹜文楷”&lt;/a&gt;，然后调整一下我的博客的结构，丰富其中的结构设计，以及加入深色模式功能和GitHub自动部署。目前完成了更换字体以及调整结构只留下了一条博客的目录，后续需要设计丰富一下。但是我现在可以先开始着手写一些内容了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;王道助教&#34;&gt;王道助教&lt;/h2&gt;&#xA;&lt;p&gt;因为之前参加过王道的线上培训课程，主要是做一个项目，现在看来是很简单了，但是当时帮助我掌握了很多知识和技巧。提到这个是因为王道当时上课的云龙老师在当时的课程群内发布了一条招聘助教的信息。我一想只需要在线上给同学们答疑就可以拿工资，多是一件美事，于是立马加了云龙老师的微信然后表达了我的意愿。虽然我没参加过这个叫做C语言督学营的课，但是我满足考研上岸211或985学校的同学，也算是拥有了一个面试的资格。想着都是一些简单的数据结构，我也就没有多做准备等待面试即可。就在昨天上午，十点半的时间，刚起床不久，我正吃着我母亲特地从菜市场给我带回来的咸豆腐脑和包子，刚刚把豆腐脑上撒的辣油和花生碎给拌开。也许是因为最近跟我母亲表达了我蛮喜欢吃花生米的意愿，所以上面的花生碎非常多。尝了没几口，收到了云龙老师的信息。就挺突然的，“现在是否方便面试，微信语音电话，预计10到15分钟的时间”，那我自然是积极回复，可以说是秒回了一句“龙哥你好方便的”。然后我便和母亲交代我有点事一会来吃，并叮嘱她一会不要来喊我，然后回房间等待面试。面试很快，9&#39;28，虽然说有些回答的磕磕绊绊，因为我对于一些专业术语反应的有点慢，归根到底我想还是记得不够牢固啊。总之，11:22分我收到了通过面试的消息，或许这是我第一份通过且接受的职位，也是我即将利用本专业知识赚取的第一碗金。是的，这时我就已经开始幻想轻松的答疑工作+拿钱了。我还挺上心的，我去看了基本上一大半的课件，完成了一大半的OJ题目，还挺费时间的，后来觉得不是太大问题，看了一下大纲就没在细细品读了。结果，今天的现实给了我沉重的打击，一是今天是周六，学习的同学比之前多特别多，虽然对于这个一共大约620人7个群的数量来说还算能接受，但也比较多了，二是遇到的问题基本上都是一长串的代码，因为是新手，他们不会根据报错和提示找到问题根源，所以我只能让他们发所有的源代码给我自己测试，还好都是比较基础的数据结构不算难理解，也很少遇到代码写的很奇怪的同学。不过我觉得这也在某种程度上加深我对数据结构的理解，真是教学相长啊。还有一个比较难受的特殊原因是，今天本来是要和我母亲一起去参加她同事儿子的婚礼，在这样的情况下，就让人比较纠结，最终我还是去了，在五点多解决了最后一个存在的问题之后。不过后续是我又早早回来了，因为在外面确实不方便，还好婚礼地点离我家不算远，加上我又有小电驴。这篇博客就是我回来之后开始写的，马上今天的答疑也快结束了。哦！我还写了一份不同时间点的提醒的文案，我要贴在下面留着，最下面是我找到的另外两个劝学的名言但没用上的。&lt;/p&gt;&#xA;&lt;table border=&#34;1&#34; cellpadding=&#34;10&#34; cellspacing=&#34;0&#34;&gt;&#xA;&lt;colgroup&gt;&#xA;    &lt;col style=&#34;width: 26%&#34;&gt;&#xA;    &lt;col style=&#34;width: 74%&#34;&gt;&#xA;  &lt;/colgroup&gt;&#xA;  &lt;thead&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;th&gt;时间点&lt;/th&gt;&#xA;      &lt;th&gt;提醒文案&lt;/th&gt;&#xA;    &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;早上9点开始&lt;/td&gt;&#xA;      &lt;td&gt;同学们早上好！为学患无疑，以则进也。遇到问题是进步的开始，大家可以在群里@我，我会努力帮助大家解答，如果问题较多可能会回复不及时还请大家多多包涵。如果漏了某些同学的问题还得麻烦再次提醒我一下，期待今天大家的提问。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;中午十二点休息&lt;/td&gt;&#xA;      &lt;td&gt;午休时间到，大家注意休息，保持充沛的精神体力，两点后答疑继续哦。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;下午两点开始&lt;/td&gt;&#xA;      &lt;td&gt;下午的答疑开始了，大家可以继续向我提问啦。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;晚上六点休息&lt;/td&gt;&#xA;      &lt;td&gt;晚饭时间到，休息一会，七点继续哦。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;晚上七点开始&lt;/td&gt;&#xA;      &lt;td&gt;晚上的答疑开始啦，欢迎提问。&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;晚上十点结束&lt;/td&gt;&#xA;      &lt;td&gt;今天的答疑时间就结束了哦，如果有遗漏和不清晰的地方可以再次@我！今天的学习也辛苦了，大家注意休息，可以早睡早起明天继续努力。同学们下次见！&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;    &lt;tr&gt;&#xA;      &lt;td&gt;人生在勤，勤则不匮。&lt;/td&gt;&#xA;      &lt;td&gt;人学始知道，不学非自然。——孟郊《劝学》&lt;/td&gt;&#xA;    &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;一会我就要发十点的文案了，幻想今天的答疑工作能收到好评。&lt;/p&gt;&#xA;&lt;h2 id=&#34;第一篇的总结&#34;&gt;第一篇的总结&lt;/h2&gt;&#xA;&lt;p&gt;万事开头难，虽然翻过了一座山，后面还有各种各样的山坡和丘陵，希望我能坚持记录。接下来可能会先写下周要分享的论文和下周二要交的论文报告。之后还可能会有软件分析的A3,A4作业，顺带一提我本来想补一下以前的内容，让这个成一套体系，但我仔细想了想先设立这个工作可能会让我有放弃的想法，所以我放弃了这个想法。之后应该还会有网安的作业，网易雷火比赛作品的开发日志，games101的学习记录等等，给自己画个小饼，希望自己多多加油努力呀！&lt;/p&gt;&#xA;&lt;p&gt;附一张我觉得有趣的图片：&lt;/p&gt;&#xA;&lt;img src=&#34;screen-shoot.jpg&#34; /&gt;&#xA;&lt;p&gt;是我在某时间点之前，将我的文案草稿全部复制粘贴好，到点就发，看着很好笑。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
